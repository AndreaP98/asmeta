<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ASMParser.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">report.aggregate</a> &gt; <a href="../index.html" class="el_bundle">asmeta.parser</a> &gt; <a href="index.source.html" class="el_package">org.asmeta.parser</a> &gt; <span class="el_source">ASMParser.java</span></div><h1>ASMParser.java</h1><pre class="source lang-java linenums">/* ASMParser.java */
/* Generated by: ParserGeneratorCC: Do not edit this line. ASMParser.java */
package org.asmeta.parser;
//import org.apache.log4j.PropertyConfigurator;
//Import JMIs
import asmeta.*;
import asmeta.definitions.*;
import asmeta.structure.*;
import asmeta.terms.*;
import asmeta.transitionrules.*;
import asmeta.definitions.domains.*;
import asmeta.terms.basicterms.*;
import asmeta.terms.furtherterms.*;
import asmeta.transitionrules.basictransitionrules.*;
import asmeta.transitionrules.derivedtransitionrules.*;
import asmeta.transitionrules.turbotransitionrules.*;
import java.io.FileOutputStream;
import java.io.File;
import java.util.*;
import java.nio.charset.Charset;

<span class="pc bpc" id="L22" title="1 of 2 branches missed.">public class ASMParser implements ASMParserConstants {</span>
  public static final String VERSION = &quot;2.0.0&quot;;

  public static final String asmExtension = &quot;.asm&quot;;

  private String filename; // file name without extension, needed to check that the name of the machine is the same

  private String asmDirLib; // where to find libraries

  private Header header; //the header section of the Asm

  //the declared domains. It associates domain names to the corresponding object.Its tuples are of kind(String,Domain)
<span class="pc" id="L34">  private HashMap &lt; String, Domain &gt; declared_Dom = new HashMap &lt; String, Domain &gt; ();</span>

  // the declared functions: those in the signature and those imported
<span class="pc" id="L37">  private HashMap &lt; String, List &lt; Function &gt; &gt; declared_Func = new HashMap &lt; String, List &lt; Function &gt; &gt; (); //the declared functions of the ASM. It associates function names to the list of functions with that name (a function can be overloaded).Its tuples are of kind(String,List&lt;Function&gt;)</span>

  //the ruleDeclarations of the ASM. It associates rule names to the corresponding object.Its tuples are of kind(String,RuleDeclaration)
<span class="pc" id="L40">  private HashMap &lt; String, List &lt; RuleDeclaration &gt; &gt; declared_Rules = new HashMap &lt; String, List &lt; RuleDeclaration &gt; &gt; ();</span>

  // it keeps memory of the already imported ASMs, to avoid importing of already imported ASM
  // keep static since it is shared among parser instances
  private static HashMap &lt; String, Asm &gt; alreadyImported;

  // real Any Domain
  private static final String anyDomainAnyName = &quot;Any&quot;;

  //the structured domains created during parsing. It associates domain names to the corresponding object. Its tuples are of kind(String,StructuredTD)
  // NO LONGER USED
  //private static HashMap&lt;String,Domain&gt; predefined_Dom = new HashMap&lt;String,Domain&gt;();    //the domains created during parsing. It associates domain names to the corresponding object. Its tuples are of kind(String,TypeDomain)
<span class="pc" id="L52">  private Map &lt; String, EnumTd &gt; enumElem = new HashMap(); //It associates enumeration element names to their enumeration domain. Its tuples are of kind(String,EnumTD)</span>

  //These hashMap associate the hashcode of the element name to the element name itself. Its tuples are of kind (Integer,String)
  private HashMap exported_Rules;

  private HashMap exported_Func;

  private HashMap exported_Dom;

  private boolean exportAll; //the value &quot;true&quot; indicates all functions and rule are exported

  // forse si puo' eliminare - non serve piu' AG
<span class="pc" id="L64">  private HashMap programs = new HashMap(); //the hashmap associating names of rule declarations (programs for agents) to the corresponding agent. Its tuples are of kind (Sting,AgentInitialization)</span>

  // these are no longer static because if it reads another (imported ASM)
  // this information must be shared. are shared by passing the argument to the new parser
  // are friendly: must be set before parsing ???
  private AsmetaFactory asmPk;

  private DefinitionsFactory defPack;

  private TermsFactory termsPack;

  private TransitionRulesFactory rulesPack;

  private StructureFactory structurePack;

  private asmeta.definitions.domains.DomainsFactory domainsFactory;

  /** this is set by the setUpReadExport to the parser used to read the first spec*/
  public static ASMParser asmParser;

  // only one logger: DANGER information is mixed
  // errors in imported lib appears errors in pmain file
  // TO BE FIXED
<span class="fc" id="L87">  private static ParserResultLogger Logger = new ParserResultLogger();</span>

  public static ParserResultLogger getResultLogger()
  {
<span class="nc" id="L91">    return Logger;</span>
  }

  /**
	 * It returns the collection of ASM
	 * create the EMF instances
	 * IT IS STATIC BECAUSE may use several parsers (included files and so on).
	 */
  public static AsmCollection setUpReadAsm(File f) throws Exception
  {
<span class="fc" id="L101">    Logger.resetForParsing(f);</span>
<span class="pc bpc" id="L102" title="2 of 6 branches missed.">    assert (f.exists() &amp;&amp; f.isFile());</span>
<span class="pc bpc" id="L103" title="2 of 4 branches missed.">    assert (f.getName().endsWith(asmExtension));</span>
<span class="fc" id="L104">    Logger.logInfo(&quot;parsing file &quot; + f.getAbsolutePath());</span>
    // reset the domains
<span class="fc" id="L106">    DomainsFactory.eINSTANCE.resetDomains();</span>
<span class="fc" id="L107">    Utility.reset();</span>
    // BUILD THE MODEL
    // init all imported so far
<span class="fc" id="L110">    alreadyImported = new HashMap &lt; String, Asm &gt; ();</span>
    // get the asmetafactory instance
<span class="fc" id="L112">    AsmetaFactory mainpackage = AsmetaFactory.eINSTANCE;</span>
    // builds the parser
<span class="fc" id="L114">    asmParser = new ASMParser(f, mainpackage);</span>
    // parses  the main Asm
<span class="fc" id="L116">    Optional&lt;asmeta.structure.Asm&gt; asm = asmParser.Asm();</span>
    // build the collection of ASM
<span class="fc" id="L118">    AsmCollection allAsms = new AsmCollection(alreadyImported.values());</span>
    // add this one as first one
<span class="fc bfc" id="L120" title="All 2 branches covered.">    if (asm.isPresent()) {</span>
<span class="fc" id="L121">      allAsms.addMain(asm.get());</span>
<span class="fc" id="L122">      Logger.logInfo(&quot;file successfully parsed for asm &quot; + asm.get().getName());</span>
    } else {
<span class="fc" id="L124">      Logger.logInfo(&quot;file successfully parsed but empty&quot;);</span>
    }
<span class="fc" id="L126">    return allAsms;</span>
  }

  /* The input file must have the same name of the ASM spec.
     * A file is needed because we need o set the path where to search
     * for libraries.
     * asmPack is the topmost level package of the metamodel.
     */
  private ASMParser(File f, AsmetaFactory asmPack) throws Exception
  {
<span class="fc" id="L136">    this (new java.io.FileInputStream(f),Charset.forName(&quot;UTF-8&quot;));</span>
    //Check the file name
<span class="pc bpc" id="L138" title="2 of 4 branches missed.">    if (!f.exists() || !f.isFile())</span>
    {
<span class="nc" id="L140">      Logger.fatal(&quot;Error:  &quot; + f.toString() + &quot; is not a file.&quot;);</span>
<span class="nc" id="L141">      throw new java.io.FileNotFoundException();</span>
    }
    //DUPLICATED CODE (see main() in MainParser)
    //if (!f.getName().endsWith(asmExtension)) {
    //	Logger.fatal(&quot;Error:  &quot; + f.toString() + &quot; is not an asm file.&quot;);
    //
    //	throw new Exception(&quot;Asm files must have &quot;+ asmExtension +&quot; extension&quot;);
    //}
    // get the filename without &quot;.asm&quot; extension
<span class="fc" id="L150">    filename = f.getName().substring(0, f.getName().length() - 4);</span>
    // the library is relative to this file
<span class="fc" id="L152">    asmDirLib = f.getParent();</span>
    // initialize other packages
    // Get references to package
<span class="fc" id="L155">    asmPk = asmPack;</span>
<span class="fc" id="L156">    defPack = asmPk.getDefinitions();</span>
<span class="fc" id="L157">    termsPack = asmPk.getTerms();</span>
<span class="fc" id="L158">    rulesPack = asmPk.getTransitionRules();</span>
<span class="fc" id="L159">    structurePack = asmPk.getStructure();</span>
<span class="fc" id="L160">    domainsFactory = defPack.getDomains();</span>
<span class="fc" id="L161">  }</span>

/***************************************************************/
/*                         GRAMMAR START                       */
/***************************************************************/
/***** MAIN OK!
se il file Ã¨ vuoto non restituisce nulla
*****/
<span class="fc" id="L169">  final public Optional&lt;Asm &gt; Asm() throws ParseException {boolean isAsm = true; // true states an ASM, false states a module</span>
  String name;
<span class="fc" id="L171">  boolean isAsyncr = false;</span>
  Header h;
  Initialization i;
  Body b;
  MacroDeclaration r;
<span class="fc" id="L176">  Asm asmMachine = null;</span>
<span class="pc bpc" id="L177" title="1 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case ASM:
    case MODULE:
    case ASYNCR:{
<span class="pc bpc" id="L181" title="1 of 4 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case ASYNCR:{
<span class="fc" id="L183">        jj_consume_token(ASYNCR);</span>
<span class="fc" id="L184">isAsyncr = true;</span>
<span class="fc" id="L185">        break;</span>
        }
      default:
<span class="fc" id="L188">        jj_la1[0] = jj_gen;</span>
        ;
      }
<span class="pc bpc" id="L191" title="1 of 5 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case ASM:{
<span class="fc" id="L193">        jj_consume_token(ASM);</span>
<span class="fc" id="L194">        break;</span>
        }
      case MODULE:{
<span class="fc" id="L197">        jj_consume_token(MODULE);</span>
<span class="fc" id="L198">isAsm = false;</span>
<span class="fc" id="L199">        break;</span>
        }
      default:
<span class="nc" id="L202">        jj_la1[1] = jj_gen;</span>
<span class="nc" id="L203">        jj_consume_token(-1);</span>
<span class="nc" id="L204">        throw new ParseException();</span>
      }
<span class="fc" id="L206">      name = ID();</span>
<span class="fc" id="L207">asmMachine = structurePack.createAsm(name, isAsyncr);</span>
<span class="fc" id="L208">      Logger.logDebug(&quot;ASM &quot; + name);</span>
<span class="pc bpc" id="L209" title="2 of 4 branches missed.">      if ((filename != null) &amp;&amp; !filename.equals(name)) throw new ParseException(&quot;Error: The file name \&quot;&quot; + filename + &quot;\&quot; is not equal to the asm name \&quot;&quot; + name + &quot;\&quot;.\n&quot;);</span>
<span class="fc" id="L210">      h = Header(asmMachine);</span>
//set the reference
<span class="fc" id="L212">      asmMachine.setHeaderSection(h);</span>
<span class="fc" id="L213">      b = Body(asmMachine);</span>
//set the reference
<span class="fc" id="L215">      asmMachine.setBodySection(b);</span>
<span class="pc bpc" id="L216" title="1 of 4 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case MAIN:{
<span class="fc" id="L218">        jj_consume_token(MAIN);</span>
<span class="fc" id="L219">        r = MacroDeclaration();</span>
//set the reference
<span class="fc" id="L221">        asmMachine.setMainrule(r);</span>
        // add also the main rule to the body (to avoid dangling resources) 
<span class="fc" id="L223">        b.getRuleDeclaration().add(r);</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">        if (!isAsm)</span>
        {
<span class="nc" id="L226">          Logger.logWarning(&quot;Warning: &quot; + filename + &quot; is a module. It cannot have a Main Rule.\n&quot;);</span>
        }
        break;
        }
      default:
<span class="fc" id="L231">        jj_la1[2] = jj_gen;</span>
        ;
      }
<span class="fc bfc" id="L234" title="All 4 branches covered.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case INIT:
      case Default:{
<span class="fc" id="L237">Collection &lt; Initialization &gt; initialStateColl = asmMachine.getInitialState();</span>
        label_1:
        while (true) {
<span class="pc bpc" id="L240" title="2 of 4 branches missed.">          switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
          case INIT:{
<span class="nc" id="L242">            break;</span>
            }
          default:
<span class="fc" id="L245">            jj_la1[3] = jj_gen;</span>
<span class="fc" id="L246">            break label_1;</span>
          }
<span class="nc" id="L248">          i = Initialization();</span>
//add it to the collection of initial states
<span class="nc" id="L250">          initialStateColl.add(i);</span>
        }
<span class="fc" id="L252">        jj_consume_token(Default);</span>
<span class="fc" id="L253">        i = Initialization();</span>
//add it to the collection of initial states
<span class="fc" id="L255">        initialStateColl.add(i);</span>
        //set the reference to the default initial state
<span class="fc" id="L257">        asmMachine.setDefaultInitialState(i);</span>
        label_2:
        while (true) {
<span class="pc bpc" id="L260" title="2 of 4 branches missed.">          switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
          case INIT:{
<span class="nc" id="L262">            break;</span>
            }
          default:
<span class="fc" id="L265">            jj_la1[4] = jj_gen;</span>
<span class="fc" id="L266">            break label_2;</span>
          }
<span class="nc" id="L268">          i = Initialization();</span>
//set the reference
<span class="nc" id="L270">          asmMachine.getInitialState().add(i);</span>
        }
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">if (!isAsm)</span>
        {
<span class="nc" id="L274">          Logger.logWarning(&quot;Warning: &quot; + filename + &quot; is a module. It cannot have any initial state.\n&quot;);</span>
        }
        break;
        }
      default:
<span class="fc" id="L279">        jj_la1[5] = jj_gen;</span>
        ;
      }
//Check OCL constraints
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">      if (!OCL_Checker.checkAsm(asmMachine))</span>
      {
<span class="nc" id="L285">        Logger.logErr(OCL_Checker.getMsgErr());</span>
<span class="nc" id="L286">        Logger.logErr(&quot;       At the Asm &quot; + name + &quot;.\n&quot;);</span>
      }
      break;
      }
    default:
<span class="fc" id="L291">      jj_la1[6] = jj_gen;</span>
      ;
    }
<span class="fc" id="L294">    jj_consume_token(0);</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">if (asmMachine== null) {if (&quot;&quot; != null) return Optional.empty();}</span>
<span class="fc" id="L296">    else {if (&quot;&quot; != null) return Optional.of(asmMachine);}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

//---------------------------HEADER OK! ---------------------------//
  final public Header Header(Asm m) throws ParseException {ImportClause i;
  ExportClause e;
  Signature s;
<span class="fc" id="L304">header = structurePack.createHeader();</span>
<span class="fc" id="L305">    s = structurePack.createSignature();</span>
<span class="fc" id="L306">    header.setSignature(s);</span>
    label_3:
    while (true) {
<span class="fc bfc" id="L309" title="All 4 branches covered.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case IMPORT:{
<span class="fc" id="L311">        break;</span>
        }
      default:
<span class="fc" id="L314">        jj_la1[7] = jj_gen;</span>
<span class="fc" id="L315">        break label_3;</span>
      }
<span class="fc" id="L317">      i = ImportClause();</span>
<span class="fc" id="L318">header.getImportClause().add(i);</span>
    }
<span class="pc bpc" id="L320" title="1 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case EXPORT:{
<span class="fc" id="L322">      e = ExportClause();</span>
<span class="fc" id="L323">header.setExportClause(e);</span>
<span class="fc" id="L324">      break;</span>
      }
    default:
<span class="fc" id="L327">      jj_la1[8] = jj_gen;</span>
      ;
    }
<span class="fc" id="L330">    s = Signature(s);</span>
<span class="fc" id="L331">{if (&quot;&quot; != null) return header;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

/*-----------------------*/
  final public ImportClause ImportClause() throws ParseException {String moduleName;
  String importedID;
  Function f;
  Domain d;
  RuleDeclaration r;
<span class="fc" id="L341">  boolean importAll = true; //the value true indicates to import all the exportClause of the other module</span>

<span class="fc" id="L343">    jj_consume_token(IMPORT);</span>
<span class="fc" id="L344">    moduleName = MOD_ID();</span>
// if it is escaped by double quotes, remove them
<span class="fc bfc" id="L346" title="All 2 branches covered.">    if (moduleName.startsWith(&quot;\&quot;&quot;))</span>
    {
<span class="fc" id="L348">      moduleName = moduleName.substring(1, moduleName.length() - 1);</span>
    }
    //
<span class="fc" id="L351">    ImportClause impClause = structurePack.createImportClause();</span>
<span class="fc" id="L352">    impClause.setModuleName(moduleName);</span>
    // it should compute again asmLibPath relatively the import ...??
    // if (asmDirLib == null) asmDirLib = &quot;.&quot;;
<span class="fc" id="L355">    Asm module_asm = null;</span>
<span class="fc" id="L356">    String moduleFileName = null;</span>
    try
    {
      // find the imported module file
<span class="fc" id="L360">      File moduleFile = Utility.importFile(asmDirLib, moduleName);</span>
<span class="fc" id="L361">      moduleFileName = moduleFile.getCanonicalPath();</span>
<span class="fc" id="L362">      Logger.logDebug(&quot;importing  &quot; + moduleFileName);</span>
      // take the module from the already imported modules
<span class="fc" id="L364">      module_asm = alreadyImported.get(moduleFileName);</span>
      // check if already imported
<span class="fc bfc" id="L366" title="All 2 branches covered.">      if (module_asm == null)</span>
      {
<span class="fc" id="L368">        ASMParser nestedParser = new ASMParser(moduleFile, asmPk);</span>
<span class="fc" id="L369">        Logger.logDebug(&quot;---------------------------- Beginning of &quot; + moduleName + &quot; parsing----------------------------&quot;);</span>
<span class="fc" id="L370">        module_asm = nestedParser.Asm().get();</span>
<span class="fc" id="L371">        Logger.logDebug(&quot;---------------------------- End of &quot; + moduleName + &quot; parsing----------------------------\n&quot;);</span>
<span class="fc" id="L372">        alreadyImported.put(moduleFileName, module_asm);</span>
<span class="fc" id="L373">      }</span>
      else
      {
        // non faccio il parsing ma prendo comunque l'export del modulo e lo metto nell'import
<span class="fc" id="L377">        Logger.logDebug(&quot;--------- &quot; + moduleFileName + &quot;  already imported &quot;);</span>
      }
    }
<span class="fc" id="L380">    catch (Exception e)</span>
    {
<span class="fc" id="L382">      e.printStackTrace(System.err);</span>
<span class="fc" id="L383">      throw new ParseException(&quot;Error: File &quot; + filename + &quot; has errors when importing &quot; + moduleFileName + &quot;:&quot; + e.getMessage());</span>
<span class="fc" id="L384">    }</span>
<span class="fc" id="L385">    ExportClause module_expCl = module_asm.getHeaderSection().getExportClause();</span>
<span class="fc" id="L386">    Collection &lt; Function &gt; impFunctions = impClause.getImportedFunction();</span>
<span class="fc" id="L387">    Collection &lt; Domain &gt; impDomains = impClause.getImportedDomain();</span>
<span class="fc" id="L388">    Collection &lt; RuleDeclaration &gt; impRules = impClause.getImportedRule();</span>
<span class="fc" id="L389">    Collection &lt; Function &gt; module_func = null;</span>
<span class="fc" id="L390">    Collection &lt; Domain &gt; module_dom = null;</span>
<span class="fc" id="L391">    Collection &lt; RuleDeclaration &gt; module_rules = null;</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">    if (module_expCl != null)</span>
    {
<span class="fc" id="L394">      module_func = module_expCl.getExportedFunction();</span>
<span class="fc" id="L395">      module_dom = module_expCl.getExportedDomain();</span>
<span class="fc" id="L396">      module_rules = module_expCl.getExportedRule();</span>
    }
    else
    {
<span class="fc" id="L400">      Logger.logWarning(&quot;Warning: The ASM &quot; + moduleName + &quot; does not export any function or rule. It cannot be imported by this ASM.\n&quot;);</span>
    }
<span class="pc bpc" id="L402" title="1 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case 115:{
<span class="fc" id="L404">      jj_consume_token(115);</span>
<span class="fc" id="L405">Logger.logDebug(&quot;imported elements: &quot;);</span>
<span class="pc bpc" id="L406" title="4 of 6 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case ID_DOMAIN:{
<span class="nc" id="L408">        importedID = ID_DOMAIN();</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">if (module_expCl != null)</span>
        {
<span class="nc" id="L411">          d = Utility.search_domName(module_dom, importedID);</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">          if (d != null)</span>
          {
<span class="nc" id="L414">            impDomains.add(d);</span>
<span class="nc" id="L415">            Logger.logDebug(importedID);</span>
          }
          else
          {
<span class="nc" id="L419">            Logger.logWarning(&quot;Warning: The domain &quot; + importedID + &quot; is not exported by the ASM &quot; + moduleName + &quot;. It cannot be imported by this ASM.\n&quot;);</span>
          }
        }
        break;
        }
      case ID_FUNCTION:{
<span class="fc" id="L425">        importedID = ID_FUNCTION();</span>
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">if (module_expCl != null)</span>
        {
<span class="fc" id="L428">          f = Utility.search_funcName(module_func, importedID);</span>
<span class="pc bpc" id="L429" title="1 of 2 branches missed.">          if (f != null)</span>
          {
<span class="fc" id="L431">            impFunctions.add(f);</span>
<span class="fc" id="L432">            Logger.logDebug(importedID);</span>
            //if it is a Dynamic Function delete all function initializations
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">            if (f instanceof DynamicFunction) ((DynamicFunction) f).getInitialization().clear();</span>
          }
          else
          {
<span class="nc" id="L438">            Logger.logWarning(&quot;Warning: The function &quot; + importedID + &quot; is not exported by the ASM &quot; + moduleName + &quot;. It cannot be imported by this ASM.\n&quot;);</span>
          }
        }
        break;
        }
      case ID_RULE:{
<span class="nc" id="L444">        importedID = ID_RULE();</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">if (module_expCl != null)</span>
        {
<span class="nc" id="L447">          r = Utility.search_ruleName(module_rules, importedID);</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">          if (r != null)</span>
          {
<span class="nc" id="L450">            impRules.add(r);</span>
<span class="nc" id="L451">            Logger.logDebug(importedID);</span>
          }
          else
          {
<span class="nc" id="L455">            Logger.logWarning(&quot;Warning: The rule &quot; + importedID + &quot; is not exported by the ASM &quot; + moduleName + &quot;. It cannot be imported by this ASM.\n&quot;);</span>
          }
        }
        break;
        }
      default:
<span class="nc" id="L461">        jj_la1[9] = jj_gen;</span>
<span class="nc" id="L462">        jj_consume_token(-1);</span>
<span class="nc" id="L463">        throw new ParseException();</span>
      }
      label_4:
      while (true) {
<span class="pc bpc" id="L467" title="2 of 4 branches missed.">        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
        case 116:{
<span class="nc" id="L469">          break;</span>
          }
        default:
<span class="fc" id="L472">          jj_la1[10] = jj_gen;</span>
<span class="fc" id="L473">          break label_4;</span>
        }
<span class="nc" id="L475">        jj_consume_token(116);</span>
<span class="nc bnc" id="L476" title="All 6 branches missed.">        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
        case ID_DOMAIN:{
<span class="nc" id="L478">          importedID = ID_DOMAIN();</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">if (module_expCl != null)</span>
          {
<span class="nc" id="L481">            d = Utility.search_domName(module_dom, importedID);</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">            if (d != null)</span>
            {
<span class="nc" id="L484">              impDomains.add(d);</span>
<span class="nc" id="L485">              Logger.logDebug(&quot;,&quot; + importedID);</span>
            }
            else
            {
<span class="nc" id="L489">              Logger.logWarning(&quot;Warning: The domain &quot; + importedID + &quot; is not exported by the ASM &quot; + moduleName + &quot;. It cannot be imported by this ASM.\n&quot;);</span>
            }
          }
          break;
          }
        case ID_FUNCTION:{
<span class="nc" id="L495">          importedID = ID_FUNCTION();</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">if (module_expCl != null)</span>
          {
<span class="nc" id="L498">            f = Utility.search_funcName(module_func, importedID);</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">            if (f != null)</span>
            {
<span class="nc" id="L501">              impFunctions.add(f);</span>
<span class="nc" id="L502">              Logger.logDebug(&quot;,&quot; + importedID);</span>
              //if it is a Dynamic Function delete all function initializations
<span class="nc bnc" id="L504" title="All 2 branches missed.">              if (f instanceof DynamicFunction) ((DynamicFunction) f).getInitialization().clear();</span>
            }
            else
            {
<span class="nc" id="L508">              Logger.logWarning(&quot;Warning: The function &quot; + importedID + &quot; is not exported by the ASM &quot; + moduleName + &quot;. It cannot be imported by this ASM.\n&quot;);</span>
            }
          }
          break;
          }
        case ID_RULE:{
<span class="nc" id="L514">          importedID = ID_RULE();</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">if (module_expCl != null)</span>
          {
<span class="nc" id="L517">            r = Utility.search_ruleName(module_rules, importedID);</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">            if (r != null)</span>
            {
<span class="nc" id="L520">              impRules.add(r);</span>
<span class="nc" id="L521">              Logger.logDebug(&quot;,&quot; + importedID);</span>
            }
            else
            {
<span class="nc" id="L525">              Logger.logWarning(&quot;Warning: The rule &quot; + importedID + &quot; is not exported by the ASM &quot; + moduleName + &quot;. It cannot be imported by this ASM.\n&quot;);</span>
            }
          }
          break;
          }
        default:
<span class="nc" id="L531">          jj_la1[11] = jj_gen;</span>
<span class="nc" id="L532">          jj_consume_token(-1);</span>
<span class="nc" id="L533">          throw new ParseException();</span>
        }
      }
<span class="fc" id="L536">      jj_consume_token(117);</span>
<span class="fc" id="L537">Logger.logDebug(&quot;&quot;);</span>
<span class="fc" id="L538">      importAll = false;</span>
<span class="fc" id="L539">      break;</span>
      }
    default:
<span class="fc" id="L542">      jj_la1[12] = jj_gen;</span>
      ;
    }
<span class="fc bfc" id="L545" title="All 4 branches covered.">if (importAll &amp;&amp; module_expCl != null)</span>
    { //all domains of the export clause are imported
<span class="fc" id="L547">      impDomains.addAll(module_dom);</span>
      //all functions of the export clause are imported
<span class="fc bfc" id="L549" title="All 2 branches covered.">      for (Function fi : module_func)</span>
      {
        //add the function to the import clause
<span class="fc" id="L552">        impFunctions.add(fi);</span>
        //if it is a Dynamic Function delete all function initializations
<span class="fc bfc" id="L554" title="All 2 branches covered.">        if (fi instanceof DynamicFunction) ((DynamicFunction) fi).getInitialization().clear();</span>
<span class="fc" id="L555">      }</span>
      //all rules of the export clause are imported
<span class="fc" id="L557">      Iterator iter_rules = module_rules.iterator();</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">      while (iter_rules.hasNext())</span>
      {
<span class="fc" id="L560">        r = (RuleDeclaration) iter_rules.next();</span>
<span class="fc" id="L561">        Logger.logDebug(&quot;import rule &quot; + r.getName());</span>
        //add the rule to the import clause
<span class="fc" id="L563">        impRules.add(r);</span>
      }
<span class="fc" id="L565">      Logger.logDebug(&quot;imported elements: all&quot;);</span>
    }
<span class="fc" id="L567">    {if (&quot;&quot; != null) return impClause;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

/*-----------------------*/
  final public ExportClause ExportClause() throws ParseException {String exportedID;
<span class="fc" id="L573">    jj_consume_token(EXPORT);</span>
<span class="fc" id="L574">Logger.logDebug(&quot;export: &quot;);</span>
<span class="fc" id="L575">    ExportClause expClause = structurePack.createExportClause();</span>
<span class="pc bpc" id="L576" title="2 of 5 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case ID_DOMAIN:
    case ID_RULE:
    case ID_FUNCTION:{
//Some functions, domains and rules are exported, but not all. Their names are stored in the global variables &quot;exported_Func&quot;, &quot;exported_Dom&quot; and &quot;exported_Rules&quot;
<span class="fc" id="L581">        exportAll = false;</span>
<span class="fc" id="L582">        exported_Func = new HashMap();</span>
<span class="fc" id="L583">        exported_Dom = new HashMap();</span>
<span class="fc" id="L584">        exported_Rules = new HashMap();</span>
        String oldValue;
<span class="pc bpc" id="L586" title="2 of 6 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case ID_DOMAIN:{
<span class="fc" id="L588">        exportedID = ID_DOMAIN();</span>
<span class="fc" id="L589">oldValue = (String) exported_Dom.put(new Integer(exportedID.hashCode()), exportedID);</span>
<span class="pc bpc" id="L590" title="1 of 2 branches missed.">          if (oldValue == null) Logger.logDebug(exportedID);</span>
        break;
        }
      case ID_FUNCTION:{
<span class="fc" id="L594">        exportedID = ID_FUNCTION();</span>
<span class="fc" id="L595">oldValue = (String) exported_Func.put(new Integer(exportedID.hashCode()), exportedID);</span>
<span class="pc bpc" id="L596" title="1 of 2 branches missed.">          if (oldValue == null) Logger.logDebug(exportedID);</span>
        break;
        }
      case ID_RULE:{
<span class="fc" id="L600">        exportedID = ID_RULE();</span>
<span class="fc" id="L601">oldValue = (String) exported_Rules.put(new Integer(exportedID.hashCode()), exportedID);</span>
<span class="pc bpc" id="L602" title="1 of 2 branches missed.">          if (oldValue == null) Logger.logDebug(exportedID);</span>
        break;
        }
      default:
<span class="nc" id="L606">        jj_la1[13] = jj_gen;</span>
<span class="nc" id="L607">        jj_consume_token(-1);</span>
<span class="nc" id="L608">        throw new ParseException();</span>
      }
      label_5:
      while (true) {
<span class="pc bpc" id="L612" title="1 of 4 branches missed.">        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
        case 116:{
<span class="fc" id="L614">          break;</span>
          }
        default:
<span class="fc" id="L617">          jj_la1[14] = jj_gen;</span>
<span class="fc" id="L618">          break label_5;</span>
        }
<span class="fc" id="L620">        jj_consume_token(116);</span>
<span class="pc bpc" id="L621" title="2 of 6 branches missed.">        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
        case ID_DOMAIN:{
<span class="fc" id="L623">          exportedID = ID_DOMAIN();</span>
<span class="fc" id="L624">oldValue = (String) exported_Dom.put(new Integer(exportedID.hashCode()), exportedID);</span>
<span class="pc bpc" id="L625" title="1 of 2 branches missed.">            if (oldValue == null) Logger.logDebug(&quot;,&quot; + exportedID);</span>
          break;
          }
        case ID_FUNCTION:{
<span class="fc" id="L629">          exportedID = ID_FUNCTION();</span>
<span class="fc" id="L630">oldValue = (String) exported_Func.put(new Integer(exportedID.hashCode()), exportedID);</span>
<span class="pc bpc" id="L631" title="1 of 2 branches missed.">            if (oldValue == null) Logger.logDebug(&quot;,&quot; + exportedID);</span>
          break;
          }
        case ID_RULE:{
<span class="fc" id="L635">          exportedID = ID_RULE();</span>
<span class="fc" id="L636">oldValue = (String) exported_Rules.put(new Integer(exportedID.hashCode()), exportedID);</span>
<span class="pc bpc" id="L637" title="1 of 2 branches missed.">            if (oldValue == null) Logger.logDebug(&quot;,&quot; + exportedID);</span>
          break;
          }
        default:
<span class="nc" id="L641">          jj_la1[15] = jj_gen;</span>
<span class="nc" id="L642">          jj_consume_token(-1);</span>
<span class="nc" id="L643">          throw new ParseException();</span>
        }
      }
      break;
      }
    case MULT:{
<span class="fc" id="L649">      jj_consume_token(MULT);</span>
//All functions, domains and rules declared in this machine are exported
<span class="fc" id="L651">      exportAll = true;</span>
<span class="fc" id="L652">      Logger.logDebug(&quot;all&quot;);</span>
<span class="fc" id="L653">      break;</span>
      }
    default:
<span class="nc" id="L656">      jj_la1[16] = jj_gen;</span>
<span class="nc" id="L657">      jj_consume_token(-1);</span>
<span class="nc" id="L658">      throw new ParseException();</span>
    }
<span class="fc" id="L660">{if (&quot;&quot; != null) return expClause;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

/*-----------------------*/
  final public Signature Signature(Signature signature) throws ParseException {Domain d, c;
  Function f;
<span class="fc" id="L667">    jj_consume_token(SIGNATURE);</span>
<span class="fc" id="L668">    jj_consume_token(118);</span>
<span class="fc" id="L669">Logger.logDebug(&quot;signature:&quot;);</span>
    //create the object
    //Signature signature = structurePack.createSignature();
<span class="fc" id="L672">    Collection &lt; Domain &gt; domains = signature.getDomain();</span>
<span class="fc" id="L673">    Collection &lt; Function &gt; functions = signature.getFunction();</span>
<span class="fc" id="L674">    ExportClause expClause = header.getExportClause();</span>
<span class="fc" id="L675">    Collection &lt; Function &gt; expFunc = null;</span>
<span class="fc" id="L676">    Collection &lt; Domain &gt; expDom = null;</span>
<span class="fc bfc" id="L677" title="All 2 branches covered.">    if (expClause != null)</span>
    {
<span class="fc" id="L679">      expFunc = expClause.getExportedFunction();</span>
<span class="fc" id="L680">      expDom = expClause.getExportedDomain();</span>
    }
    String d_name, c_name;
    boolean inserted;
    // the declarations of imported functions and domains are added to
    // the visible name
<span class="fc bfc" id="L686" title="All 2 branches covered.">    for (ImportClause impClause : header.getImportClause())</span>
    {
      //insert the imported domains
<span class="fc bfc" id="L689" title="All 2 branches covered.">      for (Domain dom : impClause.getImportedDomain())</span>
      {
<span class="fc" id="L691">        d_name = dom.getName();</span>
<span class="fc bfc" id="L692" title="All 2 branches covered.">        if (!declared_Dom.containsKey(d_name))</span>
        {
          //add the domain to the signature
          //domains.add(dom);
<span class="pc bpc" id="L696" title="1 of 10 branches missed.">          if (!(dom instanceof StructuredTd || dom instanceof BasicTd || dom instanceof AgentDomain || dom instanceof ReserveDomain || dom instanceof AnyDomain))  //insert the domain in the table of declared domains</span>
<span class="fc" id="L697">          declared_Dom.put(d_name, dom);</span>
          //If the imported domain is an enumeration, its enum literals are
          // added to the hash table &quot;enumElem&quot;
<span class="fc bfc" id="L700" title="All 2 branches covered.">          if (dom instanceof EnumTd)</span>
          {
<span class="fc" id="L702">            Iterator iter_enum = ((EnumTd) dom).getElement().iterator();</span>
            EnumElement enumEl;
<span class="fc bfc" id="L704" title="All 2 branches covered.">            while (iter_enum.hasNext())</span>
            {
<span class="fc" id="L706">              enumEl = (EnumElement) iter_enum.next();</span>
<span class="fc" id="L707">              enumElem.put(enumEl.getSymbol(), (EnumTd) dom);</span>
            }
          }
          //check if the domain can be exported
          //Remark: the HashMap exported_Dom is initialized within the ExportClause method so if exported_Dom!=null =&gt; expClause!=null
<span class="pc bpc" id="L712" title="1 of 6 branches missed.">          if (((exported_Dom != null) &amp;&amp; exported_Dom.containsKey(new Integer(d_name.hashCode()))) || (exportAll == true))</span>
          { //add the domain to the exportClause
<span class="fc" id="L714">            expDom.add(dom);</span>
            //create the association
            //X AExpClDom.add(expClause,d);
          }
        }
<span class="fc" id="L719">      }</span>
      //insert the imported functions
<span class="fc bfc" id="L721" title="All 2 branches covered.">      for (Function fi : impClause.getImportedFunction())</span>
      {
<span class="fc" id="L723">        inserted = Utility.insert(fi, declared_Func);</span>
<span class="fc bfc" id="L724" title="All 2 branches covered.">        if (inserted)</span>
        { // DO NOT add the function to the signature
          //insert domain and codomain of the function in the declared Domains
<span class="fc" id="L727">          Utility.insert(fi.getDomain(), declared_Dom);</span>
<span class="fc" id="L728">          Utility.insert(fi.getCodomain(), declared_Dom);</span>
          //check if the function can be exported
          //Remark: the HashMap exported_Func is initialized within the ExportClause method so if exported_Func!=null =&gt; expClause!=null
<span class="fc bfc" id="L731" title="All 6 branches covered.">          if (((exported_Func != null) &amp;&amp; exported_Func.containsKey(new Integer(fi.getName().hashCode()))) || (exportAll == true))</span>
          { //add the function to the exportClause
<span class="fc" id="L733">            expFunc.add(fi);</span>
          }
        }
<span class="fc" id="L736">      }</span>
<span class="fc" id="L737">    }</span>
    //         Logger.logDebug(&quot;&quot;);

    label_6:
    while (true) {
<span class="fc bfc" id="L742" title="All 2 branches covered.">      if (jj_2_1(2)) {</span>
      } else {
        break label_6;
      }
<span class="fc" id="L746">      d = Domain();</span>
<span class="fc" id="L747">d_name = d.getName();</span>
      //check if the domain has already been declared
<span class="pc bpc" id="L749" title="1 of 2 branches missed.">      if (!declared_Dom.containsKey(d_name))</span>
      { //add the domain to the signature
<span class="fc" id="L751">        domains.add(d);</span>
<span class="pc bpc" id="L752" title="1 of 10 branches missed.">        if (!(d instanceof StructuredTd || d instanceof BasicTd || d instanceof AgentDomain || d instanceof ReserveDomain || d instanceof AnyDomain))  //insert the domain in the table of declared domains</span>
<span class="fc" id="L753">        declared_Dom.put(d_name, d);</span>
<span class="pc bpc" id="L754" title="1 of 2 branches missed.">        if (d instanceof StructuredTd) Logger.logDebug(d_name);</span>
      }
<span class="nc" id="L756">      else throw new ParseException(&quot;Error: The domain &quot; + d_name + &quot; has been declared twice.&quot;);</span>
      //check if the domain can be exported
      //Remark: the HashMap exported_Dom is initialized within the ExportClause method so if exported_Dom!=null =&gt; expClause!=null
<span class="fc bfc" id="L759" title="All 6 branches covered.">      if (((exported_Dom != null) &amp;&amp; exported_Dom.containsKey(new Integer(d_name.hashCode()))) || (exportAll == true))</span>
      { //add the domain to the exportClause
<span class="fc" id="L761">        expDom.add(d);</span>
        //create the association
        //X AExpClDom.add(expClause,d);
      }
    }
<span class="fc" id="L766">Logger.logDebug(&quot;&quot;);</span>
    label_7:
    while (true) {
<span class="fc bfc" id="L769" title="All 2 branches covered.">      if (jj_2_2(2)) {</span>
      } else {
        break label_7;
      }
<span class="fc" id="L773">      f = Function();</span>
<span class="fc" id="L774">inserted = Utility.insert(f, declared_Func);</span>
<span class="pc bpc" id="L775" title="1 of 2 branches missed.">      if (inserted)</span>
      { //add the function to the signature
<span class="fc" id="L777">        functions.add(f);</span>
        //X ASignFunc.add(signature,f);
      }
<span class="nc bnc" id="L780" title="All 2 branches missed.">      else throw new ParseException(&quot;Error: The function &quot; + f.getName() + &quot;:&quot; + ((f.getDomain() == null) ? &quot;&quot; : (f.getDomain().getName() + &quot;-&gt;&quot;)) + f.getCodomain().getName() + &quot; has been declared twice.&quot;);</span>
      //check if the function can be exported
      //Remark: the HashMap exported_Func is initialized within the ExportClause method so if exported_Func!=null =&gt; expClause!=null
<span class="fc bfc" id="L783" title="All 6 branches covered.">      if (((exported_Func != null) &amp;&amp; exported_Func.containsKey(new Integer(f.getName().hashCode()))) || (exportAll == true))</span>
      { //add the function to the exportClause
<span class="fc" id="L785">        expFunc.add(f);</span>
        //create the association
        //X AExpClFunc.add(expClause,f);
      }
      //check OCL constraint U7: function-&gt;forAll(f:Function | not f.oclIsTypeOf(LocalFunction))
<span class="pc bpc" id="L790" title="1 of 2 branches missed.">      if (OCL_Checker.isLocal(f)) throw new ParseException(&quot;Error: A local dynamic function cannot be declared in the signature.\n&quot; + &quot;       At the declaration of the function &quot; + f.getName() + &quot;.&quot;);</span>
    }
<span class="fc" id="L792">{if (&quot;&quot; != null) return signature;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

//-----------------------INITIALIZATION  -----------------------//
  final public Initialization Initialization() throws ParseException {String nameState;
  DomainInitialization d_init;
  FunctionInitialization f_init;
  AgentInitialization a_init;
<span class="fc" id="L801">    jj_consume_token(INIT);</span>
<span class="fc" id="L802">    nameState = ID();</span>
<span class="fc" id="L803">    jj_consume_token(118);</span>
<span class="fc" id="L804">Logger.logDebug(&quot;Init &quot; + nameState + &quot;:&quot;);</span>
<span class="fc" id="L805">    Initialization initState = structurePack.createInitialization();</span>
<span class="fc" id="L806">    initState.setName(nameState);</span>
    label_8:
    while (true) {
<span class="fc bfc" id="L809" title="All 2 branches covered.">      if (jj_2_3(2)) {</span>
      } else {
        break label_8;
      }
<span class="fc" id="L813">      d_init = DomainInitialization(initState);</span>
<span class="fc" id="L814">initState.getDomainInitialization().add(d_init);</span>
    }
    label_9:
    while (true) {
<span class="fc bfc" id="L818" title="All 4 branches covered.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case FUNCTION:{
<span class="fc" id="L820">        break;</span>
        }
      default:
<span class="fc" id="L823">        jj_la1[17] = jj_gen;</span>
<span class="fc" id="L824">        break label_9;</span>
      }
<span class="fc" id="L826">      f_init = FunctionInitialization(initState);</span>
<span class="fc" id="L827">initState.getFunctionInitialization().add(f_init);</span>
    }
    label_10:
    while (true) {
<span class="fc bfc" id="L831" title="All 4 branches covered.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case AGENT:{
<span class="fc" id="L833">        break;</span>
        }
      default:
<span class="fc" id="L836">        jj_la1[18] = jj_gen;</span>
<span class="fc" id="L837">        break label_10;</span>
      }
<span class="fc" id="L839">      a_init = AgentInitialization(initState);</span>
<span class="fc" id="L840">initState.getAgentInitialization().add(a_init);</span>
    }
//check OCL constraints
<span class="pc bpc" id="L843" title="1 of 2 branches missed.">    if (!OCL_Checker.checkInitialization(initState))</span>
    {
<span class="nc" id="L845">      Logger.logErr(OCL_Checker.getMsgErr() + &quot;\n       At the initial state &quot; + nameState + &quot;.\n&quot;);</span>
    }
<span class="fc" id="L847">    {if (&quot;&quot; != null) return initState;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public DomainInitialization DomainInitialization(Initialization initState) throws ParseException {String name;
  Term body;
<span class="fc" id="L853">  HashMap localVar = new HashMap();</span>
<span class="fc" id="L854">    jj_consume_token(DOMAIN);</span>
<span class="fc" id="L855">    name = ID_DOMAIN();</span>
<span class="fc" id="L856">    jj_consume_token(EQ);</span>
<span class="fc" id="L857">Logger.logDebug(&quot;\ndomain &quot; + name + &quot;\nbody:&quot;);</span>
<span class="fc" id="L858">    body = Term(localVar, false, null);</span>
<span class="fc" id="L859">Domain dom = (Domain) declared_Dom.get(name);</span>
    //check if the domain has been declared
<span class="pc bpc" id="L861" title="1 of 2 branches missed.">    if (dom == null) throw new ParseException(&quot;Error: The domain &quot; + name + &quot; has not been declared. It cannot be initialized.\n&quot;);</span>
    //check if the domain is a concrete-domain
<span class="pc bpc" id="L863" title="1 of 2 branches missed.">    if (!(dom instanceof ConcreteDomain)) throw new ParseException(&quot;Error: The domain &quot; + name + &quot; is not a concrete-domain. It cannot be initialized.\n&quot;);</span>
    //create the object
<span class="fc" id="L865">    DomainInitialization dom_init = structurePack.createDomainInitialization();</span>
<span class="fc" id="L866">    dom_init.setInitialState(initState);</span>
    //set the reference to the initialized domain
<span class="fc" id="L868">    dom_init.setInitializedDomain(((ConcreteDomain) dom));</span>
<span class="fc" id="L869">    ((ConcreteDomain) dom).getInitialization().add(dom_init);</span>
    //set the reference to the body
<span class="fc" id="L871">    dom_init.setBody(body);</span>
    //check ocl constraints
<span class="pc bpc" id="L873" title="1 of 2 branches missed.">    if (!OCL_Checker.checkDomainInitialization(dom_init)) throw new ParseException(OCL_Checker.getMsgErr() + &quot;\n       At the initialization of the domain &quot; + dom.getName() + &quot;.\n&quot;);</span>
<span class="fc" id="L874">    {if (&quot;&quot; != null) return dom_init;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public FunctionInitialization FunctionInitialization(Initialization initState) throws ParseException {Term body;
  String func_name;
  VariableTerm v;
  Domain inDom;
<span class="fc" id="L882">  HashMap localVar = new HashMap();</span>
<span class="fc" id="L883">    jj_consume_token(FUNCTION);</span>
<span class="fc" id="L884">    func_name = ID_FUNCTION();</span>
<span class="fc" id="L885">Logger.logDebug(&quot;initialization of function &quot; + func_name);</span>
    //create the object
<span class="fc" id="L887">    FunctionInitialization func_init = structurePack.createFunctionInitialization();</span>
    //set the reference in the function initialization
<span class="fc" id="L889">    func_init.setInitialState(initState);</span>
<span class="fc" id="L890">    Collection func_initVariables = func_init.getVariable();</span>
    //the name of the function domain
<span class="fc" id="L892">    String dom_name = &quot;&quot;;</span>
<span class="pc bpc" id="L893" title="1 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case 115:{
<span class="fc" id="L895">Logger.logDebug(&quot;variables: &quot;);</span>
<span class="fc" id="L896">      jj_consume_token(115);</span>
<span class="fc" id="L897">      v = VariableTerm(localVar, true);</span>
<span class="fc" id="L898">      jj_consume_token(IN);</span>
<span class="fc" id="L899">      inDom = getDomainByID();</span>
//set the reference
<span class="fc" id="L901">      func_initVariables.add(v);</span>
      //update variable features
<span class="fc" id="L903">      Utility.updateVariable(v, inDom);</span>
      //if the variables are more then one the associated domains must be type-domains
      //this constraint seems silly, so it is commented
      /*
         if( getToken(1).image.equals(&quot;,&quot;) &amp;&amp; (inDom instanceof ConcreteDomain))
               throw new ParseException(&quot;Error: When the function arity is greater than 1, the domains associated to the function variables must be type-domains.&quot;+
                                         &quot;       At the initialization of the function &quot;+ func_name +&quot;.\n&quot;);
		 */
      //update the name of the function domain
<span class="fc" id="L912">      dom_name = inDom.getName();</span>
<span class="fc" id="L913">      Logger.logDebug(&quot;\t\t\t&quot; + v.getName() + &quot; updated: D=&quot; + v.getDomain().getName() + &quot;, kind=&quot; + v.getKind().toString());</span>
      label_11:
      while (true) {
<span class="pc bpc" id="L916" title="1 of 4 branches missed.">        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
        case 116:{
<span class="fc" id="L918">          break;</span>
          }
        default:
<span class="fc" id="L921">          jj_la1[19] = jj_gen;</span>
<span class="fc" id="L922">          break label_11;</span>
        }
<span class="fc" id="L924">        jj_consume_token(116);</span>
//check if the next variable is already used (look for it in the localVar HashMap)
<span class="fc" id="L926">        String nextVar = getToken(1).image;</span>
<span class="pc bpc" id="L927" title="1 of 2 branches missed.">        if (localVar.get(nextVar) != null) throw new ParseException(&quot;Error: The variable &quot; + nextVar + &quot; cannot be used as parameter of the initialization of function &quot; + func_name + &quot;. It is already used.&quot;);</span>
<span class="fc" id="L928">        v = VariableTerm(localVar, true);</span>
<span class="fc" id="L929">        jj_consume_token(IN);</span>
<span class="fc" id="L930">        inDom = getDomainByID();</span>
//set the reference
<span class="fc" id="L932">        func_initVariables.add(v);</span>
        //set the association
        //Xa_FuncInit_Var.add(v,func_init);
        //update variable features
<span class="fc" id="L936">        Utility.updateVariable(v, inDom);</span>
        //if the variables are more then one the associated domains must be type-domains
        //this constraint seems silly, so it is commented
        /*
         if( inDom instanceof ConcreteDomain)
               throw new ParseException(&quot;Error: When the function arity is greter than 1, the domains related to the variables of a function initialization or definition  must be type-domains.&quot;+
                                         &quot;       At the initialization of the function &quot;+ func_name +&quot;.\n&quot;);
		 */
        //update the name of the function domain
<span class="fc" id="L945">        dom_name = dom_name.concat(&quot;,&quot;).concat(inDom.getName());</span>
<span class="fc" id="L946">        Logger.logDebug(&quot;\t\t\t&quot; + v.getName() + &quot; updated: D=&quot; + v.getDomain().getName() + &quot;, kind=&quot; + v.getKind().toString());</span>
<span class="fc" id="L947">      }</span>
<span class="fc" id="L948">      jj_consume_token(117);</span>
<span class="fc" id="L949">      break;</span>
      }
    default:
<span class="fc" id="L952">      jj_la1[20] = jj_gen;</span>
      ;
    }
<span class="fc" id="L955">    jj_consume_token(EQ);</span>
<span class="fc" id="L956">Logger.logDebug(&quot;body:&quot;);</span>
<span class="fc" id="L957">    body = Term(localVar, false, null);</span>
//set the reference
<span class="fc" id="L959">    func_init.setBody(body);</span>
    Domain func_dom;
<span class="fc bfc" id="L961" title="All 2 branches covered.">    if (func_initVariables.size() == 0) func_dom = null;</span>
<span class="fc bfc" id="L962" title="All 2 branches covered.">    else if (func_initVariables.size() == 1)</span>
    {
<span class="fc" id="L964">      func_dom = (Domain) declared_Dom.get(dom_name);</span>
<span class="fc bfc" id="L965" title="All 2 branches covered.">      if (func_dom == null) func_dom = Utility.getBasicDomain(domainsFactory, dom_name);</span>
<span class="fc bfc" id="L966" title="All 2 branches covered.">      if (func_dom == null) func_dom = Utility.getPredefinedAbstractDomain(domainsFactory, dom_name);</span>
<span class="pc bpc" id="L967" title="1 of 2 branches missed.">      if (func_dom == null) func_dom = Utility.getStructuredDomain(domainsFactory, dom_name, header.getSignature());</span>
<span class="pc bpc" id="L968" title="1 of 2 branches missed.">      if (func_dom == null) throw new ParseException(&quot;Error: The domain&quot; + dom_name + &quot; has not been declared. There not exists a function with this domain.&quot;);</span>
    }
    else
    {
<span class="fc" id="L972">      dom_name = &quot;Prod(&quot;.concat(dom_name).concat(&quot;)&quot;);</span>
<span class="fc" id="L973">      func_dom = (Domain) Utility.getStructuredDomain(domainsFactory, dom_name, header.getSignature());</span>
<span class="pc bpc" id="L974" title="1 of 2 branches missed.">      if (func_dom == null) throw new ParseException(&quot;Error: The domain&quot; + dom_name + &quot; has not been declared. There not exists a function with this domain.&quot;);</span>
    }
    //check if the function has been declared
    /// attenzione non trova le funzioni importate !!!!
<span class="fc" id="L978">    Function f = Utility.getFunction(func_name, func_dom, false, new HashMap(), declared_Func);</span>
<span class="pc bpc" id="L979" title="1 of 2 branches missed.">    if (f == null) throw new ParseException(&quot;Error: The function &quot; + func_name + &quot;(&quot; + dom_name + &quot;)&quot; + &quot; has not been declared. It cannot be initialized&quot;);</span>
<span class="pc bpc" id="L980" title="1 of 2 branches missed.">    if (!(f instanceof DynamicFunction)) throw new ParseException(&quot;Error: The function &quot; + func_name + &quot;(&quot; + dom_name + &quot;)&quot; + &quot; is not a dynamic function. It cannot be initialized&quot;);</span>
    //set the reference to the function to initialize
<span class="fc" id="L982">    func_init.setInitializedFunction((DynamicFunction) f);</span>
<span class="fc" id="L983">    ((DynamicFunction) f).getInitialization().add(func_init);</span>
    //create the association
    //XX AInitializationInitializedFunction a_FuncInit_Func = structurePack.getAInitializationInitializedFunction();
    //XX a_FuncInit_Func.add(func_init,((DynamicFunction)f));
    // ocl constraint 1 and 2 are granted for construction
    // check ocl constraint 3
    //if(!OCL_Checker.body_ok(f,body))
    //      throw new ParseException(OCL_Checker.getMsgErr()+&quot;\n       At the initialization of the function &quot;+ func_name +&quot;(&quot;+dom_name+&quot;)&quot;+&quot;.&quot;);
    //
<span class="pc bpc" id="L992" title="1 of 2 branches missed.">    if (!OCL_Checker.checkFunctionInitialization(func_init)) throw new ParseException(OCL_Checker.getMsgErr() + &quot;\n       At the initialization of the function &quot; + func_name + &quot;(&quot; + dom_name + &quot;)&quot; + &quot;.&quot;);</span>
<span class="fc" id="L993">    {if (&quot;&quot; != null) return func_init;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public AgentInitialization AgentInitialization(Initialization initState) throws ParseException {Domain dom;
  String id_dom;
  MacroCallRule r;
<span class="fc" id="L1000">  HashMap localVar = new HashMap();</span>
<span class="fc" id="L1001">    jj_consume_token(AGENT);</span>
<span class="fc" id="L1002">Logger.logDebug(&quot;\tAgent initialization begins&quot;);</span>
<span class="fc" id="L1003">    id_dom = ID_DOMAIN();</span>
<span class="fc" id="L1004">    jj_consume_token(118);</span>
<span class="fc" id="L1005">Logger.logDebug(&quot;\tagent domain: &quot; + id_dom);</span>
<span class="fc" id="L1006">    dom = (Domain) declared_Dom.get(id_dom);</span>
<span class="fc bfc" id="L1007" title="All 2 branches covered.">    if (dom == null) dom = Utility.getPredefinedAbstractDomain(domainsFactory, id_dom);</span>
<span class="pc bpc" id="L1008" title="1 of 2 branches missed.">    if (dom == null) throw new ParseException(&quot;Error: The domain &quot; + id_dom + &quot; has not been declared. Invariant declaration failed &quot;);</span>
<span class="fc" id="L1009">    AgentInitialization agent_init = structurePack.createAgentInitialization();</span>
<span class="fc" id="L1010">    agent_init.setInitialState(initState);</span>
<span class="fc" id="L1011">    agent_init.setDomain(dom);</span>
<span class="fc" id="L1012">    r = MacroCallRule(localVar, null);</span>
//set the reference
<span class="fc" id="L1014">    agent_init.setProgram(r);</span>
    //check OCL constraints
<span class="pc bpc" id="L1016" title="1 of 2 branches missed.">    if (!OCL_Checker.checkAgentInitialization(agent_init)) throw new ParseException(OCL_Checker.getMsgErr() + &quot;\n       At the initialization of the agent set &quot; + id_dom + &quot;.&quot;);</span>
<span class="fc" id="L1017">Logger.logDebug(&quot;\tagent initialization ends&quot;);</span>
<span class="fc" id="L1018">    {if (&quot;&quot; != null) return agent_init;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

//----------------------------BODY----------------------------//
  final public Body Body(Asm m) throws ParseException {DomainDefinition d_def;
  FunctionDefinition f_def;
  RuleDeclaration r_decl;
  Property p;
  FairnessConstraint fc;
  InvarConstraint ic;
  /*Invariant a;
   //PA 30/12/2010 in order to add the CTLSPEC and LTLSPEC keywords: START 
   CtlSpec ctlSpec;
   LtlSpec ltlSpec;
   //PA 30/12/2010 in order to add the CTLSPEC and LTLSPEC keywords: END
   */

<span class="fc" id="L1036">    jj_consume_token(DEFINITIONS);</span>
<span class="fc" id="L1037">    jj_consume_token(118);</span>
<span class="fc" id="L1038">Logger.logDebug(&quot;definitions:&quot;);</span>
<span class="fc" id="L1039">    Body body = structurePack.createBody();</span>
<span class="fc" id="L1040">    Collection &lt; DomainDefinition &gt; dom_definitions = body.getDomainDefinition();</span>
<span class="fc" id="L1041">    Collection &lt; FunctionDefinition &gt; func_definitions = body.getFunctionDefinition();</span>
<span class="fc" id="L1042">    Collection &lt; RuleDeclaration &gt; rule_declarations = body.getRuleDeclaration();</span>
    //Collection invariants = body.getInvariant();
    //Collection ctlSpecs = body.getCtlSpec();
    //Collection ltlSpecs = body.getLtlSpec();
<span class="fc" id="L1046">    Collection &lt; Property &gt; properties = body.getProperty();</span>
<span class="fc" id="L1047">    Collection &lt; FairnessConstraint &gt; fairnessConstraints = body.getFairnessConstraint();</span>
<span class="fc" id="L1048">    Collection &lt; InvarConstraint &gt; invarConstraints = body.getInvariantConstraint();</span>
<span class="fc" id="L1049">    ExportClause expClause = header.getExportClause();</span>
<span class="fc" id="L1050">    Collection &lt; RuleDeclaration &gt; expRules = null;</span>
<span class="fc bfc" id="L1051" title="All 2 branches covered.">    if (expClause != null)</span>
<span class="fc" id="L1052">    expRules = expClause.getExportedRule();</span>
    label_12:
    while (true) {
<span class="fc bfc" id="L1055" title="All 2 branches covered.">      if (jj_2_4(2)) {</span>
      } else {
        break label_12;
      }
<span class="fc" id="L1059">      d_def = DomainDefinition();</span>
<span class="fc" id="L1060">dom_definitions.add(d_def);</span>
      //set the association
      //XX a_Body_DomDef.add(body,d_def);

    }
    label_13:
    while (true) {
<span class="fc bfc" id="L1067" title="All 4 branches covered.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case FUNCTION:{
<span class="fc" id="L1069">        break;</span>
        }
      default:
<span class="fc" id="L1072">        jj_la1[21] = jj_gen;</span>
<span class="fc" id="L1073">        break label_13;</span>
      }
<span class="fc" id="L1075">      f_def = FunctionDefinition(m);</span>
<span class="fc" id="L1076">func_definitions.add(f_def);</span>
      //set the association
      //XX a_Body_FuncDef.add(f_def,body);

    }
//the rule declarations imported are added to declared rules
<span class="fc bfc" id="L1082" title="All 2 branches covered.">    for (ImportClause impClause : header.getImportClause())</span>
    {
<span class="fc bfc" id="L1084" title="All 2 branches covered.">      for (RuleDeclaration r_d : impClause.getImportedRule())</span>
      {
<span class="fc" id="L1086">        String rule_name = rule_name = r_d.getName();</span>
        //check if the rule has already been declared
<span class="fc" id="L1088">        List &lt; RuleDeclaration &gt; r_list = declared_Rules.get(rule_name);</span>
<span class="fc bfc" id="L1089" title="All 2 branches covered.">        if (r_list == null)</span>
        {
<span class="fc" id="L1091">          List &lt; RuleDeclaration &gt; newList = new ArrayList &lt; RuleDeclaration &gt; (Collections.singletonList(r_d));</span>
<span class="fc" id="L1092">          declared_Rules.put(rule_name, newList);</span>
<span class="fc" id="L1093">        }</span>
        else
        {
          // add this rule in any case
<span class="fc" id="L1097">          r_list.add(r_d);</span>
        }
        //check if the rule can be exported
        //Remark: the HashMap exported_Rules is initialized within the ExportClause method so if exported_Rules!=null =&gt; expClause!=null
<span class="pc bpc" id="L1101" title="1 of 6 branches missed.">        if (((exported_Rules != null) &amp;&amp; exported_Rules.containsKey(new Integer(rule_name.hashCode()))) || exportAll)</span>
        {
<span class="fc" id="L1103">          expRules.add(r_d);</span>
        }
        //check if the rule is the program associated to an agent in an AgentInitialization
        /*for (AgentInitialization a_init: programs.get(rule_name)){
                     //set the reference
                     // TODO
                     // MODIFICARE !!!! setNamedProgram --&gt; a_init.setProgram((MacroDeclaration)r_decl);
                     //create the association
                     //X AAgentNamedProg.add(a_init,r_decl);
               }*/
<span class="fc" id="L1113">      }</span>
<span class="fc" id="L1114">    }</span>
    label_14:
    while (true) {
<span class="fc bfc" id="L1117" title="All 4 branches covered.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case RULE:
      case MACRO:
      case TURBO:{
<span class="fc" id="L1121">        break;</span>
        }
      default:
<span class="fc" id="L1124">        jj_la1[22] = jj_gen;</span>
<span class="fc" id="L1125">        break label_14;</span>
      }
      /*LOOKAHEAD(2)*/
<span class="fc" id="L1128">          r_decl = RuleDeclaration();</span>
<span class="fc" id="L1129">String rule_name = r_decl.getName();</span>
      //check if the rule has already been declared
<span class="pc bpc" id="L1131" title="1 of 2 branches missed.">      if (Utility.searchRuleByName(declared_Rules, rule_name, r_decl.getVariable()) == null)</span>
      {
<span class="fc" id="L1133">        rule_declarations.add(r_decl);</span>
        //create the association
        //XX a_Body_Rule.add(body,r_decl);
        //insert the rule in the table of declared rules
        // create a new list of rules
<span class="fc bfc" id="L1138" title="All 2 branches covered.">        if (!declared_Rules.containsKey(rule_name))</span>
        {
<span class="fc" id="L1140">          List &lt; RuleDeclaration &gt; newList = new ArrayList &lt; RuleDeclaration &gt; (Collections.singletonList(r_decl));</span>
<span class="fc" id="L1141">          declared_Rules.put(rule_name, newList);</span>
<span class="fc" id="L1142">        }</span>
        else
        {
<span class="fc" id="L1145">          declared_Rules.get(rule_name).add(r_decl);</span>
        }
      }
      else
      {
<span class="nc" id="L1150">        Logger.logDebug(&quot;\trule alredy declared&quot;);</span>
<span class="nc" id="L1151">        throw new ParseException(&quot;Error: The rule &quot; + rule_name + &quot; has been declared twice with the same parameters.&quot;);</span>
      }
      //check if the rule can be exported
      //Remark: the HashMap exported_Rules is initialized within the ExportClause method so if exported_Rules!=null =&gt; expClause!=null
<span class="fc bfc" id="L1155" title="All 6 branches covered.">      if (((exported_Rules != null) &amp;&amp; exported_Rules.containsKey(new Integer(rule_name.hashCode()))) || exportAll)</span>
      {
<span class="fc" id="L1157">        expRules.add(r_decl);</span>
        //create the association
        //XX AExpClRule.add(expClause,r_decl);
      }
      //check if the rule is the program associated to an agent in an AgentInitialization
      /* r_list = (LinkedList)programs.get(rule_name);
            if(r_list!=null)
            {  iter_r_list = r_list.listIterator(r_list.size());
               while(iter_r_list.hasNext())
               {  a_init = (AgentInitialization)iter_r_list.next();
                  //set the reference
                  // MODIFICARE AG TODO a_init.setNamedProgram((MacroDeclaration)r_decl);
               }
            }*/

<span class="fc" id="L1172">    }</span>
    label_15:
    while (true) {
<span class="pc bpc" id="L1175" title="2 of 4 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case INVAR:{
<span class="nc" id="L1177">        break;</span>
        }
      default:
<span class="fc" id="L1180">        jj_la1[23] = jj_gen;</span>
<span class="fc" id="L1181">        break label_15;</span>
      }
<span class="nc" id="L1183">      ic = InvarConstraint(m);</span>
<span class="nc" id="L1184">invarConstraints.add(ic);</span>
    }
    label_16:
    while (true) {
<span class="pc bpc" id="L1188" title="1 of 4 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case JUSTICE:
      case COMPASSION:{
<span class="fc" id="L1191">        break;</span>
        }
      default:
<span class="fc" id="L1194">        jj_la1[24] = jj_gen;</span>
<span class="fc" id="L1195">        break label_16;</span>
      }
<span class="fc" id="L1197">      fc = FairnessConstraint(m);</span>
<span class="fc" id="L1198">fairnessConstraints.add(fc);</span>
    }
    label_17:
    while (true) {
<span class="fc bfc" id="L1202" title="All 4 branches covered.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case INVARIANT:
      case CTLSPEC:
      case LTLSPEC:{
<span class="fc" id="L1206">        break;</span>
        }
      default:
<span class="fc" id="L1209">        jj_la1[25] = jj_gen;</span>
<span class="fc" id="L1210">        break label_17;</span>
      }
<span class="fc" id="L1212">      p = Property(m);</span>
<span class="fc" id="L1213">String name = p.getName();</span>
<span class="fc bfc" id="L1214" title="All 2 branches covered.">      if (name != null)</span>
      {
<span class="fc bfc" id="L1216" title="All 2 branches covered.">        if (p instanceof CtlSpec)</span>
        {
<span class="fc bfc" id="L1218" title="All 2 branches covered.">          for (Property p2 : properties)</span>
          {
<span class="pc bpc" id="L1220" title="2 of 6 branches missed.">            if (p2 instanceof CtlSpec &amp;&amp; p2.getName() != null &amp;&amp; p2.getName().equals(name))</span>
            {
<span class="nc" id="L1222">              throw new ParseException(&quot;Two CTL specifications can not have the same name.&quot;);</span>
            }
<span class="fc" id="L1224">          }</span>
        }
<span class="fc bfc" id="L1226" title="All 2 branches covered.">        if (p instanceof LtlSpec)</span>
        {
<span class="fc bfc" id="L1228" title="All 2 branches covered.">          for (Property p2 : properties)</span>
          {
<span class="pc bpc" id="L1230" title="2 of 6 branches missed.">            if (p2 instanceof LtlSpec &amp;&amp; p2.getName() != null &amp;&amp; p2.getName().equals(name))</span>
            {
<span class="nc" id="L1232">              throw new ParseException(&quot;Two LTL specifications can not have the same name.&quot;);</span>
            }
<span class="fc" id="L1234">          }</span>
        }
      }
<span class="fc" id="L1237">      properties.add(p);</span>
<span class="fc" id="L1238">    }</span>
<span class="fc" id="L1239">{if (&quot;&quot; != null) return body;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public DomainDefinition DomainDefinition() throws ParseException {String name;
  Term body;
<span class="fc" id="L1245">  HashMap localVar = new HashMap();</span>
<span class="fc" id="L1246">    jj_consume_token(DOMAIN);</span>
<span class="fc" id="L1247">    name = ID_DOMAIN();</span>
<span class="fc" id="L1248">    jj_consume_token(EQ);</span>
<span class="fc" id="L1249">Logger.logDebug(&quot;domain &quot; + name);</span>
<span class="fc" id="L1250">    Logger.logDebug(&quot;body:&quot;);</span>
<span class="fc" id="L1251">    body = Term(localVar, false, null);</span>
<span class="fc" id="L1252">Domain dom = declared_Dom.get(name);</span>
    //check if the domain has been declared
<span class="pc bpc" id="L1254" title="1 of 2 branches missed.">    if (dom == null) throw new ParseException(&quot;Error: The domain &quot; + name + &quot; has not been declared. It cannot be defined.\n&quot;);</span>
    //check if the domain is a concrete-domain
<span class="pc bpc" id="L1256" title="1 of 2 branches missed.">    if (!(dom instanceof ConcreteDomain)) throw new ParseException(&quot;Error: The domain &quot; + name + &quot; is not a concrete-domain. It cannot be defined.\n&quot;);</span>
    //check if the domain has already been defined
<span class="pc bpc" id="L1258" title="1 of 2 branches missed.">    if (((ConcreteDomain) dom).getDefinition() != null) throw new ParseException(&quot;Error: The domain &quot; + name + &quot; has been defined twice.&quot;);</span>
    //create the object
<span class="fc" id="L1260">    DomainDefinition dom_def = structurePack.createDomainDefinition();</span>
    //set the reference to the defined domain
<span class="fc" id="L1262">    dom_def.setDefinedDomain(((ConcreteDomain) dom));</span>
<span class="fc" id="L1263">    ((ConcreteDomain) dom).setDefinition(dom_def);</span>
    //create the association
    //X ADefinitionDefinedDomain ADefDom = structurePack.getADefinitionDefinedDomain();
    //X ADefDom.add(dom_def,((ConcreteDomain)dom));
    //set the reference to the body
<span class="fc" id="L1268">    dom_def.setBody(body);</span>
    //create the association
    //X ADomainDefinitionBody ADefbody = structurePack.getADomainDefinitionBody();
    //X ADefbody.add(dom_def,body);
    //check ocl constraints
<span class="pc bpc" id="L1273" title="3 of 4 branches missed.">    if (!OCL_Checker.checkDomainDefinition(dom_def)) throw new ParseException(OCL_Checker.getMsgErr() + &quot;\n       At the definition of the &quot; + (((ConcreteDomain) dom).getIsDynamic() ? &quot;dynamic&quot; : &quot;static&quot;) + &quot; domain &quot; + dom.getName() + &quot;.\n&quot;);</span>
<span class="fc" id="L1274">    {if (&quot;&quot; != null) return dom_def;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public FunctionDefinition FunctionDefinition(Asm m) throws ParseException {Term body;
  String func_name;
  VariableTerm v;
  Domain inDom;
<span class="fc" id="L1282">  HashMap &lt; String, VariableTerm &gt; localVar = new HashMap &lt; String, VariableTerm &gt; ();</span>
<span class="fc" id="L1283">    jj_consume_token(FUNCTION);</span>
<span class="fc" id="L1284">    func_name = ID_FUNCTION();</span>
<span class="fc" id="L1285">Logger.logDebug(&quot;function &quot; + func_name);</span>
    //create the object
<span class="fc" id="L1287">    FunctionDefinition func_def = structurePack.createFunctionDefinition();</span>
<span class="fc" id="L1288">    List &lt; VariableTerm &gt; variables = func_def.getVariable();</span>
    //the name of the function domain
<span class="fc" id="L1290">    String dom_name = &quot;&quot;;</span>
<span class="pc bpc" id="L1291" title="1 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case 115:{
<span class="fc" id="L1293">Logger.logDebug(&quot;variables: &quot;);</span>
<span class="fc" id="L1294">      jj_consume_token(115);</span>
<span class="fc" id="L1295">      v = VariableTerm(localVar, true);</span>
<span class="fc" id="L1296">      jj_consume_token(IN);</span>
<span class="fc" id="L1297">      inDom = getDomainByID();</span>
//set the reference
<span class="fc" id="L1299">      variables.add(v);</span>
      //update variable features
<span class="fc" id="L1301">      Utility.updateVariable(v, inDom);</span>
      //update the name of the function domain
<span class="fc" id="L1303">      dom_name = inDom.getName();</span>
<span class="fc" id="L1304">      Logger.logDebug(&quot;\t\t\t&quot; + v.getName() + &quot; updated: TD=&quot; + v.getDomain().getName() + &quot;, kind=&quot; + v.getKind().toString());</span>
      label_18:
      while (true) {
<span class="pc bpc" id="L1307" title="1 of 4 branches missed.">        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
        case 116:{
<span class="fc" id="L1309">          break;</span>
          }
        default:
<span class="fc" id="L1312">          jj_la1[26] = jj_gen;</span>
<span class="fc" id="L1313">          break label_18;</span>
        }
<span class="fc" id="L1315">        jj_consume_token(116);</span>
//check if the next variable is already used (look for it in the localVar HashMap)
<span class="fc" id="L1317">        String nextVar = getToken(1).image;</span>
<span class="pc bpc" id="L1318" title="1 of 2 branches missed.">        if (localVar.get(nextVar) != null) throw new ParseException(&quot;Error: The variable &quot; + nextVar + &quot; cannot be used as parameter of the definition of function &quot; + func_name + &quot;. It is already used.&quot;);</span>
<span class="fc" id="L1319">        v = VariableTerm(localVar, true);</span>
<span class="fc" id="L1320">        jj_consume_token(IN);</span>
<span class="fc" id="L1321">        inDom = getDomainByID();</span>
//set the reference
<span class="fc" id="L1323">        variables.add(v);</span>
        //update variable features
<span class="fc" id="L1325">        Utility.updateVariable(v, inDom);</span>
        //update the name of the function domain
<span class="fc" id="L1327">        dom_name = dom_name.concat(&quot;,&quot;).concat(inDom.getName());</span>
<span class="fc" id="L1328">        Logger.logDebug(&quot;\t\t\t&quot; + v.getName() + &quot; updated: TD=&quot; + v.getDomain().getName() + &quot;, kind=&quot; + v.getKind().toString());</span>
<span class="fc" id="L1329">      }</span>
<span class="fc" id="L1330">      jj_consume_token(117);</span>
<span class="fc" id="L1331">      break;</span>
      }
    default:
<span class="fc" id="L1334">      jj_la1[27] = jj_gen;</span>
      ;
    }
<span class="fc" id="L1337">    jj_consume_token(EQ);</span>
<span class="fc" id="L1338">Logger.logDebug(&quot;body:&quot;);</span>
<span class="fc" id="L1339">    body = Term(localVar, false, null);</span>
//set the reference
<span class="fc" id="L1341">    func_def.setBody(body);</span>
    Domain func_dom;
<span class="fc bfc" id="L1343" title="All 2 branches covered.">    if (variables.size() == 0) func_dom = null;</span>
<span class="fc bfc" id="L1344" title="All 2 branches covered.">    else if (variables.size() == 1)</span>
    {
<span class="fc" id="L1346">      func_dom = (Domain) declared_Dom.get(dom_name);</span>
<span class="fc bfc" id="L1347" title="All 2 branches covered.">      if (func_dom == null) func_dom = Utility.getBasicDomain(domainsFactory, dom_name);</span>
<span class="fc bfc" id="L1348" title="All 2 branches covered.">      if (func_dom == null) func_dom = Utility.getPredefinedAbstractDomain(domainsFactory, dom_name);</span>
<span class="fc bfc" id="L1349" title="All 2 branches covered.">      if (func_dom == null) func_dom = Utility.getStructuredDomain(domainsFactory, dom_name, header.getSignature());</span>
<span class="pc bpc" id="L1350" title="1 of 2 branches missed.">      if (func_dom == null) throw new ParseException(&quot;Error: The domain&quot; + dom_name + &quot; has not been declared. There not exists a function with this domain.\n&quot;);</span>
    }
    else
    {
<span class="fc" id="L1354">      dom_name = &quot;Prod(&quot;.concat(dom_name).concat(&quot;)&quot;);</span>
<span class="fc" id="L1355">      func_dom = Utility.getStructuredDomain(domainsFactory, dom_name, header.getSignature());</span>
<span class="pc bpc" id="L1356" title="1 of 2 branches missed.">      if (func_dom == null) throw new ParseException(&quot;Error: The domain&quot; + dom_name + &quot; has not been declared. There not exists a function with this domain.\n&quot;);</span>
    }
    //check if the function has been declared
<span class="fc" id="L1359">    Function f = Utility.getFunction(func_name, func_dom, false, new HashMap &lt; String, Domain &gt; (), declared_Func);</span>
<span class="pc bpc" id="L1360" title="1 of 2 branches missed.">    if (f == null) throw new ParseException(&quot;Error: The function &quot; + func_name + &quot;(&quot; + dom_name + &quot;)&quot; + &quot; has not been declared. It cannot be defined!\n&quot;);</span>
    //check if the function has already been defined
<span class="pc bpc" id="L1362" title="1 of 2 branches missed.">    if (f.getDefinition() != null) throw new ParseException(&quot;Error: The function &quot; + func_name + &quot;(&quot; + dom_name + &quot;)&quot; + &quot; has been defined twice.\n&quot;);</span>
    //set the reference to the function to define
<span class="fc" id="L1364">    func_def.setDefinedFunction(f);</span>
<span class="fc" id="L1365">    f.setDefinition(func_def);</span>
    //create the association
    //X ADefinitionDefinedFunction a_FuncDef_Func = structurePack.getADefinitionDefinedFunction();
    //X a_FuncDef_Func.add(f,func_def);
    //check ocl constraint 1
<span class="pc bpc" id="L1370" title="1 of 4 branches missed.">    if (!((f instanceof StaticFunction) || (f instanceof DerivedFunction))) throw new ParseException(&quot;Error: Only static and derived functions can be defined.\n&quot; + &quot;       At the definition of the function &quot; + func_name + &quot;(&quot; + dom_name + &quot;)&quot; + &quot;.\n&quot;);</span>
<span class="pc bpc" id="L1371" title="1 of 2 branches missed.">    if (!OCL_Checker.checkFunctionDefinition(func_def)) throw new ParseException(OCL_Checker.getMsgErr() + &quot;\n       At the definition of the function &quot; + func_name + &quot;(&quot; + dom_name + &quot;)&quot; + &quot;.\n&quot;);</span>
<span class="fc" id="L1372">    {if (&quot;&quot; != null) return func_def;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public RuleDeclaration RuleDeclaration() throws ParseException {RuleDeclaration result;
<span class="pc bpc" id="L1377" title="2 of 5 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case RULE:
    case MACRO:{
<span class="fc" id="L1380">      result = MacroDeclaration();</span>
<span class="fc" id="L1381">      break;</span>
      }
    case TURBO:{
<span class="fc" id="L1384">      result = TurboDeclaration();</span>
<span class="fc" id="L1385">      break;</span>
      }
    default:
<span class="nc" id="L1388">      jj_la1[28] = jj_gen;</span>
<span class="nc" id="L1389">      jj_consume_token(-1);</span>
<span class="nc" id="L1390">      throw new ParseException();</span>
    }
<span class="fc" id="L1392">{if (&quot;&quot; != null) return result;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

<span class="fc" id="L1396">  final public MacroDeclaration MacroDeclaration() throws ParseException {Logger.logDebug(&quot;macro rule&quot;);</span>
<span class="fc" id="L1397">  MacroDeclaration ruleDecl = rulesPack.getBasicTransitionRules().createMacroDeclaration();</span>
  String ruleName;
  List &lt; VariableTerm &gt; vars;
  Rule body;
<span class="fc" id="L1401">  int arity = 0;</span>
<span class="fc" id="L1402">  HashMap &lt; String, VariableTerm &gt; localVar = new HashMap &lt; String, VariableTerm &gt; ();</span>
<span class="fc bfc" id="L1403" title="All 4 branches covered.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case MACRO:{
<span class="fc" id="L1405">      jj_consume_token(MACRO);</span>
<span class="fc" id="L1406">      break;</span>
      }
    default:
<span class="fc" id="L1409">      jj_la1[29] = jj_gen;</span>
      ;
    }
<span class="fc" id="L1412">    jj_consume_token(RULE);</span>
<span class="fc" id="L1413">    ruleName = ID_RULE();</span>
<span class="fc" id="L1414">Logger.logDebug(&quot;\t&quot; + ruleName);</span>
<span class="fc" id="L1415">    ruleDecl.setName(ruleName);</span>
<span class="fc" id="L1416">    List &lt; VariableTerm &gt; variables = ruleDecl.getVariable();</span>
<span class="pc bpc" id="L1417" title="1 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case 115:{
<span class="fc" id="L1419">Logger.logDebug(&quot;variables: &quot;);</span>
      VariableTerm v;
      Domain inDom;
<span class="fc" id="L1422">      jj_consume_token(115);</span>
<span class="fc" id="L1423">      v = VariableTerm(localVar, true);</span>
<span class="fc" id="L1424">      jj_consume_token(IN);</span>
<span class="fc" id="L1425">      inDom = getDomainByID();</span>
//add it to the list
<span class="fc" id="L1427">      variables.add(v);</span>
      //create the association
      //X ARuleDeclarationVariable ARuleDeclVar = defPack.getARuleDeclarationVariable();
      //X ARuleDeclVar.add(v,ruleDecl);
      //update variable features
<span class="fc" id="L1432">      Utility.updateVariable(v, inDom);</span>
      //update the arity value
<span class="fc" id="L1434">      arity++;</span>
<span class="fc" id="L1435">      Logger.logDebug(&quot;\t\t\t&quot; + v.getName() + &quot; updated: TD=&quot; + v.getDomain().getName() + &quot;, kind=&quot; + v.getKind().toString());</span>
      label_19:
      while (true) {
<span class="fc bfc" id="L1438" title="All 4 branches covered.">        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
        case 116:{
<span class="fc" id="L1440">          break;</span>
          }
        default:
<span class="fc" id="L1443">          jj_la1[30] = jj_gen;</span>
<span class="fc" id="L1444">          break label_19;</span>
        }
<span class="fc" id="L1446">        jj_consume_token(116);</span>
//check if the next variable is already used (look for it in the localVar HashMap)
<span class="fc" id="L1448">        String nextVar = getToken(1).image;</span>
<span class="pc bpc" id="L1449" title="1 of 2 branches missed.">        if (localVar.get(nextVar) != null) throw new ParseException(&quot;Error: The variable &quot; + nextVar + &quot; cannot be used because it is already used.&quot;);</span>
<span class="fc" id="L1450">        v = VariableTerm(localVar, true);</span>
<span class="fc" id="L1451">        jj_consume_token(IN);</span>
<span class="fc" id="L1452">        inDom = getDomainByID();</span>
//add it to the list
<span class="fc" id="L1454">        variables.add(v);</span>
        //create the association
        //X ARuleDeclVar.add(v,ruleDecl);
        //set the variable type-domain
<span class="fc" id="L1458">        Utility.updateVariable(v, inDom);</span>
        //(OCL constraint 2) set variable kind
        //if(inDom instanceof RuleDomain)
        //   v.setKind(VariableKind.forName(&quot;ruleVar&quot;));
        //update the arity value
<span class="fc" id="L1463">        arity++;</span>
<span class="fc" id="L1464">        Logger.logDebug(&quot;\t\t\t&quot; + v.getName() + &quot; updated: TD=&quot; + v.getDomain().getName() + &quot;, kind=&quot; + v.getKind().toString());</span>
<span class="fc" id="L1465">      }</span>
<span class="fc" id="L1466">      jj_consume_token(117);</span>
<span class="fc" id="L1467">      break;</span>
      }
    default:
<span class="fc" id="L1470">      jj_la1[31] = jj_gen;</span>
      ;
    }
<span class="fc" id="L1473">    jj_consume_token(EQ);</span>
// add this rule to the declared rules
<span class="fc" id="L1475">    Logger.logDebug(&quot;body:&quot;);</span>
<span class="fc" id="L1476">    body = Rule(localVar, ruleDecl);</span>
//set the reference
<span class="fc" id="L1478">    ruleDecl.setRuleBody(body);</span>
<span class="fc" id="L1479">    ruleDecl.setArity(arity);</span>
    //constraint 1 is granted for construction
<span class="fc" id="L1481">    {if (&quot;&quot; != null) return ruleDecl;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

<span class="fc" id="L1485">  final public TurboDeclaration TurboDeclaration() throws ParseException {Logger.logDebug(&quot;turbo rule \n&quot;);</span>
<span class="fc" id="L1486">  TurboDeclaration ruleDecl = rulesPack.getTurboTransitionRules().createTurboDeclaration();</span>
  String ruleName;
  List &lt; VariableTerm &gt; vars;
  Rule body;
<span class="fc" id="L1490">  int arity = 0;</span>
  Domain inDom;
<span class="fc" id="L1492">  HashMap &lt; String, VariableTerm &gt; localVar = new HashMap &lt; String, VariableTerm &gt; ();</span>
<span class="fc" id="L1493">    jj_consume_token(TURBO);</span>
<span class="fc" id="L1494">    jj_consume_token(RULE);</span>
<span class="fc" id="L1495">    ruleName = ID_RULE();</span>
<span class="fc" id="L1496">ruleDecl.setName(ruleName);</span>
<span class="fc" id="L1497">    Logger.logDebug(&quot;\t&quot; + ruleName);</span>
<span class="fc" id="L1498">    List variables = ruleDecl.getVariable();</span>
<span class="pc bpc" id="L1499" title="1 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case 115:{
<span class="fc" id="L1501">Logger.logDebug(&quot;variables: &quot;);</span>
      VariableTerm v;
<span class="fc" id="L1503">      jj_consume_token(115);</span>
<span class="fc" id="L1504">      v = VariableTerm(localVar, true);</span>
<span class="fc" id="L1505">      jj_consume_token(IN);</span>
<span class="fc" id="L1506">      inDom = getDomainByID();</span>
//add it to the list
<span class="fc" id="L1508">      variables.add(v);</span>
      //create the association
      //X ARuleDeclarationVariable ARuleDeclVar = defPack.getARuleDeclarationVariable();
      //X ARuleDeclVar.add(v,ruleDecl);
      //update variable features
<span class="fc" id="L1513">      Utility.updateVariable(v, inDom);</span>
      //update the arity value
<span class="fc" id="L1515">      arity++;</span>
<span class="fc" id="L1516">      Logger.logDebug(&quot;\t\t\t&quot; + v.getName() + &quot; updated: TD=&quot; + v.getDomain().getName() + &quot;, kind=&quot; + v.getKind().toString());</span>
      label_20:
      while (true) {
<span class="fc bfc" id="L1519" title="All 4 branches covered.">        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
        case 116:{
<span class="fc" id="L1521">          break;</span>
          }
        default:
<span class="fc" id="L1524">          jj_la1[32] = jj_gen;</span>
<span class="fc" id="L1525">          break label_20;</span>
        }
<span class="fc" id="L1527">        jj_consume_token(116);</span>
//check if the next variable is already used (look for it in the localVar HashMap)
<span class="fc" id="L1529">        String nextVar = getToken(1).image;</span>
<span class="pc bpc" id="L1530" title="1 of 2 branches missed.">        if (localVar.get(nextVar) != null) throw new ParseException(&quot;Error: The variable &quot; + nextVar + &quot; cannot be used because it is already used.&quot;);</span>
<span class="fc" id="L1531">        v = VariableTerm(localVar, true);</span>
<span class="fc" id="L1532">        jj_consume_token(IN);</span>
<span class="fc" id="L1533">        inDom = getDomainByID();</span>
//add it to the list
<span class="fc" id="L1535">        variables.add(v);</span>
        //create the association
        //X ARuleDeclVar.add(v,ruleDecl);
        //set the variable type-domain
<span class="fc" id="L1539">        Utility.updateVariable(v, inDom);</span>
        //(OCL constraint 2) set variable kind
        //if(inDom instanceof RuleDomain)
        //v.setKind(VariableKind.forName(&quot;ruleVar&quot;));
        //update the arity value
<span class="fc" id="L1544">        arity++;</span>
<span class="fc" id="L1545">        Logger.logDebug(&quot;\t\t\t&quot; + v.getName() + &quot; updated: TD=&quot; + v.getDomain().getName() + &quot;, kind=&quot; + v.getKind().toString());</span>
<span class="fc" id="L1546">      }</span>
<span class="fc" id="L1547">      jj_consume_token(117);</span>
<span class="fc" id="L1548">      break;</span>
      }
    default:
<span class="fc" id="L1551">      jj_la1[33] = jj_gen;</span>
      ;
    }
<span class="fc bfc" id="L1554" title="All 4 branches covered.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case IN:{
<span class="fc" id="L1556">      jj_consume_token(IN);</span>
<span class="fc" id="L1557">      inDom = getDomainByID();</span>
<span class="fc" id="L1558">Logger.logDebug(&quot;\t\t\tReturn type: &quot; + inDom.getName());</span>
<span class="fc" id="L1559">      ruleDecl.setResultType(inDom);</span>
<span class="fc" id="L1560">      Logger.logDebug(&quot;=&quot;);</span>
<span class="fc" id="L1561">      break;</span>
      }
    default:
<span class="fc" id="L1564">      jj_la1[34] = jj_gen;</span>
      ;
    }
<span class="fc" id="L1567">    jj_consume_token(EQ);</span>
<span class="fc" id="L1568">Logger.logDebug(&quot;body:&quot;);</span>
<span class="fc" id="L1569">    body = Rule(localVar, ruleDecl);</span>
//set the reference
<span class="fc" id="L1571">    ruleDecl.setRuleBody(body);</span>
<span class="fc" id="L1572">    ruleDecl.setArity(arity);</span>
    //constraint 1 is granted for construction
<span class="fc" id="L1574">    {if (&quot;&quot; != null) return ruleDecl;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public Property Property(Asm m) throws ParseException {Property p;
<span class="pc bpc" id="L1579" title="2 of 5 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case INVARIANT:{
<span class="fc" id="L1581">      p = Invariant(m);</span>
<span class="fc" id="L1582">      break;</span>
      }
    case CTLSPEC:
    case LTLSPEC:{
<span class="fc" id="L1586">      p = TemporalProperty(m);</span>
<span class="fc" id="L1587">      break;</span>
      }
    default:
<span class="nc" id="L1590">      jj_la1[35] = jj_gen;</span>
<span class="nc" id="L1591">      jj_consume_token(-1);</span>
<span class="nc" id="L1592">      throw new ParseException();</span>
    }
<span class="fc" id="L1594">{if (&quot;&quot; != null) return p;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public TemporalProperty TemporalProperty(Asm m) throws ParseException {TemporalProperty tp;
<span class="pc bpc" id="L1599" title="2 of 5 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case CTLSPEC:{
<span class="fc" id="L1601">      tp = CtlSpec(m);</span>
<span class="fc" id="L1602">      break;</span>
      }
    case LTLSPEC:{
<span class="fc" id="L1605">      tp = LtlSpec(m);</span>
<span class="fc" id="L1606">      break;</span>
      }
    default:
<span class="nc" id="L1609">      jj_la1[36] = jj_gen;</span>
<span class="nc" id="L1610">      jj_consume_token(-1);</span>
<span class="nc" id="L1611">      throw new ParseException();</span>
    }
<span class="fc" id="L1613">{if (&quot;&quot; != null) return tp;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public Invariant Invariant(Asm m) throws ParseException {String idElement;
  Term exp;
<span class="fc" id="L1619">  HashMap localVar = new HashMap();</span>
<span class="fc" id="L1620">  boolean funHasArg = false;</span>
<span class="fc" id="L1621">  String name = &quot;&quot;;</span>
<span class="fc" id="L1622">    jj_consume_token(INVARIANT);</span>
<span class="pc bpc" id="L1623" title="1 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case ID_AXIOM:{
<span class="fc" id="L1625">      name = ID_AXIOM();</span>
<span class="fc" id="L1626">      break;</span>
      }
    default:
<span class="fc" id="L1629">      jj_la1[37] = jj_gen;</span>
      ;
    }
<span class="fc" id="L1632">    jj_consume_token(OVER);</span>
<span class="fc" id="L1633">Logger.logDebug(&quot;invariant &quot; + name + &quot;over &quot;);</span>
<span class="fc" id="L1634">    Invariant invariant = defPack.createInvariant();</span>
<span class="fc" id="L1635">    invariant.setName(name);</span>
    //XX AConstraintConstrainedDomain AAxiomDom = defPack.getAConstraintConstrainedDomain();
    //XX AConstraintConstrainedFunction AAxiomFunc = defPack.getAConstraintConstrainedFunction();
    //XX AConstraintConstrainedRule AAxiomRule = defPack.getAConstraintConstrainedRule();
<span class="fc" id="L1639">    Collection domains = invariant.getConstrainedDomain();</span>
<span class="fc" id="L1640">    Collection functions = invariant.getConstrainedFunction();</span>
<span class="fc" id="L1641">    Collection rules = invariant.getConstrainedRule();</span>
<span class="fc" id="L1642">    Domain dom = null;</span>
<span class="fc" id="L1643">    Function func = null;</span>
    RuleDeclaration rule;
<span class="pc bpc" id="L1645" title="3 of 6 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case ID_DOMAIN:{
<span class="fc" id="L1647">      idElement = ID_DOMAIN();</span>
<span class="fc" id="L1648">dom = (Domain) declared_Dom.get(idElement);</span>
<span class="pc bpc" id="L1649" title="1 of 2 branches missed.">      if (dom == null) dom = Utility.getBasicDomain(domainsFactory, idElement);</span>
<span class="pc bpc" id="L1650" title="1 of 2 branches missed.">      if (dom == null) dom = Utility.getPredefinedAbstractDomain(domainsFactory, idElement);</span>
<span class="pc bpc" id="L1651" title="1 of 2 branches missed.">      if (dom == null) dom = Utility.getStructuredDomain(domainsFactory, idElement, header.getSignature());</span>
<span class="pc bpc" id="L1652" title="1 of 2 branches missed.">      if (dom == null) throw new ParseException(&quot;Error: The domain &quot; + idElement + &quot; has not been declared. Invariant declaration failed &quot;);</span>
<span class="fc" id="L1653">      domains.add(dom);</span>
<span class="fc" id="L1654">      dom.getConstraint().add(invariant);</span>
      //create the association
      //XX AAxiomDom.add(dom,invariant);
<span class="fc" id="L1657">      dom = null;</span>
<span class="fc" id="L1658">      Logger.logDebug(idElement);</span>
<span class="fc" id="L1659">      break;</span>
      }
    case ID_FUNCTION:{
<span class="fc" id="L1662">      idElement = ID_FUNCTION();</span>
<span class="pc bpc" id="L1663" title="1 of 4 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case 115:{
<span class="fc" id="L1665">        jj_consume_token(115);</span>
<span class="pc bpc" id="L1666" title="2 of 4 branches missed.">        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
        case PROD:
        case SEQ:
        case POWERSET:
        case BAG:
        case MAP:
        case RULEDOM:
        case ID_DOMAIN:{
<span class="nc" id="L1674">          dom = getDomainByID();</span>
<span class="nc" id="L1675">          break;</span>
          }
        default:
<span class="fc" id="L1678">          jj_la1[38] = jj_gen;</span>
          ;
        }
<span class="fc" id="L1681">        jj_consume_token(117);</span>
<span class="fc" id="L1682">funHasArg = true;</span>
<span class="fc" id="L1683">        break;</span>
        }
      default:
<span class="fc" id="L1686">        jj_la1[39] = jj_gen;</span>
        ;
      }
<span class="fc bfc" id="L1689" title="All 2 branches covered.">if (!funHasArg)</span>
      {
<span class="fc" id="L1691">        LinkedList f_list = (LinkedList) declared_Func.get(idElement);</span>
<span class="pc bpc" id="L1692" title="1 of 2 branches missed.">        if (f_list == null) throw new ParseException(&quot;Error: The function &quot; + idElement + &quot; has not been declared. Invariant declaration failed.&quot;);</span>
<span class="pc bpc" id="L1693" title="1 of 2 branches missed.">        else if (f_list.size() == 1) func = (Function) f_list.getFirst();</span>
<span class="nc" id="L1694">        else throw new ParseException(&quot;Error: The function &quot; + idElement + &quot; is overloaded. Specify its domain in the invariant declaration.&quot;);</span>
<span class="fc" id="L1695">      }</span>
      else
      {
<span class="fc" id="L1698">        func = Utility.getFunction(idElement, dom, false, new HashMap(), declared_Func);</span>
<span class="pc bpc" id="L1699" title="1 of 2 branches missed.">        if (func == null) throw new ParseException(&quot;Error: The function &quot; + idElement + &quot;(&quot; + dom.getName() + &quot;) has not been declared. Invariant declaration failed &quot;);</span>
      }
<span class="fc" id="L1701">      functions.add(func);</span>
<span class="fc" id="L1702">      func.getConstraint().add(invariant);</span>
      //create the association
      //XX AAxiomFunc.add(func,invariant);
<span class="fc" id="L1705">      Logger.logDebug(idElement);</span>
<span class="fc bfc" id="L1706" title="All 2 branches covered.">      if (func.getDomain() != null) Logger.logDebug(&quot;(&quot; + func.getDomain().getName() + &quot;)&quot;);</span>
<span class="fc" id="L1707">      funHasArg = false;</span>
<span class="fc" id="L1708">      break;</span>
      }
    case ID_RULE:{
<span class="nc" id="L1711">      idElement = ID_RULE();</span>
<span class="nc" id="L1712">rule = Utility.getRuleByNameDom(declared_Rules, idElement, null);</span>
<span class="nc" id="L1713">      rules.add(rule);</span>
<span class="nc" id="L1714">      rule.getConstraint().add(invariant);</span>
<span class="nc" id="L1715">      Logger.logDebug(idElement);</span>
<span class="nc" id="L1716">      break;</span>
      }
    default:
<span class="nc" id="L1719">      jj_la1[40] = jj_gen;</span>
<span class="nc" id="L1720">      jj_consume_token(-1);</span>
<span class="nc" id="L1721">      throw new ParseException();</span>
    }
    label_21:
    while (true) {
<span class="fc bfc" id="L1725" title="All 4 branches covered.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case 116:{
<span class="fc" id="L1727">        break;</span>
        }
      default:
<span class="fc" id="L1730">        jj_la1[41] = jj_gen;</span>
<span class="fc" id="L1731">        break label_21;</span>
      }
<span class="fc" id="L1733">      jj_consume_token(116);</span>
<span class="pc bpc" id="L1734" title="4 of 6 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case ID_DOMAIN:{
<span class="nc" id="L1736">        idElement = ID_DOMAIN();</span>
<span class="nc" id="L1737">dom = (Domain) declared_Dom.get(idElement);</span>
<span class="nc bnc" id="L1738" title="All 2 branches missed.">        if (dom == null) dom = Utility.getBasicDomain(domainsFactory, idElement);</span>
<span class="nc bnc" id="L1739" title="All 2 branches missed.">        if (dom == null) dom = Utility.getPredefinedAbstractDomain(domainsFactory, idElement);</span>
<span class="nc bnc" id="L1740" title="All 2 branches missed.">        if (dom == null) dom = Utility.getStructuredDomain(domainsFactory, idElement, header.getSignature());</span>
<span class="nc bnc" id="L1741" title="All 2 branches missed.">        if (dom == null) throw new ParseException(&quot;Error: The domain &quot; + idElement + &quot; has not been declared. Invariant declaration failed &quot;);</span>
<span class="nc" id="L1742">        domains.add(dom);</span>
<span class="nc" id="L1743">        dom.getConstraint().add(invariant);</span>
        //create the association
        //XX AAxiomDom.add(dom,invariant);
<span class="nc" id="L1746">        dom = null;</span>
<span class="nc" id="L1747">        Logger.logDebug(&quot;,&quot; + idElement);</span>
<span class="nc" id="L1748">        break;</span>
        }
      case ID_FUNCTION:{
<span class="fc" id="L1751">        idElement = ID_FUNCTION();</span>
<span class="pc bpc" id="L1752" title="1 of 4 branches missed.">        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
        case 115:{
<span class="fc" id="L1754">          jj_consume_token(115);</span>
<span class="pc bpc" id="L1755" title="2 of 4 branches missed.">          switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
          case PROD:
          case SEQ:
          case POWERSET:
          case BAG:
          case MAP:
          case RULEDOM:
          case ID_DOMAIN:{
<span class="nc" id="L1763">            dom = getDomainByID();</span>
<span class="nc" id="L1764">            break;</span>
            }
          default:
<span class="fc" id="L1767">            jj_la1[42] = jj_gen;</span>
            ;
          }
<span class="fc" id="L1770">          jj_consume_token(117);</span>
<span class="fc" id="L1771">          break;</span>
          }
        default:
<span class="fc" id="L1774">          jj_la1[43] = jj_gen;</span>
          ;
        }
<span class="pc bpc" id="L1777" title="1 of 2 branches missed.">if (!funHasArg)</span>
        {
<span class="fc" id="L1779">          LinkedList f_list = (LinkedList) declared_Func.get(idElement);</span>
<span class="pc bpc" id="L1780" title="1 of 2 branches missed.">          if (f_list == null) throw new ParseException(&quot;Error: The function &quot; + idElement + &quot; has not been declared. Invariant declaration failed &quot;);</span>
<span class="pc bpc" id="L1781" title="1 of 2 branches missed.">          else if (f_list.size() == 1) func = (Function) f_list.getFirst();</span>
<span class="nc" id="L1782">          else throw new ParseException(&quot;Error: The function &quot; + idElement + &quot; is overloaded. Specify its domain in the invariant declaration. &quot;);</span>
<span class="fc" id="L1783">        }</span>
        else
        {
<span class="nc" id="L1786">          func = Utility.getFunction(idElement, dom, false, new HashMap(), declared_Func);</span>
<span class="nc bnc" id="L1787" title="All 2 branches missed.">          if (func == null) throw new ParseException(&quot;Error: The function &quot; + idElement + &quot;(&quot; + dom.getName() + &quot;) has not been declared. Invariant declaration failed &quot;);</span>
        }
<span class="fc" id="L1789">        functions.add(func);</span>
<span class="fc" id="L1790">        func.getConstraint().add(invariant);</span>
        //create the association
        //XX AAxiomFunc.add(func,invariant);
<span class="fc" id="L1793">        Logger.logDebug(&quot;,&quot; + idElement);</span>
<span class="fc bfc" id="L1794" title="All 2 branches covered.">        if (func.getDomain() != null) Logger.logDebug(&quot;(&quot; + func.getDomain().getName() + &quot;)&quot;);</span>
<span class="fc" id="L1795">        funHasArg = false;</span>
<span class="fc" id="L1796">        break;</span>
        }
      case ID_RULE:{
<span class="nc" id="L1799">        idElement = ID_RULE();</span>
<span class="nc" id="L1800">rule = Utility.getRuleByNameDom(declared_Rules, idElement, null);</span>
<span class="nc" id="L1801">        rules.add(rule);</span>
<span class="nc" id="L1802">        rule.getConstraint().add(invariant);</span>
        //create the association
        //XX AAxiomRule.add(rule,invariant);
<span class="nc" id="L1805">        Logger.logDebug(&quot;,&quot; + idElement);</span>
<span class="nc" id="L1806">        break;</span>
        }
      default:
<span class="nc" id="L1809">        jj_la1[44] = jj_gen;</span>
<span class="nc" id="L1810">        jj_consume_token(-1);</span>
<span class="nc" id="L1811">        throw new ParseException();</span>
      }
    }
<span class="fc" id="L1814">    jj_consume_token(118);</span>
<span class="fc" id="L1815">Logger.logDebug(&quot;body:&quot;);</span>
<span class="fc" id="L1816">    exp = Term(localVar, false, null);</span>
<span class="fc" id="L1817">invariant.setBody(exp);</span>
    //create the association
    //XX AAxiomBody AAxiomBody = defPack.getAAxiomBody();
    //XX AAxiomBody.add(invariant,exp);
    //ocl constraint 1 is granted for construction
    //check ocl constraint 2
    //PA 30/12/2010 poiche' abbiamo introdotto gli operatori temporali come
    //funzioni con codominio Boolean, qui bisognerebbe anche controllare
    //che all'interno di exp non sia stata utilizzata una funzione della
    //CTLlibrary o della LTLlibrary
<span class="pc bpc" id="L1827" title="1 of 2 branches missed.">    if (!OCL_Checker.isBoolean(exp))</span>
    {
<span class="nc" id="L1829">      Logger.logErr(&quot;Error: The expression specifying an invariant must be a term whose associated type-domain is Boolean.&quot;);</span>
      //PA 2 feb 2011: aggiunta ParseException  
<span class="nc" id="L1831">      throw new ParseException(&quot;Error: The expression specifying an invariant must be a term whose associated type-domain is Boolean.&quot;);</span>
    }
<span class="fc" id="L1833">{if (&quot;&quot; != null) return invariant;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

//PA 19/05/2014 in order to add the CTLSPEC, LTLSPEC, FAIRNESS, JUSTICE, COMPASSION, and INVAR keywords: START
  final public CtlSpec CtlSpec(Asm m) throws ParseException {Term exp;
<span class="fc" id="L1839">  HashMap localVar = new HashMap();</span>
<span class="fc" id="L1840">  String name = null;</span>
<span class="fc" id="L1841">    jj_consume_token(CTLSPEC);</span>
<span class="pc bpc" id="L1842" title="1 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case ID_CTL:{
<span class="fc" id="L1844">      name = ID_CTL();</span>
<span class="fc" id="L1845">      jj_consume_token(118);</span>
<span class="fc" id="L1846">      break;</span>
      }
    default:
<span class="fc" id="L1849">      jj_la1[45] = jj_gen;</span>
      ;
    }
<span class="fc" id="L1852">Logger.logDebug(&quot;CTLSPEC&quot;);</span>
<span class="fc" id="L1853">    CtlSpec ctlSpec = defPack.createCtlSpec();</span>
<span class="fc bfc" id="L1854" title="All 2 branches covered.">    if (name != null)</span>
    {
<span class="fc" id="L1856">      ctlSpec.setName(name);</span>
    }
<span class="fc" id="L1858">Logger.logDebug(&quot;body:&quot;);</span>
<span class="fc" id="L1859">    exp = Term(localVar, false, null);</span>
<span class="fc" id="L1860">ctlSpec.setBody(exp);</span>
    //PA 30/12/2010 here we should check that no function of the LTLlibrary is used
<span class="pc bpc" id="L1862" title="1 of 2 branches missed.">    if (!OCL_Checker.isBoolean(exp))</span>
    {
<span class="nc" id="L1864">      Logger.logErr(&quot;Error: The expression specifying a CTL propery must be a term whose associated type-domain is Boolean.&quot;);</span>
<span class="nc" id="L1865">      throw new ParseException(&quot;Error: The expression specifying a CTL propery must be a term whose associated type-domain is Boolean.&quot;);</span>
    }
<span class="fc" id="L1867">{if (&quot;&quot; != null) return ctlSpec;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public LtlSpec LtlSpec(Asm m) throws ParseException {Term exp;
<span class="fc" id="L1872">  HashMap localVar = new HashMap();</span>
<span class="fc" id="L1873">  String name = null;</span>
  Token t;
<span class="fc" id="L1875">    jj_consume_token(LTLSPEC);</span>
<span class="pc bpc" id="L1876" title="1 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case ID_LTL:{
<span class="fc" id="L1878">      name = ID_LTL();</span>
<span class="fc" id="L1879">      jj_consume_token(118);</span>
<span class="fc" id="L1880">      break;</span>
      }
    default:
<span class="fc" id="L1883">      jj_la1[46] = jj_gen;</span>
      ;
    }
<span class="fc" id="L1886">Logger.logDebug(&quot;LTLSPEC&quot;);</span>
<span class="fc" id="L1887">    LtlSpec ltlSpec = defPack.createLtlSpec();</span>
<span class="fc bfc" id="L1888" title="All 2 branches covered.">    if (name != null)</span>
    {
<span class="fc" id="L1890">      ltlSpec.setName(name);</span>
    }
<span class="fc" id="L1892">Logger.logDebug(&quot;body:&quot;);</span>
<span class="fc" id="L1893">    exp = Term(localVar, false, null);</span>
<span class="fc" id="L1894">ltlSpec.setBody(exp);</span>
    //PA 30/12/2010 here we should check that no function of the CTLlibrary is used
<span class="pc bpc" id="L1896" title="1 of 2 branches missed.">    if (!OCL_Checker.isBoolean(exp))</span>
    {
<span class="nc" id="L1898">      Logger.logErr(&quot;Error: The expression specifying an LTL property must be a term whose associated type-domain is Boolean.&quot;);</span>
<span class="nc" id="L1899">      throw new ParseException(&quot;Error: The expression specifying an LTL property must be a term whose associated type-domain is Boolean.&quot;);</span>
    }
<span class="fc" id="L1901">{if (&quot;&quot; != null) return ltlSpec;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public FairnessConstraint FairnessConstraint(Asm m) throws ParseException {FairnessConstraint fc;
<span class="pc bpc" id="L1906" title="3 of 5 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case JUSTICE:{
<span class="fc" id="L1908">      fc = JusticeConstraint(m);</span>
<span class="fc" id="L1909">      break;</span>
      }
    case COMPASSION:{
<span class="nc" id="L1912">      fc = CompassionConstraint(m);</span>
<span class="nc" id="L1913">      break;</span>
      }
    default:
<span class="nc" id="L1916">      jj_la1[47] = jj_gen;</span>
<span class="nc" id="L1917">      jj_consume_token(-1);</span>
<span class="nc" id="L1918">      throw new ParseException();</span>
    }
<span class="fc" id="L1920">{if (&quot;&quot; != null) return fc;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public JusticeConstraint JusticeConstraint(Asm m) throws ParseException {Term exp;
<span class="fc" id="L1925">  HashMap localVar = new HashMap();</span>
<span class="fc" id="L1926">  String name = null;</span>
  Token t;
<span class="fc" id="L1928">    jj_consume_token(JUSTICE);</span>
<span class="fc" id="L1929">Logger.logDebug(&quot;JUSTICE&quot;);</span>
<span class="fc" id="L1930">    JusticeConstraint justiceConstraint = defPack.createJusticeConstraint();</span>
<span class="fc" id="L1931">Logger.logDebug(&quot;body:&quot;);</span>
<span class="fc" id="L1932">    exp = Term(localVar, false, null);</span>
<span class="fc" id="L1933">justiceConstraint.setBody(exp);</span>
<span class="pc bpc" id="L1934" title="1 of 2 branches missed.">    if (!OCL_Checker.isBoolean(exp))</span>
    {
<span class="nc" id="L1936">      Logger.logErr(&quot;Error: The expression specifying a JUSTICE constraint must be a term whose associated type-domain is Boolean.&quot;);</span>
<span class="nc" id="L1937">      throw new ParseException(&quot;Error: The expression specifying a JUSTICE constraint must be a term whose associated type-domain is Boolean.&quot;);</span>
    }
<span class="fc" id="L1939">{if (&quot;&quot; != null) return justiceConstraint;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public CompassionConstraint CompassionConstraint(Asm m) throws ParseException {Term p, q;
<span class="nc" id="L1944">  HashMap localVar = new HashMap();</span>
<span class="nc" id="L1945">  String name = null;</span>
  Token t;
<span class="nc" id="L1947">    jj_consume_token(COMPASSION);</span>
<span class="nc" id="L1948">Logger.logDebug(&quot;COMPASSION&quot;);</span>
<span class="nc" id="L1949">    CompassionConstraint compassionConstraint = defPack.createCompassionConstraint();</span>
<span class="nc" id="L1950">    jj_consume_token(115);</span>
<span class="nc" id="L1951">Logger.logDebug(&quot;p:&quot;);</span>
<span class="nc" id="L1952">    p = Term(localVar, false, null);</span>
<span class="nc" id="L1953">    jj_consume_token(116);</span>
<span class="nc" id="L1954">Logger.logDebug(&quot;q:&quot;);</span>
<span class="nc" id="L1955">    q = Term(localVar, false, null);</span>
<span class="nc" id="L1956">compassionConstraint.setP(p);</span>
<span class="nc bnc" id="L1957" title="All 2 branches missed.">    if (!OCL_Checker.isBoolean(p))</span>
    {
<span class="nc" id="L1959">      Logger.logErr(&quot;Error: The expression p specifying a COMPASSION constraint must be a term whose associated type-domain is Boolean.&quot;);</span>
<span class="nc" id="L1960">      throw new ParseException(&quot;Error: The expression p specifying a COMPASSION constraint must be a term whose associated type-domain is Boolean.&quot;);</span>
    }
<span class="nc" id="L1962">    compassionConstraint.setQ(q);</span>
<span class="nc bnc" id="L1963" title="All 2 branches missed.">    if (!OCL_Checker.isBoolean(q))</span>
    {
<span class="nc" id="L1965">      Logger.logErr(&quot;Error: The expression q specifying a COMPASSION constraint must be a term whose associated type-domain is Boolean.&quot;);</span>
<span class="nc" id="L1966">      throw new ParseException(&quot;Error: The expression q specifying a COMPASSION constraint must be a term whose associated type-domain is Boolean.&quot;);</span>
    }
<span class="nc" id="L1968">{if (&quot;&quot; != null) return compassionConstraint;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public InvarConstraint InvarConstraint(Asm m) throws ParseException {Term exp;
<span class="nc" id="L1973">  HashMap localVar = new HashMap();</span>
<span class="nc" id="L1974">  String name = null;</span>
  Token t;
<span class="nc" id="L1976">    jj_consume_token(INVAR);</span>
<span class="nc" id="L1977">Logger.logDebug(&quot;INVAR&quot;);</span>
<span class="nc" id="L1978">    InvarConstraint invarConstraint = defPack.createInvarConstraint();</span>
<span class="nc" id="L1979">Logger.logDebug(&quot;body:&quot;);</span>
<span class="nc" id="L1980">    exp = Term(localVar, false, null);</span>
<span class="nc" id="L1981">invarConstraint.setBody(exp);</span>
<span class="nc bnc" id="L1982" title="All 2 branches missed.">    if (!OCL_Checker.isBoolean(exp))</span>
    {
<span class="nc" id="L1984">      Logger.logErr(&quot;Error: The expression specifying an INVAR constraint must be a term whose associated type-domain is Boolean.&quot;);</span>
<span class="nc" id="L1985">      throw new ParseException(&quot;Error: The expression specifying an INVAR constraint must be a term whose associated type-domain is Boolean.&quot;);</span>
    }
<span class="nc" id="L1987">{if (&quot;&quot; != null) return invarConstraint;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

//PA 19/05/2014 in order to add the CTLSPEC, LTLSPEC, FAIRNESS, JUSTICE, COMPASSION, and INVAR keywords: END
/*-----------------------------------------------------------*/
/**********************    DOMAIN    *************************/
/*-----------------------------------------------------------*/
  final public Domain Domain() throws ParseException {Domain d;
<span class="fc bfc" id="L1996" title="All 2 branches covered.">    if (jj_2_5(2)) {</span>
<span class="fc" id="L1997">      d = ConcreteDomain();</span>
    } else {
<span class="pc bpc" id="L1999" title="2 of 4 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case DYNAMIC:
      case ANYDOMAIN:
      case BASIC:
      case ABSTRACT:
      case ENUM:
      case PROD:
      case SEQ:
      case POWERSET:
      case BAG:
      case MAP:
      case RULEDOM:{
<span class="fc" id="L2011">        d = TypeDomain();</span>
<span class="fc" id="L2012">        break;</span>
        }
      default:
<span class="nc" id="L2015">        jj_la1[48] = jj_gen;</span>
<span class="nc" id="L2016">        jj_consume_token(-1);</span>
<span class="nc" id="L2017">        throw new ParseException();</span>
      }
    }
<span class="fc" id="L2020">{if (&quot;&quot; != null) return d;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

/*----------------------  ConcreteDomain  --------------------*/
  final public ConcreteDomain ConcreteDomain() throws ParseException {String name;
<span class="fc" id="L2026">  boolean isDynamic = false;</span>
  Domain typeDom;
<span class="pc bpc" id="L2028" title="1 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case DYNAMIC:{
<span class="fc" id="L2030">      jj_consume_token(DYNAMIC);</span>
<span class="fc" id="L2031">isDynamic = true;</span>
<span class="fc" id="L2032">      break;</span>
      }
    default:
<span class="fc" id="L2035">      jj_la1[49] = jj_gen;</span>
      ;
    }
<span class="fc" id="L2038">    jj_consume_token(DOMAIN);</span>
<span class="fc" id="L2039">    name = ID_DOMAIN();</span>
<span class="fc" id="L2040">    jj_consume_token(SUBSETOF);</span>
<span class="fc" id="L2041">    typeDom = getDomainByID();</span>
<span class="pc bpc" id="L2042" title="1 of 2 branches missed.">if (!(typeDom instanceof TypeDomain))</span>
    {
<span class="nc" id="L2044">      throw new ParseException(&quot;Error: A concrete domain cannot be defined over a concrete domain.&quot;);</span>
    }
    //create the object
<span class="fc" id="L2047">    ConcreteDomain concreteDom = defPack.getDomains().createConcreteDomain();</span>
<span class="fc" id="L2048">    concreteDom.setName(name);</span>
<span class="fc" id="L2049">    concreteDom.setIsDynamic(isDynamic);</span>
    //set references
<span class="fc" id="L2051">    concreteDom.setTypeDomain((TypeDomain) typeDom);</span>
<span class="fc bfc" id="L2052" title="All 2 branches covered.">    Logger.logDebug(isDynamic ? &quot;dynamic&quot; : &quot;&quot; + &quot;domain &quot; + name + &quot; subsetof &quot; + typeDom.getName());</span>
<span class="fc" id="L2053">    {if (&quot;&quot; != null) return concreteDom;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

/*----------------------   TypeDomain  Ok! ----------------------*/
  final public TypeDomain TypeDomain() throws ParseException {TypeDomain d;
<span class="pc bpc" id="L2059" title="3 of 8 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case ANYDOMAIN:{
<span class="fc" id="L2061">      d = AnyDomain();</span>
<span class="fc" id="L2062">      break;</span>
      }
    case PROD:
    case SEQ:
    case POWERSET:
    case BAG:
    case MAP:
    case RULEDOM:{
<span class="nc" id="L2070">      d = StructuredTD();</span>
<span class="nc" id="L2071">      break;</span>
      }
    case ENUM:{
<span class="fc" id="L2074">      d = EnumTD();</span>
<span class="fc" id="L2075">      break;</span>
      }
    case DYNAMIC:
    case ABSTRACT:{
<span class="fc" id="L2079">      d = AbstractTD();</span>
<span class="fc" id="L2080">      break;</span>
      }
    case BASIC:{
<span class="fc" id="L2083">      d = BasicTD();</span>
<span class="fc" id="L2084">      break;</span>
      }
    default:
<span class="nc" id="L2087">      jj_la1[50] = jj_gen;</span>
<span class="nc" id="L2088">      jj_consume_token(-1);</span>
<span class="nc" id="L2089">      throw new ParseException();</span>
    }
<span class="fc" id="L2091">{if (&quot;&quot; != null) return d;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

/*---------------  AnyDomain  To be done! ------------------*/
  final public AnyDomain AnyDomain() throws ParseException {String name;
<span class="fc" id="L2097">    jj_consume_token(ANYDOMAIN);</span>
<span class="fc" id="L2098">    name = ID_DOMAIN();</span>
<span class="fc" id="L2099">AnyDomain d = Utility.getAnyDomain(domainsFactory, name);</span>
<span class="pc bpc" id="L2100" title="1 of 2 branches missed.">    if (d == null)</span>
    {
      // TODO
      // check name and in case
      // throw new ParseException(&quot;Error: The domain &quot;+ name + &quot; cannot be declared as an AnyDomain&quot;);
<span class="fc" id="L2105">      d = domainsFactory.createAnyDomain(name);</span>
    }
<span class="fc" id="L2107">    Logger.logDebug(&quot;anydomain &quot; + name);</span>
<span class="fc" id="L2108">    {if (&quot;&quot; != null) return d;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

/*---------------  BasicTD  OK! ------------------*/
  final public BasicTd BasicTD() throws ParseException {String name;
<span class="fc" id="L2114">    jj_consume_token(BASIC);</span>
<span class="fc" id="L2115">    jj_consume_token(DOMAIN);</span>
<span class="fc" id="L2116">    name = ID_DOMAIN();</span>
<span class="fc" id="L2117">BasicTd basicTd = Utility.getBasicDomain(domainsFactory, name);</span>
<span class="pc bpc" id="L2118" title="1 of 2 branches missed.">    if (basicTd == null) throw new ParseException(&quot;Error: A basic domain &quot; + name + &quot; not allowed has been declared.&quot;);</span>
<span class="fc" id="L2119">    Logger.logDebug(&quot;basic domain &quot; + name);</span>
<span class="fc" id="L2120">    {if (&quot;&quot; != null) return basicTd;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

/*-------------  AbstractTD  OK! -----------------*/
  final public AbstractTd AbstractTD() throws ParseException {String name;
<span class="fc" id="L2126">  boolean isDynamic = false;</span>
<span class="pc bpc" id="L2127" title="1 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case DYNAMIC:{
<span class="fc" id="L2129">      jj_consume_token(DYNAMIC);</span>
<span class="fc" id="L2130">isDynamic = true;</span>
<span class="fc" id="L2131">      break;</span>
      }
    default:
<span class="fc" id="L2134">      jj_la1[51] = jj_gen;</span>
      ;
    }
<span class="fc" id="L2137">    jj_consume_token(ABSTRACT);</span>
<span class="fc" id="L2138">    jj_consume_token(DOMAIN);</span>
<span class="fc" id="L2139">    name = ID_DOMAIN();</span>
// try predefined
<span class="fc" id="L2141">    AbstractTd abstractTd = Utility.getPredefinedAbstractDomain(domainsFactory, name);</span>
    // otherwise create new one
<span class="fc bfc" id="L2143" title="All 2 branches covered.">    if (abstractTd == null)</span>
    {
<span class="fc" id="L2145">      abstractTd = domainsFactory.createAbstractTd();</span>
<span class="fc" id="L2146">      abstractTd.setName(name);</span>
<span class="fc" id="L2147">      abstractTd.setIsDynamic(isDynamic);</span>
<span class="fc" id="L2148">      Logger.logDebug(&quot;creating abstract domain &quot; + name);</span>
    }
    else
    {
<span class="fc" id="L2152">      Logger.logDebug(&quot;abstract domain &quot; + name);</span>
    }
<span class="fc" id="L2154">    {if (&quot;&quot; != null) return abstractTd;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

/*---------------  EnumTD  OK! -------------------*/
  final public EnumTd EnumTD() throws ParseException {String name;
  EnumElement elem;
<span class="fc" id="L2161">    jj_consume_token(ENUM);</span>
<span class="fc" id="L2162">    jj_consume_token(DOMAIN);</span>
<span class="fc" id="L2163">    name = ID_DOMAIN();</span>
<span class="fc" id="L2164">EnumTd enumTd = defPack.getDomains().createEnumTd();</span>
<span class="fc" id="L2165">    enumTd.setName(name);</span>
<span class="fc" id="L2166">    Collection elements = enumTd.getElement();</span>
<span class="fc" id="L2167">    Logger.logDebug(&quot;enum domain &quot; + name);</span>
<span class="fc" id="L2168">    jj_consume_token(EQ);</span>
<span class="fc" id="L2169">    jj_consume_token(119);</span>
<span class="fc" id="L2170">    elem = EnumElement();</span>
//add the new element to the collection
<span class="fc" id="L2172">    elements.add(elem);</span>
    //create the association
    //XX AEnumTdElem.add(elem,enumTd);
    //insert it in the hashMap of enum elements
<span class="fc" id="L2176">    String symbol = elem.getSymbol();</span>
<span class="pc bpc" id="L2177" title="1 of 2 branches missed.">    if (enumElem.put(symbol, enumTd) != null)</span>
    {
<span class="nc" id="L2179">      throw new ParseException(&quot;The enum symbol &quot; + symbol + &quot; is duplicate&quot;);</span>
    }
<span class="fc" id="L2181">    Logger.logDebug(&quot;={&quot; + symbol);</span>
    label_22:
    while (true) {
<span class="pc bpc" id="L2184" title="1 of 4 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case 116:
      case 120:{
<span class="fc" id="L2187">        break;</span>
        }
      default:
<span class="fc" id="L2190">        jj_la1[52] = jj_gen;</span>
<span class="fc" id="L2191">        break label_22;</span>
      }
<span class="pc bpc" id="L2193" title="2 of 5 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case 120:{
<span class="fc" id="L2195">        jj_consume_token(120);</span>
<span class="fc" id="L2196">        break;</span>
        }
      case 116:{
<span class="fc" id="L2199">        jj_consume_token(116);</span>
<span class="fc" id="L2200">        break;</span>
        }
      default:
<span class="nc" id="L2203">        jj_la1[53] = jj_gen;</span>
<span class="nc" id="L2204">        jj_consume_token(-1);</span>
<span class="nc" id="L2205">        throw new ParseException();</span>
      }
<span class="fc" id="L2207">      elem = EnumElement();</span>
//add new element to the collection
<span class="fc" id="L2209">      elements.add(elem);</span>
      //create the association
      //XX AEnumTdElem.add(elem,enumTd);
      //insert it in the hashMap of enum elements
<span class="fc" id="L2213">      symbol = elem.getSymbol();</span>
<span class="pc bpc" id="L2214" title="1 of 2 branches missed.">      if (enumElem.put(symbol, enumTd) != null)</span>
      {
<span class="nc" id="L2216">        throw new ParseException(&quot;The enum symbol &quot; + symbol + &quot; is duplicate&quot;);</span>
      }
<span class="fc" id="L2218">      Logger.logDebug(&quot;|&quot; + symbol);</span>
    }
<span class="fc" id="L2220">    jj_consume_token(121);</span>
<span class="fc" id="L2221">Logger.logDebug(&quot;}&quot;);</span>
<span class="fc" id="L2222">    {if (&quot;&quot; != null) return enumTd;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public EnumElement EnumElement() throws ParseException {String symbol;
<span class="fc" id="L2227">    symbol = ID_ENUM();</span>
<span class="fc" id="L2228">EnumElement elem = defPack.getDomains().createEnumElement();</span>
<span class="fc" id="L2229">    elem.setSymbol(symbol);</span>
<span class="fc" id="L2230">    {if (&quot;&quot; != null) return elem;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

/*-------------  StructuredTD  OK! ---------------*/
  final public StructuredTd StructuredTD() throws ParseException {StructuredTd d;
<span class="pc bpc" id="L2236" title="2 of 9 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case RULEDOM:{
<span class="fc" id="L2238">      d = RuleDomain();</span>
<span class="fc" id="L2239">      break;</span>
      }
    case PROD:{
<span class="fc" id="L2242">      d = ProductDomain();</span>
<span class="fc" id="L2243">      break;</span>
      }
    case SEQ:{
<span class="fc" id="L2246">      d = SequenceDomain();</span>
<span class="fc" id="L2247">      break;</span>
      }
    case POWERSET:{
<span class="fc" id="L2250">      d = PowersetDomain();</span>
<span class="fc" id="L2251">      break;</span>
      }
    case BAG:{
<span class="fc" id="L2254">      d = BagDomain();</span>
<span class="fc" id="L2255">      break;</span>
      }
    case MAP:{
<span class="fc" id="L2258">      d = MapDomain();</span>
<span class="fc" id="L2259">      break;</span>
      }
    default:
<span class="nc" id="L2262">      jj_la1[54] = jj_gen;</span>
<span class="nc" id="L2263">      jj_consume_token(-1);</span>
<span class="nc" id="L2264">      throw new ParseException();</span>
    }
<span class="fc" id="L2266">{if (&quot;&quot; != null) return d;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public RuleDomain RuleDomain() throws ParseException {Domain dom;
<span class="fc" id="L2271">    jj_consume_token(RULEDOM);</span>
<span class="fc" id="L2272">List ruleElemList = new LinkedList();</span>
<span class="pc bpc" id="L2273" title="1 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case 115:{
<span class="fc" id="L2275">      jj_consume_token(115);</span>
<span class="fc" id="L2276">      dom = getDomainByID();</span>
<span class="fc" id="L2277">ruleElemList.add(dom);</span>
      label_23:
      while (true) {
<span class="pc bpc" id="L2280" title="1 of 4 branches missed.">        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
        case 116:{
<span class="fc" id="L2282">          break;</span>
          }
        default:
<span class="fc" id="L2285">          jj_la1[55] = jj_gen;</span>
<span class="fc" id="L2286">          break label_23;</span>
        }
<span class="fc" id="L2288">        jj_consume_token(116);</span>
<span class="fc" id="L2289">        dom = getDomainByID();</span>
<span class="fc" id="L2290">ruleElemList.add(dom);</span>
      }
<span class="fc" id="L2292">      jj_consume_token(117);</span>
<span class="fc" id="L2293">      break;</span>
      }
    default:
<span class="fc" id="L2296">      jj_la1[56] = jj_gen;</span>
      ;
    }
<span class="fc" id="L2299">{if (&quot;&quot; != null) return Utility.getRuleDomain(ruleElemList, defPack, header.getSignature());}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public ProductDomain ProductDomain() throws ParseException {Domain dom;
<span class="fc" id="L2304">    jj_consume_token(PROD);</span>
<span class="fc" id="L2305">List prodElemList = new LinkedList();</span>
<span class="fc" id="L2306">    jj_consume_token(115);</span>
<span class="fc" id="L2307">    dom = getDomainByID();</span>
//a StructuredTD can not be defined over a concrete domain  NO LONGER APPLIES!!!
    //if(!(dom instanceof TypeDomain))
    //   {   throw new ParseException(&quot;Error: A StructuredTD domain can not be defined over a concrete domain.&quot;);}
    //add a new element to the Domain list
<span class="fc" id="L2312">    prodElemList.add(dom); //prodElemList.add((TypeDomain)dom);</span>

    label_24:
    while (true) {
<span class="fc" id="L2316">      jj_consume_token(116);</span>
<span class="fc" id="L2317">      dom = getDomainByID();</span>
//a StructuredTD can not be defined over a concrete domain  NO LONGER APPLIES!!!
      //if(!(dom instanceof TypeDomain))
      //   {   throw new ParseException(&quot;Error: A StructuredTD domain can not be defined over a concrete domain.&quot;);}
      //add a new element to the Domain list
<span class="fc" id="L2322">      prodElemList.add(dom); //prodElemList.add((TypeDomain)dom);</span>

<span class="pc bpc" id="L2324" title="1 of 4 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case 116:{
<span class="fc" id="L2326">        break;</span>
        }
      default:
<span class="fc" id="L2329">        jj_la1[57] = jj_gen;</span>
<span class="fc" id="L2330">        break label_24;</span>
      }
    }
<span class="fc" id="L2333">    jj_consume_token(117);</span>
<span class="fc" id="L2334">{if (&quot;&quot; != null) return Utility.getProduct(prodElemList, defPack, header.getSignature());}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

//OK!
  final public SequenceDomain SequenceDomain() throws ParseException {Domain dom;
<span class="fc" id="L2340">    jj_consume_token(SEQ);</span>
<span class="fc" id="L2341">    jj_consume_token(115);</span>
<span class="fc" id="L2342">    dom = getDomainByID();</span>
<span class="fc" id="L2343">    jj_consume_token(117);</span>
//NO LONGER APPLIES!!!
    //a SeqTD can not be defined over a concrete domain
    //if(!(dom instanceof TypeDomain))
    //{   throw new ParseException(&quot;Error: A SequenceTD can not be defined over a concrete domain.&quot;);}
<span class="fc" id="L2348">    {if (&quot;&quot; != null) return Utility.getSequence(dom, defPack, header.getSignature());}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public PowersetDomain PowersetDomain() throws ParseException {Domain dom;
<span class="fc" id="L2353">    jj_consume_token(POWERSET);</span>
<span class="fc" id="L2354">    jj_consume_token(115);</span>
<span class="fc" id="L2355">    dom = getDomainByID();</span>
<span class="fc" id="L2356">    jj_consume_token(117);</span>
//NO LONGER APPLIES!!!
    //a PowerTD can not be defined over a concrete domain
    // if(!(dom instanceof TypeDomain))
    //    {   throw new ParseException(&quot;Error: A PowerTD can not be defined over a concrete domain.&quot;);}
<span class="fc" id="L2361">    {if (&quot;&quot; != null) return Utility.getPowerset(dom, defPack, header.getSignature());}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public BagDomain BagDomain() throws ParseException {Domain dom;
<span class="fc" id="L2366">    jj_consume_token(BAG);</span>
<span class="fc" id="L2367">    jj_consume_token(115);</span>
<span class="fc" id="L2368">    dom = getDomainByID();</span>
<span class="fc" id="L2369">    jj_consume_token(117);</span>
//NO LONGER APPLIES!!!
    //a BagTD can not be defined over a concrete domain
    //if(!(dom instanceof TypeDomain))
    //   {   throw new ParseException(&quot;Error: A BagTD domain can not be defined over a concrete domain.&quot;);}
<span class="fc" id="L2374">    {if (&quot;&quot; != null) return Utility.getBag(dom, defPack, header.getSignature());}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public MapDomain MapDomain() throws ParseException {Domain dom1, dom2;
<span class="fc" id="L2379">    jj_consume_token(MAP);</span>
<span class="fc" id="L2380">    jj_consume_token(115);</span>
<span class="fc" id="L2381">    dom1 = getDomainByID();</span>
<span class="fc" id="L2382">    jj_consume_token(116);</span>
<span class="fc" id="L2383">    dom2 = getDomainByID();</span>
<span class="fc" id="L2384">    jj_consume_token(117);</span>
//NO LONGER APPLIES!!!
    //a MapTD domain can not be defined over a concrete domain
    //if(!(dom1 instanceof TypeDomain)||!(dom2 instanceof TypeDomain))
    //    {   throw new ParseException(&quot;Error: A MapTD domain can not be defined over a concrete domain.&quot;);}
<span class="fc" id="L2389">    {if (&quot;&quot; != null) return Utility.getMap(dom1, dom2, defPack, header.getSignature());}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

//------------------------------------------------------------//
  final public Domain getDomainByID() throws ParseException {String domName;
  Domain domain;
<span class="pc bpc" id="L2396" title="1 of 5 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case ID_DOMAIN:{
<span class="fc" id="L2398">      domName = ID_DOMAIN();</span>
<span class="fc" id="L2399">domain = declared_Dom.get(domName);</span>
<span class="fc bfc" id="L2400" title="All 2 branches covered.">      if (domain == null) domain = Utility.getPredefinedDomain(domainsFactory, domName);</span>
<span class="pc bpc" id="L2401" title="1 of 2 branches missed.">      if (domain == null) throw new ParseException(&quot;Error: &quot; + domName + &quot; domain is not declared.&quot;);</span>
      break;
      }
    case PROD:
    case SEQ:
    case POWERSET:
    case BAG:
    case MAP:
    case RULEDOM:{
<span class="fc" id="L2410">      domain = StructuredTD();</span>
<span class="fc" id="L2411">      break;</span>
      }
    default:
<span class="nc" id="L2414">      jj_la1[58] = jj_gen;</span>
<span class="nc" id="L2415">      jj_consume_token(-1);</span>
<span class="nc" id="L2416">      throw new ParseException();</span>
    }
<span class="fc" id="L2418">{if (&quot;&quot; != null) return domain;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

//------------------------------------------------------------//
/*-----------------------------------------------------------*/
/**********************   FUNCTIONS   OK! ************************/
/*-----------------------------------------------------------*/
  final public Function Function() throws ParseException {Function func;
<span class="pc bpc" id="L2427" title="1 of 5 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case STATIC:
    case DYNAMIC:
    case MONITORED:
    case CONTROLLED:
    case SHARED:
    case OUT:
    case LOCAL:{
<span class="fc" id="L2435">      func = BasicFunction();</span>
<span class="fc" id="L2436">      break;</span>
      }
    case DERIVED:{
<span class="fc" id="L2439">      func = DerivedFunction();</span>
<span class="fc" id="L2440">      break;</span>
      }
    default:
<span class="nc" id="L2443">      jj_la1[59] = jj_gen;</span>
<span class="nc" id="L2444">      jj_consume_token(-1);</span>
<span class="nc" id="L2445">      throw new ParseException();</span>
    }
<span class="fc" id="L2447">{if (&quot;&quot; != null) return func;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public BasicFunction BasicFunction() throws ParseException {BasicFunction func;
<span class="pc bpc" id="L2452" title="2 of 5 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case STATIC:{
<span class="fc" id="L2454">      func = StaticFunction();</span>
<span class="fc" id="L2455">      break;</span>
      }
    case DYNAMIC:
    case MONITORED:
    case CONTROLLED:
    case SHARED:
    case OUT:
    case LOCAL:{
<span class="fc" id="L2463">      func = DynamicFunction();</span>
<span class="fc" id="L2464">      break;</span>
      }
    default:
<span class="nc" id="L2467">      jj_la1[60] = jj_gen;</span>
<span class="nc" id="L2468">      jj_consume_token(-1);</span>
<span class="nc" id="L2469">      throw new ParseException();</span>
    }
<span class="fc" id="L2471">{if (&quot;&quot; != null) return func;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public DerivedFunction DerivedFunction() throws ParseException {String funcName;
<span class="fc" id="L2476">  Domain dom = null;</span>
  Domain cod;
<span class="fc" id="L2478">    jj_consume_token(DERIVED);</span>
<span class="fc" id="L2479">    funcName = ID_FUNCTION();</span>
<span class="fc" id="L2480">    jj_consume_token(118);</span>
<span class="fc" id="L2481">DerivedFunction func = defPack.createDerivedFunction();</span>
<span class="fc" id="L2482">    func.setName(funcName);</span>
<span class="fc bfc" id="L2483" title="All 2 branches covered.">    if (jj_2_6(2147483647)) {</span>
<span class="fc" id="L2484">      dom = getDomainByID();</span>
<span class="fc" id="L2485">      jj_consume_token(122);</span>
<span class="fc" id="L2486">func.setDomain(dom);</span>
    } else {
      ;
    }
<span class="fc" id="L2490">    cod = getDomainByID();</span>
<span class="fc" id="L2491">func.setCodomain(cod);</span>
    //create the association
    //XX AFunctionCodomain AFuncCod =  defPack.getAFunctionCodomain();
    //XX AFuncCod.add(func,cod);
<span class="fc" id="L2495">    int arity = OCL_Checker.evalArity(func);</span>
<span class="fc" id="L2496">    func.setArity(arity);</span>
<span class="fc bfc" id="L2497" title="All 2 branches covered.">    Logger.logDebug(&quot;derived function &quot; + funcName + &quot;:&quot; + ((dom != null) ? (dom.getName() + &quot;-&gt;&quot;) : &quot;&quot;) + cod.getName() + &quot;\t arity = &quot; + arity);</span>
<span class="fc" id="L2498">    {if (&quot;&quot; != null) return func;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public StaticFunction StaticFunction() throws ParseException {String funcName;
<span class="fc" id="L2503">  Domain dom = null;</span>
  Domain cod;
<span class="fc" id="L2505">StaticFunction func = defPack.createStaticFunction();</span>
<span class="fc" id="L2506">    jj_consume_token(STATIC);</span>
<span class="fc" id="L2507">    funcName = ID_FUNCTION();</span>
<span class="fc" id="L2508">    jj_consume_token(118);</span>
<span class="fc" id="L2509">func.setName(funcName);</span>
<span class="fc bfc" id="L2510" title="All 2 branches covered.">    if (jj_2_7(2147483647)) {</span>
<span class="fc" id="L2511">      dom = getDomainByID();</span>
<span class="fc" id="L2512">      jj_consume_token(122);</span>
<span class="fc" id="L2513">func.setDomain(dom);</span>
    } else {
      ;
    }
<span class="fc" id="L2517">    cod = getDomainByID();</span>
<span class="fc" id="L2518">func.setCodomain(cod);</span>
<span class="fc" id="L2519">    int arity = OCL_Checker.evalArity(func);</span>
<span class="fc" id="L2520">    func.setArity(arity);</span>
<span class="fc bfc" id="L2521" title="All 2 branches covered.">    Logger.logDebug(&quot;static function &quot; + funcName + &quot;:&quot; + ((dom != null) ? (dom.getName() + &quot;-&gt;&quot;) : &quot;&quot;) + cod.getName() + &quot;\t arity = &quot; + arity);</span>
<span class="fc" id="L2522">    {if (&quot;&quot; != null) return func;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

//OK!
  final public DynamicFunction DynamicFunction() throws ParseException {DynamicFunction result;
<span class="fc bfc" id="L2528" title="All 2 branches covered.">    if (jj_2_8(2)) {</span>
<span class="fc" id="L2529">      result = OutFunction();</span>
<span class="fc bfc" id="L2530" title="All 2 branches covered.">    } else if (jj_2_9(2)) {</span>
<span class="fc" id="L2531">      result = MonitoredFunction();</span>
<span class="fc bfc" id="L2532" title="All 2 branches covered.">    } else if (jj_2_10(2)) {</span>
<span class="fc" id="L2533">      result = SharedFunction();</span>
<span class="pc bpc" id="L2534" title="1 of 2 branches missed.">    } else if (jj_2_11(2)) {</span>
<span class="fc" id="L2535">      result = ControlledFunction();</span>
    } else {
<span class="nc bnc" id="L2537" title="All 4 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case DYNAMIC:
      case LOCAL:{
<span class="nc" id="L2540">        result = LocalFunction();</span>
<span class="nc" id="L2541">        break;</span>
        }
      default:
<span class="nc" id="L2544">        jj_la1[61] = jj_gen;</span>
<span class="nc" id="L2545">        jj_consume_token(-1);</span>
<span class="nc" id="L2546">        throw new ParseException();</span>
      }
    }
<span class="fc" id="L2549">{if (&quot;&quot; != null) return result;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public LocalFunction LocalFunction() throws ParseException {String funcName;
<span class="fc" id="L2554">  Domain dom = null;</span>
  Domain cod;
<span class="fc" id="L2556">LocalFunction func = defPack.createLocalFunction();</span>
<span class="pc bpc" id="L2557" title="2 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case DYNAMIC:{
<span class="nc" id="L2559">      jj_consume_token(DYNAMIC);</span>
<span class="nc" id="L2560">      break;</span>
      }
    default:
<span class="fc" id="L2563">      jj_la1[62] = jj_gen;</span>
      ;
    }
<span class="fc" id="L2566">    jj_consume_token(LOCAL);</span>
<span class="fc" id="L2567">    funcName = ID_FUNCTION();</span>
<span class="fc" id="L2568">    jj_consume_token(118);</span>
<span class="fc" id="L2569">func.setName(funcName);</span>
<span class="pc bpc" id="L2570" title="1 of 2 branches missed.">    if (jj_2_12(2147483647)) {</span>
<span class="nc" id="L2571">      dom = getDomainByID();</span>
<span class="nc" id="L2572">      jj_consume_token(122);</span>
<span class="nc" id="L2573">func.setDomain(dom);</span>
      //create the association
      //XX AFunctionDomain AFuncDom =  defPack.getAFunctionDomain();
      //XX AFuncDom.add(func,dom);

    } else {
      ;
    }
<span class="fc" id="L2581">    cod = getDomainByID();</span>
<span class="fc" id="L2582">func.setCodomain(cod);</span>
    //create the association
    //XX AFunctionCodomain AFuncCod =  defPack.getAFunctionCodomain();
    //XX AFuncCod.add(func,cod);
<span class="fc" id="L2586">    int arity = OCL_Checker.evalArity(func);</span>
<span class="fc" id="L2587">    func.setArity(arity);</span>
<span class="pc bpc" id="L2588" title="1 of 2 branches missed.">    Logger.logDebug(&quot;local function &quot; + funcName + &quot;:&quot; + ((dom != null) ? (dom.getName() + &quot;-&gt;&quot;) : &quot;&quot;) + cod.getName() + &quot;\t arity = &quot; + arity);</span>
<span class="fc" id="L2589">    {if (&quot;&quot; != null) return func;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public ControlledFunction ControlledFunction() throws ParseException {String funcName;
<span class="fc" id="L2594">  Domain dom = null;</span>
  Domain cod;
<span class="fc" id="L2596">ControlledFunction func = defPack.createControlledFunction();</span>
<span class="pc bpc" id="L2597" title="1 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case DYNAMIC:{
<span class="fc" id="L2599">      jj_consume_token(DYNAMIC);</span>
<span class="fc" id="L2600">      break;</span>
      }
    default:
<span class="fc" id="L2603">      jj_la1[63] = jj_gen;</span>
      ;
    }
<span class="fc" id="L2606">    jj_consume_token(CONTROLLED);</span>
<span class="fc" id="L2607">    funcName = ID_FUNCTION();</span>
<span class="fc" id="L2608">    jj_consume_token(118);</span>
<span class="fc" id="L2609">func.setName(funcName);</span>
<span class="fc bfc" id="L2610" title="All 2 branches covered.">    if (jj_2_13(2147483647)) {</span>
<span class="fc" id="L2611">      dom = getDomainByID();</span>
<span class="fc" id="L2612">      jj_consume_token(122);</span>
<span class="fc" id="L2613">func.setDomain(dom);</span>
      //create the association
      //XX  AFunctionDomain AFuncDom =  defPack.getAFunctionDomain();
      //XX AFuncDom.add(func,dom);

    } else {
      ;
    }
<span class="fc" id="L2621">    cod = getDomainByID();</span>
<span class="fc" id="L2622">func.setCodomain(cod);</span>
    //create the association
    //XX  AFunctionCodomain AFuncCod =  defPack.getAFunctionCodomain();
    //XX AFuncCod.add(func,cod);
<span class="fc" id="L2626">    int arity = OCL_Checker.evalArity(func);</span>
<span class="fc" id="L2627">    func.setArity(arity);</span>
<span class="fc bfc" id="L2628" title="All 2 branches covered.">    Logger.logDebug(&quot;controlled function &quot; + funcName + &quot;:&quot; + ((dom != null) ? (dom.getName() + &quot;-&gt;&quot;) : &quot;&quot;) + cod.getName() + &quot;\t arity = &quot; + arity);</span>
<span class="fc" id="L2629">    {if (&quot;&quot; != null) return func;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public SharedFunction SharedFunction() throws ParseException {String funcName;
<span class="fc" id="L2634">  Domain dom = null;</span>
  Domain cod;
<span class="fc" id="L2636">SharedFunction func = defPack.createSharedFunction();</span>
<span class="pc bpc" id="L2637" title="2 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case DYNAMIC:{
<span class="fc" id="L2639">      jj_consume_token(DYNAMIC);</span>
<span class="fc" id="L2640">      break;</span>
      }
    default:
<span class="nc" id="L2643">      jj_la1[64] = jj_gen;</span>
      ;
    }
<span class="fc" id="L2646">    jj_consume_token(SHARED);</span>
<span class="fc" id="L2647">    funcName = ID_FUNCTION();</span>
<span class="fc" id="L2648">    jj_consume_token(118);</span>
<span class="fc" id="L2649">func.setName(funcName);</span>
<span class="fc bfc" id="L2650" title="All 2 branches covered.">    if (jj_2_14(2147483647)) {</span>
<span class="fc" id="L2651">      dom = getDomainByID();</span>
<span class="fc" id="L2652">      jj_consume_token(122);</span>
<span class="fc" id="L2653">func.setDomain(dom);</span>
      //create the association
      //XX AFunctionDomain AFuncDom =  defPack.getAFunctionDomain();
      //XX AFuncDom.add(func,dom);

    } else {
      ;
    }
<span class="fc" id="L2661">    cod = getDomainByID();</span>
<span class="fc" id="L2662">func.setCodomain(cod);</span>
    //create the association
    //XX AFunctionCodomain AFuncCod =  defPack.getAFunctionCodomain();
    //XX AFuncCod.add(func,cod);
<span class="fc" id="L2666">    int arity = OCL_Checker.evalArity(func);</span>
<span class="fc" id="L2667">    func.setArity(arity);</span>
<span class="fc bfc" id="L2668" title="All 2 branches covered.">    Logger.logDebug(&quot;shared function &quot; + funcName + &quot;:&quot; + ((dom != null) ? (dom.getName() + &quot;-&gt;&quot;) : &quot;&quot;) + cod.getName() + &quot;\t arity = &quot; + arity);</span>
<span class="fc" id="L2669">    {if (&quot;&quot; != null) return func;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public MonitoredFunction MonitoredFunction() throws ParseException {String funcName;
<span class="fc" id="L2674">  Domain dom = null;</span>
  Domain cod;
<span class="fc" id="L2676">MonitoredFunction func = defPack.createMonitoredFunction();</span>
<span class="pc bpc" id="L2677" title="1 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case DYNAMIC:{
<span class="fc" id="L2679">      jj_consume_token(DYNAMIC);</span>
<span class="fc" id="L2680">      break;</span>
      }
    default:
<span class="fc" id="L2683">      jj_la1[65] = jj_gen;</span>
      ;
    }
<span class="fc" id="L2686">    jj_consume_token(MONITORED);</span>
<span class="fc" id="L2687">    funcName = ID_FUNCTION();</span>
<span class="fc" id="L2688">    jj_consume_token(118);</span>
<span class="fc" id="L2689">func.setName(funcName);</span>
<span class="fc bfc" id="L2690" title="All 2 branches covered.">    if (jj_2_15(2147483647)) {</span>
<span class="fc" id="L2691">      dom = getDomainByID();</span>
<span class="fc" id="L2692">      jj_consume_token(122);</span>
<span class="fc" id="L2693">func.setDomain(dom);</span>
      //create the association
      //XX AFunctionDomain AFuncDom =  defPack.getAFunctionDomain();
      //XX  AFuncDom.add(func,dom);

    } else {
      ;
    }
<span class="fc" id="L2701">    cod = getDomainByID();</span>
<span class="fc" id="L2702">func.setCodomain(cod);</span>
    //create the association
    //XX AFunctionCodomain AFuncCod =  defPack.getAFunctionCodomain();
    //XX AFuncCod.add(func,cod);
<span class="fc" id="L2706">    int arity = OCL_Checker.evalArity(func);</span>
<span class="fc" id="L2707">    func.setArity(arity);</span>
<span class="fc bfc" id="L2708" title="All 2 branches covered.">    Logger.logDebug(&quot;monitored function &quot; + funcName + &quot;:&quot; + ((dom != null) ? (dom.getName() + &quot;-&gt;&quot;) : &quot;&quot;) + cod.getName() + &quot;\t arity = &quot; + arity);</span>
<span class="fc" id="L2709">    {if (&quot;&quot; != null) return func;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public OutFunction OutFunction() throws ParseException {String funcName;
<span class="fc" id="L2714">  Domain dom = null;</span>
  Domain cod;
<span class="fc" id="L2716">OutFunction func = defPack.createOutFunction();</span>
<span class="pc bpc" id="L2717" title="1 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case DYNAMIC:{
<span class="fc" id="L2719">      jj_consume_token(DYNAMIC);</span>
<span class="fc" id="L2720">      break;</span>
      }
    default:
<span class="fc" id="L2723">      jj_la1[66] = jj_gen;</span>
      ;
    }
<span class="fc" id="L2726">    jj_consume_token(OUT);</span>
<span class="fc" id="L2727">    funcName = ID_FUNCTION();</span>
<span class="fc" id="L2728">    jj_consume_token(118);</span>
<span class="fc" id="L2729">func.setName(funcName);</span>
<span class="fc bfc" id="L2730" title="All 2 branches covered.">    if (jj_2_16(2147483647)) {</span>
<span class="fc" id="L2731">      dom = getDomainByID();</span>
<span class="fc" id="L2732">      jj_consume_token(122);</span>
<span class="fc" id="L2733">func.setDomain(dom);</span>
      //create the association
      //XX  AFunctionDomain AFuncDom =  defPack.getAFunctionDomain();
      //XX AFuncDom.add(func,dom);

    } else {
      ;
    }
<span class="fc" id="L2741">    cod = getDomainByID();</span>
<span class="fc" id="L2742">func.setCodomain(cod);</span>
    //create the association
    //XX AFunctionCodomain AFuncCod =  defPack.getAFunctionCodomain();
    //XX AFuncCod.add(func,cod);
<span class="fc" id="L2746">    int arity = OCL_Checker.evalArity(func);</span>
<span class="fc" id="L2747">    func.setArity(arity);</span>
<span class="fc bfc" id="L2748" title="All 2 branches covered.">    Logger.logDebug(&quot;out function &quot; + funcName + &quot;:&quot; + ((dom != null) ? (dom.getName() + &quot;-&gt;&quot;) : &quot;&quot;) + cod.getName() + &quot;\t arity = &quot; + arity);</span>
<span class="fc" id="L2749">    {if (&quot;&quot; != null) return func;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

/*-----------------------------------------------------------*/
/************************   TERMs    ***************************/
/*-----------------------------------------------------------*/
  final public Term Term(HashMap localVar, boolean areAllowedNewVar, RuleDeclaration c) throws ParseException {Term t;
<span class="fc" id="L2757">    t = TermForUpdateRule(localVar, areAllowedNewVar, c, null);</span>
<span class="fc" id="L2758">{if (&quot;&quot; != null) return t;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public Term TermForUpdateRule(HashMap localVar, boolean areAllowedNewVar, RuleDeclaration c, Domain expDom) throws ParseException {Term t;
<span class="fc bfc" id="L2763" title="All 2 branches covered.">    if (jj_2_17(2147483647)) {</span>
<span class="fc" id="L2764">      t = Expression(localVar, areAllowedNewVar);</span>
    } else {
<span class="pc bpc" id="L2766" title="1 of 4 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case PROD:
      case SEQ:
      case POWERSET:
      case BAG:
      case MAP:
      case RULEDOM:
      case IF:
      case SWITCH:
      case LET:
      case LT:
      case ID_DOMAIN:
      case 115:
      case 119:
      case 124:
      case 126:{
<span class="fc" id="L2782">        t = ExtendedTerm(localVar, areAllowedNewVar, c, expDom);</span>
<span class="fc" id="L2783">        break;</span>
        }
      default:
<span class="nc" id="L2786">        jj_la1[67] = jj_gen;</span>
<span class="nc" id="L2787">        jj_consume_token(-1);</span>
<span class="nc" id="L2788">        throw new ParseException();</span>
      }
    }
<span class="fc" id="L2791">{if (&quot;&quot; != null) return t;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*    Expression   */
//IMPLIES
  final public Term Expression(HashMap localVar, boolean areAllowedNewVar) throws ParseException {Term t, arg1, arg2;
  Token tok;
<span class="fc" id="L2800">    t = or_xorLogicExpr(localVar, areAllowedNewVar);</span>
    label_25:
    while (true) {
<span class="fc bfc" id="L2803" title="All 2 branches covered.">      if (jj_2_18(1)) {</span>
      } else {
        break label_25;
      }
<span class="pc bpc" id="L2807" title="1 of 4 branches missed.">      if (getToken(1).kind == ID_FUNCTION &amp;&amp; getToken(1).image.equals(&quot;implies&quot;)) {</span>
<span class="fc" id="L2808">        tok = jj_consume_token(ID_FUNCTION);</span>
<span class="fc" id="L2809">Logger.logDebug(&quot;\timplies\t\toperator&quot;);</span>
<span class="fc" id="L2810">        arg2 = or_xorLogicExpr(localVar, areAllowedNewVar);</span>
<span class="pc bpc" id="L2811" title="2 of 4 branches missed.">      } else if (getToken(1).kind == ID_FUNCTION &amp;&amp; getToken(1).image.equals(&quot;iff&quot;)) {</span>
<span class="fc" id="L2812">        tok = jj_consume_token(ID_FUNCTION);</span>
<span class="fc" id="L2813">Logger.logDebug(&quot;\tiff\t\toperator&quot;);</span>
<span class="fc" id="L2814">        arg2 = or_xorLogicExpr(localVar, areAllowedNewVar);</span>
      } else {
<span class="nc" id="L2816">        jj_consume_token(-1);</span>
<span class="nc" id="L2817">        throw new ParseException();</span>
      }
<span class="fc" id="L2819">arg1 = t;</span>
<span class="fc" id="L2820">      String funcName = Utility.getFunctionName(tok.image);</span>
<span class="fc" id="L2821">      TupleTerm tupleT = Utility.createPair(arg1, arg2, termsPack, defPack, header.getSignature());</span>
      //assert tupleT.getTerms().size() == tupleT.getArity();
<span class="pc bpc" id="L2823" title="1 of 2 branches missed.">      if ((t = Utility.createFunctionTerm(funcName, tupleT, termsPack, declared_Func, declared_Dom, defPack, header.getSignature())) == null) throw new ParseException(&quot;&quot;);</span>
<span class="fc" id="L2824">    }</span>
<span class="fc" id="L2825">{if (&quot;&quot; != null) return t;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

// OR  //XOR
  final public Term or_xorLogicExpr(HashMap localVar, boolean areAllowedNewVar) throws ParseException {Term arg1, arg2;
  Token op;
<span class="fc" id="L2832">    arg1 = andLogicExpr(localVar, areAllowedNewVar);</span>
    label_26:
    while (true) {
<span class="fc bfc" id="L2835" title="All 2 branches covered.">      if (jj_2_19(1)) {</span>
      } else {
        break label_26;
      }
<span class="pc bpc" id="L2839" title="1 of 4 branches missed.">      if (getToken(1).kind == ID_FUNCTION &amp;&amp; getToken(1).image.equals(&quot;or&quot;)) {</span>
<span class="fc" id="L2840">        op = jj_consume_token(ID_FUNCTION);</span>
<span class="fc" id="L2841">Logger.logDebug(&quot;\tor\t\toperator&quot;);</span>
<span class="pc bpc" id="L2842" title="2 of 4 branches missed.">      } else if (getToken(1).kind == ID_FUNCTION &amp;&amp; getToken(1).image.equals(&quot;xor&quot;)) {</span>
<span class="fc" id="L2843">        op = jj_consume_token(ID_FUNCTION);</span>
<span class="fc" id="L2844">Logger.logDebug(&quot;\txor\t\toperator&quot;);</span>
      } else {
<span class="nc" id="L2846">        jj_consume_token(-1);</span>
<span class="nc" id="L2847">        throw new ParseException();</span>
      }
<span class="fc" id="L2849">      arg2 = andLogicExpr(localVar, areAllowedNewVar);</span>
<span class="fc" id="L2850">String funcName = Utility.getFunctionName(op.image);</span>
<span class="fc" id="L2851">      TupleTerm tupleT = Utility.createPair(arg1, arg2, termsPack, defPack, header.getSignature());</span>
      //assert tupleT.getTerms().size() == tupleT.getArity();
<span class="fc" id="L2853">      arg1 = Utility.createFunctionTerm(funcName, tupleT, termsPack, declared_Func, declared_Dom, defPack, header.getSignature());</span>
<span class="pc bpc" id="L2854" title="1 of 2 branches missed.">      if (arg1 == null) throw new ParseException(&quot;&quot;);</span>
<span class="fc" id="L2855">    }</span>
<span class="fc" id="L2856">{if (&quot;&quot; != null) return arg1;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

// AND
  final public Term andLogicExpr(HashMap localVar, boolean areAllowedNewVar) throws ParseException {Term t, arg1, arg2;
  Token tok;
<span class="fc" id="L2863">    t = relationalExpr(localVar, areAllowedNewVar);</span>
    label_27:
    while (true) {
<span class="fc bfc" id="L2866" title="All 4 branches covered.">      if (getToken(1).kind == ID_FUNCTION &amp;&amp; getToken(1).image.equals(&quot;and&quot;)) {</span>
      } else {
        break label_27;
      }
<span class="fc" id="L2870">      tok = jj_consume_token(ID_FUNCTION);</span>
<span class="fc" id="L2871">Logger.logDebug(&quot;\tand\t\toperator&quot;);</span>
<span class="fc" id="L2872">      arg2 = relationalExpr(localVar, areAllowedNewVar);</span>
<span class="fc" id="L2873">arg1 = t;</span>
<span class="fc" id="L2874">      String funcName = Utility.getFunctionName(tok.image);</span>
<span class="fc" id="L2875">      TupleTerm tupleT = Utility.createPair(arg1, arg2, termsPack, defPack, header.getSignature());</span>
      //assert tupleT.getTerms().size() == tupleT.getArity();
<span class="pc bpc" id="L2877" title="1 of 2 branches missed.">      if ((t = Utility.createFunctionTerm(funcName, tupleT, termsPack, declared_Func, declared_Dom, defPack, header.getSignature())) == null) throw new ParseException(&quot;&quot;);</span>
<span class="fc" id="L2878">    }</span>
<span class="fc" id="L2879">{if (&quot;&quot; != null) return t;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

/* NEVER USED
// in e !in (appartenenza)
Term includesExpr(HashMap localVar, boolean areAllowedNewVar) :
{
  Term t, arg1, arg2;
  Token tok;
}
{
  t = relationalExpr(localVar, areAllowedNewVar)
  (
    (
      LOOKAHEAD({ getToken(1).kind == ID_FUNCTION &amp;&amp; getToken(1).image.equals(&quot;in&quot;) })
      tok = &lt; ID_FUNCTION &gt;
      {
        Logger.logDebug(&quot;\tin\t\toperator&quot;);
      }
      arg2 = relationalExpr(localVar, areAllowedNewVar)
    | LOOKAHEAD({ getToken(1).kind == ID_FUNCTION &amp;&amp; getToken(1).image.equals(&quot;notin&quot;) })
      tok = &lt; ID_FUNCTION &gt;
      {
        Logger.logDebug(&quot;\tnotin\t\toperator&quot;);
      }
      arg2 = relationalExpr(localVar, areAllowedNewVar)
    )
    {
      arg1 = t;
      String funcName = Utility.getFunctionName(tok.image);
      TupleTerm tupleT = Utility.createPair(arg1, arg2, termsPack, defPack, header.getSignature());
      //assert tupleT.getTerms().size() == tupleT.getArity();
      if ((t = Utility.createFunctionTerm(funcName, tupleT, termsPack, declared_Func, declared_Dom, defPack, header.getSignature())) == null) throw new ParseException(&quot;&quot;);
    }
  )?
  {
    return t;
  }
}*/

// == != &gt; &gt;= &lt; &lt;=
  final public Term relationalExpr(HashMap localVar, boolean areAllowedNewVar) throws ParseException {Term t, arg1, arg2;
  Token tok;
<span class="fc" id="L2923">    t = notLogicExpr(localVar, areAllowedNewVar);</span>
    label_28:
    while (true) {
<span class="fc bfc" id="L2926" title="All 2 branches covered.">      if (jj_2_20(2)) {</span>
      } else {
        break label_28;
      }
<span class="pc bpc" id="L2930" title="2 of 9 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case EQ:{
<span class="fc" id="L2932">        tok = jj_consume_token(EQ);</span>
<span class="fc" id="L2933">Logger.logDebug(&quot;\t=\t\toperator&quot;);</span>
<span class="fc" id="L2934">        arg2 = notLogicExpr(localVar, areAllowedNewVar);</span>
<span class="fc" id="L2935">        break;</span>
        }
      case NEQ:{
<span class="fc" id="L2938">        tok = jj_consume_token(NEQ);</span>
<span class="fc" id="L2939">Logger.logDebug(&quot;\t!=\t\toperator&quot;);</span>
<span class="fc" id="L2940">        arg2 = notLogicExpr(localVar, areAllowedNewVar);</span>
<span class="fc" id="L2941">        break;</span>
        }
      case LT:{
<span class="fc" id="L2944">        tok = jj_consume_token(LT);</span>
<span class="fc" id="L2945">Logger.logDebug(&quot;\t&lt;\t\toperator&quot;);</span>
<span class="fc" id="L2946">        arg2 = notLogicExpr(localVar, areAllowedNewVar);</span>
<span class="fc" id="L2947">        break;</span>
        }
      case LE:{
<span class="fc" id="L2950">        tok = jj_consume_token(LE);</span>
<span class="fc" id="L2951">Logger.logDebug(&quot;\t&lt;=\t\toperator&quot;);</span>
<span class="fc" id="L2952">        arg2 = notLogicExpr(localVar, areAllowedNewVar);</span>
<span class="fc" id="L2953">        break;</span>
        }
      case GT:{
<span class="fc" id="L2956">        tok = jj_consume_token(GT);</span>
<span class="fc" id="L2957">Logger.logDebug(&quot;\t&gt;\t\toperator&quot;);</span>
<span class="fc" id="L2958">        arg2 = notLogicExpr(localVar, areAllowedNewVar);</span>
<span class="fc" id="L2959">        break;</span>
        }
      case GE:{
<span class="fc" id="L2962">        tok = jj_consume_token(GE);</span>
<span class="fc" id="L2963">Logger.logDebug(&quot;\t&gt;=\t\toperator&quot;);</span>
<span class="fc" id="L2964">        arg2 = notLogicExpr(localVar, areAllowedNewVar);</span>
<span class="fc" id="L2965">        break;</span>
        }
      default:
<span class="nc" id="L2968">        jj_la1[68] = jj_gen;</span>
<span class="nc" id="L2969">        jj_consume_token(-1);</span>
<span class="nc" id="L2970">        throw new ParseException();</span>
      }
<span class="fc" id="L2972">arg1 = t;</span>
<span class="fc" id="L2973">      String funcName = Utility.getFunctionName(tok.image);</span>
<span class="fc" id="L2974">      TupleTerm tupleT = Utility.createPair(arg1, arg2, termsPack, defPack, header.getSignature());</span>
      //assert tupleT.getTerms().size() == tupleT.getArity();
<span class="pc bpc" id="L2976" title="1 of 2 branches missed.">      if ((t = Utility.createFunctionTerm(funcName, tupleT, termsPack, declared_Func, declared_Dom, defPack, header.getSignature())) == null) throw new ParseException(&quot;&quot;);</span>
<span class="fc" id="L2977">    }</span>
<span class="fc" id="L2978">{if (&quot;&quot; != null) return t;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

// NOT
  final public Term notLogicExpr(HashMap localVar, boolean areAllowedNewVar) throws ParseException {Term t, arg;
  Token op;
<span class="fc bfc" id="L2985" title="All 4 branches covered.">    if (getToken(1).kind == ID_FUNCTION &amp;&amp; getToken(1).image.equals(&quot;not&quot;)) {</span>
<span class="fc" id="L2986">      op = jj_consume_token(ID_FUNCTION);</span>
<span class="fc" id="L2987">Logger.logDebug(&quot;\tnot\t\toperator&quot;);</span>
<span class="fc" id="L2988">      arg = additiveExpr(localVar, areAllowedNewVar);</span>
<span class="fc" id="L2989">String funcName = Utility.getFunctionName(op.image);</span>
<span class="fc" id="L2990">      TupleTerm tupleT = Utility.createSingle(arg, termsPack, defPack, header.getSignature());</span>
      //assert tupleT.getTerms().size() == tupleT.getArity();
<span class="pc bpc" id="L2992" title="1 of 2 branches missed.">      if ((t = Utility.createFunctionTerm(funcName, tupleT, termsPack, declared_Func, declared_Dom, defPack, header.getSignature())) == null) throw new ParseException(&quot;&quot;);</span>
<span class="fc" id="L2993">    } else {</span>
<span class="pc bpc" id="L2994" title="1 of 4 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case PROD:
      case SEQ:
      case POWERSET:
      case BAG:
      case MAP:
      case RULEDOM:
      case TRUE:
      case FALSE:
      case UNDEF:
      case PLUS:
      case MINUS:
      case NUMBER:
      case NATNUMBER:
      case REAL_NUMBER:
      case COMPLEX_NUMBER:
      case ID_VARIABLE:
      case ID_ENUM:
      case ID_DOMAIN:
      case ID_FUNCTION:
      case CHAR_LITERAL:
      case STRING_LITERAL:
      case 115:{
<span class="fc" id="L3017">        t = additiveExpr(localVar, areAllowedNewVar);</span>
<span class="fc" id="L3018">        break;</span>
        }
      default:
<span class="nc" id="L3021">        jj_la1[69] = jj_gen;</span>
<span class="nc" id="L3022">        jj_consume_token(-1);</span>
<span class="nc" id="L3023">        throw new ParseException();</span>
      }
    }
<span class="fc" id="L3026">{if (&quot;&quot; != null) return t;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

//
// a +b
//
  final public Term additiveExpr(HashMap localVar, boolean areAllowedNewVar) throws ParseException {Term t, arg1, arg2;
  Token tok;
<span class="fc" id="L3035">    t = multiplicativeExpr(localVar, areAllowedNewVar);</span>
    label_29:
    while (true) {
<span class="pc bpc" id="L3038" title="1 of 4 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case PLUS:
      case MINUS:{
<span class="fc" id="L3041">        break;</span>
        }
      default:
<span class="fc" id="L3044">        jj_la1[70] = jj_gen;</span>
<span class="fc" id="L3045">        break label_29;</span>
      }
<span class="fc bfc" id="L3047" title="All 2 branches covered.">      if (jj_2_21(2)) {</span>
<span class="fc" id="L3048">        tok = jj_consume_token(PLUS);</span>
<span class="fc" id="L3049">Logger.logDebug(&quot;\t+\t\toperator&quot;);</span>
<span class="fc" id="L3050">        arg2 = multiplicativeExpr(localVar, areAllowedNewVar);</span>
      } else {
<span class="pc bpc" id="L3052" title="2 of 4 branches missed.">        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
        case MINUS:{
<span class="fc" id="L3054">          tok = jj_consume_token(MINUS);</span>
<span class="fc" id="L3055">Logger.logDebug(&quot;\t-\t\toperator&quot;);</span>
<span class="fc" id="L3056">          arg2 = multiplicativeExpr(localVar, areAllowedNewVar);</span>
<span class="fc" id="L3057">          break;</span>
          }
        default:
<span class="nc" id="L3060">          jj_la1[71] = jj_gen;</span>
<span class="nc" id="L3061">          jj_consume_token(-1);</span>
<span class="nc" id="L3062">          throw new ParseException();</span>
        }
      }
<span class="fc" id="L3065">arg1 = t;</span>
<span class="fc" id="L3066">      String funcName = Utility.getFunctionName(tok.image);</span>
<span class="fc" id="L3067">      TupleTerm tupleT = Utility.createPair(arg1, arg2, termsPack, defPack, header.getSignature());</span>
      //assert tupleT.getTerms().size() == tupleT.getArity();
<span class="pc bpc" id="L3069" title="1 of 2 branches missed.">      if ((t = Utility.createFunctionTerm(funcName, tupleT, termsPack, declared_Func, declared_Dom, defPack, header.getSignature())) == null) throw new ParseException(&quot;&quot;);</span>
<span class="fc" id="L3070">    }</span>
<span class="fc" id="L3071">{if (&quot;&quot; != null) return t;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public Term multiplicativeExpr(HashMap localVar, boolean areAllowedNewVar) throws ParseException {Term t, arg1, arg2;
  Token tok;
<span class="fc" id="L3077">    t = powerExpr(localVar, areAllowedNewVar);</span>
    label_30:
    while (true) {
<span class="fc bfc" id="L3080" title="All 2 branches covered.">      if (jj_2_22(1)) {</span>
      } else {
        break label_30;
      }
<span class="pc bpc" id="L3084" title="1 of 5 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case MULT:{
<span class="fc" id="L3086">        tok = jj_consume_token(MULT);</span>
<span class="fc" id="L3087">Logger.logDebug(&quot;\t*\t\toperator&quot;);</span>
<span class="fc" id="L3088">        arg2 = powerExpr(localVar, areAllowedNewVar);</span>
<span class="fc" id="L3089">        break;</span>
        }
      case DIV:{
<span class="fc" id="L3092">        tok = jj_consume_token(DIV);</span>
<span class="fc" id="L3093">Logger.logDebug(&quot;\t/\t\toperator&quot;);</span>
<span class="fc" id="L3094">        arg2 = powerExpr(localVar, areAllowedNewVar);</span>
<span class="fc" id="L3095">        break;</span>
        }
      default:
<span class="fc" id="L3098">        jj_la1[72] = jj_gen;</span>
<span class="pc bpc" id="L3099" title="2 of 4 branches missed.">        if (getToken(1).kind == ID_FUNCTION &amp;&amp; getToken(1).image.equals(&quot;mod&quot;)) {</span>
<span class="fc" id="L3100">          tok = jj_consume_token(ID_FUNCTION);</span>
<span class="fc" id="L3101">Logger.logDebug(&quot;\tmod\t\toperator&quot;);</span>
          // se definisco il token mod non posso piÃÂ¹ usarlo come funzione,
                // invece mod ÃÂ¨ definito nella standard library anche come funzione
                // quindi quando trova &lt;MOD&gt; invece che function protesta
                // tok = &lt;MOD&gt; {Logger.logDebug(&quot;\tmod\t\toperator&quot;);}
<span class="fc" id="L3106">                arg2 = powerExpr(localVar, areAllowedNewVar);</span>
        } else {
<span class="nc" id="L3108">          jj_consume_token(-1);</span>
<span class="nc" id="L3109">          throw new ParseException();</span>
        }
      }
<span class="fc" id="L3112">arg1 = t;</span>
<span class="fc" id="L3113">      String funcName = Utility.getFunctionName(tok.image);</span>
<span class="fc" id="L3114">      TupleTerm tupleT = Utility.createPair(arg1, arg2, termsPack, defPack, header.getSignature());</span>
      //assert tupleT.getTerms().size() == tupleT.getArity();
<span class="pc bpc" id="L3116" title="1 of 2 branches missed.">      if ((t = Utility.createFunctionTerm(funcName, tupleT, termsPack, declared_Func, declared_Dom, defPack, header.getSignature())) == null) throw new ParseException(&quot;&quot;);</span>
<span class="fc" id="L3117">    }</span>
<span class="fc" id="L3118">{if (&quot;&quot; != null) return t;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public Term powerExpr(HashMap localVar, boolean areAllowedNewVar) throws ParseException {Term t, arg1, arg2;
  Token tok;
<span class="fc" id="L3124">    t = unaryExpr(localVar, areAllowedNewVar);</span>
    label_31:
    while (true) {
<span class="pc bpc" id="L3127" title="1 of 4 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case PWR:{
<span class="nc" id="L3129">        break;</span>
        }
      default:
<span class="fc" id="L3132">        jj_la1[73] = jj_gen;</span>
<span class="fc" id="L3133">        break label_31;</span>
      }
<span class="nc" id="L3135">      tok = jj_consume_token(PWR);</span>
<span class="nc" id="L3136">Logger.logDebug(&quot;\t^\t\toperator&quot;);</span>
<span class="nc" id="L3137">      arg2 = unaryExpr(localVar, areAllowedNewVar);</span>
<span class="nc" id="L3138">arg1 = t;</span>
<span class="nc" id="L3139">      String funcName = Utility.getFunctionName(tok.image);</span>
<span class="nc" id="L3140">      TupleTerm tupleT = Utility.createPair(arg1, arg2, termsPack, defPack, header.getSignature());</span>
      //assert tupleT.getTerms().size() == tupleT.getArity();
<span class="nc bnc" id="L3142" title="All 2 branches missed.">      if ((t = Utility.createFunctionTerm(funcName, tupleT, termsPack, declared_Func, declared_Dom, defPack, header.getSignature())) == null) throw new ParseException(&quot;&quot;);</span>
<span class="nc" id="L3143">    }</span>
<span class="fc" id="L3144">{if (&quot;&quot; != null) return t;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

<span class="fc" id="L3148">  final public Term unaryExpr(HashMap localVar, boolean areAllowedNewVar) throws ParseException {Term t = null, arg;</span>
  Token tok;
<span class="pc bpc" id="L3150" title="1 of 5 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case PLUS:
    case MINUS:{
<span class="fc bfc" id="L3153" title="All 2 branches covered.">      if (jj_2_23(2)) {</span>
<span class="fc" id="L3154">        tok = jj_consume_token(PLUS);</span>
<span class="fc" id="L3155">Logger.logDebug(&quot;\tPLUS UNARY -\t\toperator&quot;);</span>
<span class="fc" id="L3156">        arg = unaryExpr(localVar, areAllowedNewVar);</span>
      } else {
<span class="pc bpc" id="L3158" title="2 of 4 branches missed.">        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
        case MINUS:{
<span class="fc" id="L3160">          tok = jj_consume_token(MINUS);</span>
<span class="fc" id="L3161">Logger.logDebug(&quot;\t MINUS  UNARY -\t\toperator&quot;);</span>
<span class="fc" id="L3162">          arg = unaryExpr(localVar, areAllowedNewVar);</span>
<span class="fc" id="L3163">          break;</span>
          }
        default:
<span class="nc" id="L3166">          jj_la1[74] = jj_gen;</span>
<span class="nc" id="L3167">          jj_consume_token(-1);</span>
<span class="nc" id="L3168">          throw new ParseException();</span>
        }
      }
<span class="fc" id="L3171">String funcName = Utility.getFunctionName(tok.image);</span>
<span class="fc" id="L3172">      TupleTerm tupleT = Utility.createSingle(arg, termsPack, defPack, header.getSignature());</span>
      //assert tupleT.getTerms().size() == tupleT.getArity();
<span class="fc" id="L3174">      t = Utility.createFunctionTerm(funcName, tupleT, termsPack, declared_Func, declared_Dom, defPack, header.getSignature());</span>
<span class="pc bpc" id="L3175" title="1 of 2 branches missed.">      if (t == null) throw new ParseException(&quot;Problems in creating unary espressions.&quot;);</span>
<span class="fc" id="L3176">      {if (&quot;&quot; != null) return t;}</span>
      break;
      }
    case PROD:
    case SEQ:
    case POWERSET:
    case BAG:
    case MAP:
    case RULEDOM:
    case TRUE:
    case FALSE:
    case UNDEF:
    case NUMBER:
    case NATNUMBER:
    case REAL_NUMBER:
    case COMPLEX_NUMBER:
    case ID_VARIABLE:
    case ID_ENUM:
    case ID_DOMAIN:
    case ID_FUNCTION:
    case CHAR_LITERAL:
    case STRING_LITERAL:
    case 115:{
<span class="fc" id="L3199">      t = basicExpr(localVar, areAllowedNewVar);</span>
<span class="fc" id="L3200">      break;</span>
      }
    default:
<span class="nc" id="L3203">      jj_la1[75] = jj_gen;</span>
<span class="nc" id="L3204">      jj_consume_token(-1);</span>
<span class="nc" id="L3205">      throw new ParseException();</span>
    }
<span class="fc" id="L3207">{if (&quot;&quot; != null) return t;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public Term basicExpr(HashMap localVar, boolean areAllowedNewVar) throws ParseException {Term t;
<span class="fc bfc" id="L3212" title="All 2 branches covered.">    if (jj_2_24(2147483647)) {</span>
<span class="fc" id="L3213">      t = BasicTerm(localVar, areAllowedNewVar);</span>
    } else {
<span class="pc bpc" id="L3215" title="1 of 4 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case PROD:
      case SEQ:
      case POWERSET:
      case BAG:
      case MAP:
      case RULEDOM:
      case ID_DOMAIN:{
<span class="fc" id="L3223">        t = DomainTerm();</span>
<span class="fc" id="L3224">        break;</span>
        }
      default:
<span class="fc" id="L3227">        jj_la1[76] = jj_gen;</span>
<span class="fc bfc" id="L3228" title="All 2 branches covered.">        if (jj_2_25(2147483647)) {</span>
<span class="fc" id="L3229">          t = FiniteQuantificationTerm(localVar);</span>
        } else {
<span class="pc bpc" id="L3231" title="2 of 4 branches missed.">          switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
          case 115:{
<span class="fc" id="L3233">            jj_consume_token(115);</span>
<span class="fc" id="L3234">Logger.logDebug(&quot;\t(&quot;);</span>
<span class="fc" id="L3235">            t = Expression(localVar, areAllowedNewVar);</span>
<span class="fc" id="L3236">            jj_consume_token(117);</span>
<span class="fc" id="L3237">Logger.logDebug(&quot;\t)&quot;);</span>
<span class="fc" id="L3238">            break;</span>
            }
          default:
<span class="nc" id="L3241">            jj_la1[77] = jj_gen;</span>
<span class="nc" id="L3242">            jj_consume_token(-1);</span>
<span class="nc" id="L3243">            throw new ParseException();</span>
          }
        }
      }
    }
<span class="fc" id="L3248">{if (&quot;&quot; != null) return t;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

////////////////////////////////////////////////////////////////////////////////////////
  final public BasicTerm BasicTerm(HashMap localVar, boolean areAllowedNewVar) throws ParseException {BasicTerm t;
<span class="pc bpc" id="L3254" title="2 of 6 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case TRUE:
    case FALSE:
    case UNDEF:
    case NUMBER:
    case NATNUMBER:
    case REAL_NUMBER:
    case COMPLEX_NUMBER:
    case ID_ENUM:
    case CHAR_LITERAL:
    case STRING_LITERAL:{
<span class="fc" id="L3265">      t = ConstantTerm();</span>
<span class="fc" id="L3266">      break;</span>
      }
    case ID_VARIABLE:{
<span class="fc" id="L3269">      t = VariableTerm(localVar, areAllowedNewVar);</span>
<span class="fc" id="L3270">      break;</span>
      }
    case ID_FUNCTION:{
<span class="fc" id="L3273">      t = FunctionTerm(localVar, areAllowedNewVar);</span>
<span class="fc" id="L3274">      break;</span>
      }
    default:
<span class="nc" id="L3277">      jj_la1[78] = jj_gen;</span>
<span class="nc" id="L3278">      jj_consume_token(-1);</span>
<span class="nc" id="L3279">      throw new ParseException();</span>
    }
<span class="fc" id="L3281">{if (&quot;&quot; != null) return t;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public FunctionTerm FunctionTerm(HashMap localVar, boolean areAllowedNewVar) throws ParseException {String funcName;
<span class="fc" id="L3286">  String agentName = null;</span>
<span class="fc" id="L3287">  TupleTerm tupleT = null;</span>
  FunctionTerm t;
<span class="fc" id="L3289">Logger.logDebug(&quot;\t&quot;);</span>
<span class="pc bpc" id="L3290" title="1 of 2 branches missed.">    if (jj_2_26(2)) {</span>
<span class="nc" id="L3291">      agentName = ID_AGENT();</span>
<span class="nc" id="L3292">      jj_consume_token(123);</span>
<span class="nc" id="L3293">Logger.logDebug(agentName + &quot;.&quot;);</span>
    } else {
      ;
    }
<span class="fc" id="L3297">    funcName = ID_FUNCTION();</span>
<span class="fc" id="L3298">Logger.logDebug(funcName + &quot;\t\tFunctionTerm beginning&quot;);</span>
<span class="pc bpc" id="L3299" title="1 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case 115:{
<span class="fc" id="L3301">      tupleT = TupleTerm(localVar, areAllowedNewVar);</span>
<span class="fc" id="L3302">      break;</span>
      }
    default:
<span class="fc" id="L3305">      jj_la1[79] = jj_gen;</span>
      ;
    }
<span class="pc bpc" id="L3308" title="1 of 2 branches missed.">if (agentName != null)</span>
    { //create a new functionTerm representing the agent
      FunctionTerm agent_funT;
<span class="nc bnc" id="L3311" title="All 2 branches missed.">      if (agentName.equals(&quot;self&quot;))</span>
      {
<span class="nc bnc" id="L3313" title="All 2 branches missed.">        if ((agent_funT = Utility.createFunctionTerm(&quot;self&quot;, null, termsPack, declared_Func, declared_Dom, defPack, header.getSignature())) == null) throw new ParseException(&quot;&quot;);</span>
      }
      else
      {
<span class="nc" id="L3317">        Term arg = Utility.createStringT(agentName, termsPack, domainsFactory);</span>
<span class="nc" id="L3318">        TupleTerm agentArg = Utility.createSingle(arg, termsPack, defPack, header.getSignature());</span>
        //assert agentArg.getTerms().size() == agentArg.getArity();
<span class="nc bnc" id="L3320" title="All 2 branches missed.">        if ((agent_funT = Utility.createFunctionTerm(&quot;getAgent&quot;, agentArg, termsPack, declared_Func, declared_Dom, defPack, header.getSignature())) == null) throw new ParseException(&quot;&quot;);</span>
      }
      //insert the functionTerm created as first element of tupleT
<span class="nc bnc" id="L3323" title="All 2 branches missed.">      if (tupleT == null)</span>
      { //create a new TupleTerm for the FunctionTerm
<span class="nc" id="L3325">        tupleT = Utility.createSingle(agent_funT, termsPack, defPack, header.getSignature());</span>
        //assert tupleT.getTerms().size() == tupleT.getArity();
      }
<span class="nc" id="L3328">      else tupleT.getTerms().add(0, agent_funT);</span>
    }
<span class="pc bpc" id="L3330" title="1 of 2 branches missed.">    if ((t = Utility.createFunctionTerm(funcName, tupleT, termsPack, declared_Func, declared_Dom, defPack, header.getSignature())) == null) throw new ParseException(&quot;Problems in creating Function Term&quot;);</span>
<span class="fc" id="L3331">    Logger.logDebug(&quot;\t\t\tFunctionTerm end, D=&quot; + t.getDomain().getName());</span>
<span class="fc" id="L3332">    {if (&quot;&quot; != null) return t;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public LocationTerm LocationTerm(HashMap localVar, boolean areAllowedNewVar) throws ParseException {String funcName;
<span class="fc" id="L3337">  TupleTerm tupleT = null;</span>
<span class="fc" id="L3338">  String agentName = null;</span>
  LocationTerm t;
<span class="fc" id="L3340">Logger.logDebug(&quot;\t&quot;);</span>
<span class="pc bpc" id="L3341" title="1 of 2 branches missed.">    if (jj_2_27(2)) {</span>
<span class="nc" id="L3342">      agentName = ID_AGENT();</span>
<span class="nc" id="L3343">      jj_consume_token(123);</span>
<span class="nc" id="L3344">Logger.logDebug(agentName + &quot;.&quot;);</span>
    } else {
      ;
    }
<span class="fc" id="L3348">    funcName = ID_FUNCTION();</span>
<span class="fc" id="L3349">Logger.logDebug(&quot;\t&quot; + funcName + &quot;\t\tLocationTerm beginning&quot;);</span>
<span class="pc bpc" id="L3350" title="1 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case 115:{
<span class="fc" id="L3352">      tupleT = TupleTerm(localVar, areAllowedNewVar);</span>
<span class="fc" id="L3353">      break;</span>
      }
    default:
<span class="fc" id="L3356">      jj_la1[80] = jj_gen;</span>
      ;
    }
<span class="pc bpc" id="L3359" title="1 of 2 branches missed.">if (agentName != null)</span>
    { //create a new functionTerm representing the agent
      FunctionTerm agent_funT;
<span class="nc bnc" id="L3362" title="All 2 branches missed.">      if (agentName.equals(&quot;self&quot;))</span>
      {
<span class="nc bnc" id="L3364" title="All 2 branches missed.">        if ((agent_funT = Utility.createFunctionTerm(&quot;self&quot;, null, termsPack, declared_Func, declared_Dom, defPack, header.getSignature())) == null) throw new ParseException(&quot;&quot;);</span>
      }
      else
      {
<span class="nc" id="L3368">        Term arg = Utility.createStringT(agentName, termsPack, domainsFactory);</span>
<span class="nc" id="L3369">        TupleTerm agentArg = Utility.createPair(arg, null, termsPack, defPack, header.getSignature());</span>
<span class="nc bnc" id="L3370" title="All 2 branches missed.">        if ((agent_funT = Utility.createFunctionTerm(&quot;getAgent&quot;, agentArg, termsPack, declared_Func, declared_Dom, defPack, header.getSignature())) == null) throw new ParseException(&quot;&quot;);</span>
      }
      //insert the functionTerm created as first element of tupleT
<span class="nc bnc" id="L3373" title="All 2 branches missed.">      if (tupleT == null)</span>
      { //create a new TupleTerm for the FunctionTerm
<span class="nc" id="L3375">        tupleT = Utility.createPair(agent_funT, null, termsPack, defPack, header.getSignature());</span>
      }
<span class="nc" id="L3377">      else tupleT.getTerms().add(0, agent_funT);</span>
    }
<span class="fc" id="L3379">    FunctionTerm f = Utility.createFunctionTerm(funcName, tupleT, termsPack, declared_Func, declared_Dom, defPack, header.getSignature());</span>
<span class="fc" id="L3380">    t = (LocationTerm) f;</span>
<span class="pc bpc" id="L3381" title="1 of 2 branches missed.">    if (t == null) throw new ParseException(&quot;Problems in creating Location Term&quot;);</span>
<span class="fc" id="L3382">    Logger.logDebug(&quot;\t\t\tLocationTerm end, TD=&quot; + t.getDomain().getName());</span>
<span class="fc" id="L3383">    {if (&quot;&quot; != null) return t;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

/** reads a variable term v:
* if v is not in localVar and not areAllowedNewVar parseException
* if v is not in localVar and areAllowedNewVar then builds new variable
* if v is in localVar then insert it in localVar and return that variable
*/
  final public VariableTerm VariableTerm(HashMap &lt; String, VariableTerm &gt; localVar, boolean areAllowedNewVar) throws ParseException {String name;
<span class="fc" id="L3393">  VariableKind kind = VariableKind.LOGICAL_VAR; //Initially new created variableTerm have kind=logical</span>

<span class="fc" id="L3395">    name = ID_VARIABLE();</span>
<span class="fc" id="L3396">VariableTerm variable = (VariableTerm) localVar.get(name);</span>
<span class="fc bfc" id="L3397" title="All 4 branches covered.">    if (!areAllowedNewVar &amp;&amp; variable == null) throw new ParseException(&quot;Error: The definition of new variable is not allowed and &quot; + name + &quot; variable occurs for the first time&quot;);</span>
<span class="fc bfc" id="L3398" title="All 2 branches covered.">    if (variable == null) //create a new variable</span>
    { //create the object
<span class="fc" id="L3400">      variable = termsPack.getBasicTerms().createVariableTerm(name, kind);</span>
      //add this new variable to the localVar HashMap
<span class="fc" id="L3402">      localVar.put(name, variable);</span>
      //set TypeDomain
<span class="fc" id="L3404">      AnyDomain anyDomain = Utility.getAnyDomain(domainsFactory, anyDomainAnyName);</span>
<span class="pc bpc" id="L3405" title="1 of 2 branches missed.">      if (anyDomain == null) throw new ParseException(&quot;Error: The AnyDomain is not defined&quot;);</span>
<span class="fc" id="L3406">      variable.setDomain(anyDomain);</span>
    } //else use the variable found in the HashMap
    //OCL constraints are granted for construction.
    //The variable associations are set through the updateVariable() method invoked by the construct that use the variable
<span class="fc" id="L3410">    Logger.logDebug(&quot;\t&quot; + name + &quot;\t\tVariableTerm, D=&quot; + variable.getDomain().getName() + &quot;, kind=&quot; + variable.getKind().toString());</span>
<span class="fc" id="L3411">    {if (&quot;&quot; != null) return variable;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public ConstantTerm ConstantTerm() throws ParseException {ConstantTerm t;
<span class="pc bpc" id="L3416" title="1 of 2 branches missed.">    if (jj_2_28(2147483647)) {</span>
<span class="nc" id="L3417">      t = ComplexTerm();</span>
<span class="fc bfc" id="L3418" title="All 2 branches covered.">    } else if (jj_2_29(2147483647)) {</span>
<span class="fc" id="L3419">      t = RealTerm();</span>
    } else {
<span class="pc bpc" id="L3421" title="3 of 10 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case NUMBER:{
<span class="fc" id="L3423">        t = IntegerTerm();</span>
<span class="fc" id="L3424">        break;</span>
        }
      case NATNUMBER:{
<span class="fc" id="L3427">        t = NaturalTerm();</span>
<span class="fc" id="L3428">        break;</span>
        }
      case CHAR_LITERAL:{
<span class="nc" id="L3431">        t = CharTerm();</span>
<span class="nc" id="L3432">        break;</span>
        }
      case STRING_LITERAL:{
<span class="fc" id="L3435">        t = StringTerm();</span>
<span class="fc" id="L3436">        break;</span>
        }
      case TRUE:
      case FALSE:{
<span class="fc" id="L3440">        t = BooleanTerm();</span>
<span class="fc" id="L3441">        break;</span>
        }
      case UNDEF:{
<span class="fc" id="L3444">        t = UndefTerm();</span>
<span class="fc" id="L3445">        break;</span>
        }
      case ID_ENUM:{
<span class="fc" id="L3448">        t = EnumTerm();</span>
<span class="fc" id="L3449">        break;</span>
        }
      default:
<span class="nc" id="L3452">        jj_la1[81] = jj_gen;</span>
<span class="nc" id="L3453">        jj_consume_token(-1);</span>
<span class="nc" id="L3454">        throw new ParseException();</span>
      }
    }
<span class="fc" id="L3457">{if (&quot;&quot; != null) return t;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public ComplexTerm ComplexTerm() throws ParseException {Token t;
  String symbol;
<span class="nc" id="L3463">    t = jj_consume_token(COMPLEX_NUMBER);</span>
<span class="nc" id="L3464">symbol = t.image;</span>
    //create the object
<span class="nc" id="L3466">    ComplexTerm term = termsPack.getFurtherTerms().createComplexTerm();</span>
    // set the symbol
<span class="nc" id="L3468">    term.setSymbol(symbol);</span>
    //look for the Complex domain reference
<span class="nc" id="L3470">    BasicTd complexDom = Utility.getBasicDomain(domainsFactory, &quot;Complex&quot;);</span>
    //set the reference
<span class="nc" id="L3472">    term.setDomain(complexDom);</span>
    //constraint 1 is granted for construction
<span class="nc" id="L3474">    Logger.logDebug(&quot;\t&quot; + term.getSymbol() + &quot;\t\tComplexTerm, TD=&quot; + term.getDomain().getName());</span>
<span class="nc" id="L3475">    {if (&quot;&quot; != null) return term;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public RealTerm RealTerm() throws ParseException {Token t;
<span class="fc" id="L3480">  String symbol = &quot;&quot;;</span>
<span class="fc" id="L3481">    t = jj_consume_token(REAL_NUMBER);</span>
<span class="fc" id="L3482">symbol = symbol.concat(t.image);</span>
    //create the object
<span class="fc" id="L3484">    RealTerm term = termsPack.getFurtherTerms().createRealTerm();</span>
<span class="fc" id="L3485">    term.setSymbol(symbol);</span>
    //look for the Real domain reference in the predefined_Dom HashMap
<span class="fc" id="L3487">    TypeDomain dom = Utility.getBasicDomain(domainsFactory, &quot;Real&quot;);</span>
<span class="pc bpc" id="L3488" title="1 of 2 branches missed.">    if (dom == null)</span>
    {
<span class="nc" id="L3490">      throw new ParseException(&quot;Error: The Real domain is not defined&quot;);</span>
    }
    //set references
<span class="fc" id="L3493">    term.setDomain(dom);</span>
    //constraint 1 is granted for construction
<span class="fc" id="L3495">    Logger.logDebug(&quot;\t&quot; + term.getSymbol() + &quot;\t\tRealTerm, TD=&quot; + term.getDomain().getName());</span>
<span class="fc" id="L3496">    {if (&quot;&quot; != null) return term;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public IntegerTerm IntegerTerm() throws ParseException {Token t;
<span class="fc" id="L3501">  String symbol = &quot;&quot;;</span>
    //(t =&quot;+&quot;|t =&quot;-&quot;){symbol = symbol.concat(t.image);}
<span class="fc" id="L3503">      t = jj_consume_token(NUMBER);</span>
<span class="fc" id="L3504">symbol = symbol.concat(t.image);</span>
    //create the object
<span class="fc" id="L3506">    IntegerTerm term = termsPack.getFurtherTerms().createIntegerTerm();</span>
<span class="fc" id="L3507">    term.setSymbol(symbol);</span>
    //look for the Integer domain reference in the predefined_Dom HashMap
<span class="fc" id="L3509">    TypeDomain dom = (TypeDomain) Utility.getBasicDomain(domainsFactory, &quot;Integer&quot;);</span>
<span class="pc bpc" id="L3510" title="1 of 2 branches missed.">    if (dom == null)</span>
    {
<span class="nc" id="L3512">      throw new ParseException(&quot;Error: The Integer domain is not defined&quot;);</span>
    }
    //set references
<span class="fc" id="L3515">    term.setDomain(dom);</span>
    //constraint 1 is granted for construction
<span class="fc" id="L3517">    Logger.logDebug(&quot;\t&quot; + term.getSymbol() + &quot;\t\tIntegerTerm, TD=&quot; + term.getDomain().getName());</span>
<span class="fc" id="L3518">    {if (&quot;&quot; != null) return term;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public NaturalTerm NaturalTerm() throws ParseException {Token t;
  String symbol;
<span class="fc" id="L3524">    t = jj_consume_token(NATNUMBER);</span>
<span class="fc" id="L3525">symbol = t.image;</span>
    //create the object
<span class="fc" id="L3527">    NaturalTerm term = termsPack.getFurtherTerms().createNaturalTerm();</span>
<span class="fc" id="L3528">    term.setSymbol(symbol);</span>
    //look for the Natural domain reference in the predefined_Dom HashMap
<span class="fc" id="L3530">    TypeDomain dom = (TypeDomain) Utility.getBasicDomain(domainsFactory, &quot;Natural&quot;);</span>
<span class="pc bpc" id="L3531" title="1 of 2 branches missed.">    if (dom == null)</span>
    {
<span class="nc" id="L3533">      throw new ParseException(&quot;Error: The Natural domain is not defined&quot;);</span>
    }
    //set references
<span class="fc" id="L3536">    term.setDomain(dom);</span>
    //constraint 1 is granted for construction
<span class="fc" id="L3538">    Logger.logDebug(&quot;\t&quot; + term.getSymbol() + &quot;\t\tNaturalTerm, TD=&quot; + term.getDomain().getName());</span>
<span class="fc" id="L3539">    {if (&quot;&quot; != null) return term;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public CharTerm CharTerm() throws ParseException {Token t;
  String symbol;
<span class="nc" id="L3545">    t = jj_consume_token(CHAR_LITERAL);</span>
<span class="nc" id="L3546">symbol = t.image;</span>
    //create the object
<span class="nc" id="L3548">    CharTerm term = termsPack.getFurtherTerms().createCharTerm();</span>
<span class="nc" id="L3549">    term.setSymbol(symbol);</span>
    //look for the char domain reference in the predefined_Dom HashMap
<span class="nc" id="L3551">    TypeDomain dom = (TypeDomain) Utility.getBasicDomain(domainsFactory, &quot;Char&quot;);</span>
<span class="nc bnc" id="L3552" title="All 2 branches missed.">    if (dom == null)</span>
    {
<span class="nc" id="L3554">      throw new ParseException(&quot;Error: The Char domain is not defined&quot;);</span>
    }
    //set references
<span class="nc" id="L3557">    term.setDomain(dom);</span>
    //constraint 1 is granted for construction
<span class="nc" id="L3559">    Logger.logDebug(&quot;\t&quot; + term.getSymbol() + &quot;\t\tCharTerm, TD=&quot; + term.getDomain().getName());</span>
<span class="nc" id="L3560">    {if (&quot;&quot; != null) return term;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public StringTerm StringTerm() throws ParseException {Token t;
  String symbol;
<span class="fc" id="L3566">    t = jj_consume_token(STRING_LITERAL);</span>
//PA 2018/07/25
    //Con l'istruzione symbol = t.image; le stringhe sono
    //ritornate con le virgolette.
    //symbol = t.image;
    //Con l'istruzione qui sotto commentata le virgolette
    //sono rimosse. E' meglio averle le virgolette, o non averle? 
<span class="fc" id="L3573">    symbol = t.image.substring(1, t.image.length() - 1);</span>
<span class="fc" id="L3574">    StringTerm term = Utility.createStringT(symbol, termsPack, domainsFactory);</span>
<span class="pc bpc" id="L3575" title="1 of 2 branches missed.">    if (term == null) throw new ParseException(&quot;Error: The Char domain is not defined&quot;);</span>
<span class="fc" id="L3576">    Logger.logDebug(&quot;\t&quot; + term.getSymbol() + &quot;\t\tStringTerm, TD=&quot; + term.getDomain().getName());</span>
<span class="fc" id="L3577">    {if (&quot;&quot; != null) return term;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public BooleanTerm BooleanTerm() throws ParseException {Token t;
  String symbol;
<span class="pc bpc" id="L3583" title="2 of 5 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case TRUE:{
<span class="fc" id="L3585">      t = jj_consume_token(TRUE);</span>
<span class="fc" id="L3586">      break;</span>
      }
    case FALSE:{
<span class="fc" id="L3589">      t = jj_consume_token(FALSE);</span>
<span class="fc" id="L3590">      break;</span>
      }
    default:
<span class="nc" id="L3593">      jj_la1[82] = jj_gen;</span>
<span class="nc" id="L3594">      jj_consume_token(-1);</span>
<span class="nc" id="L3595">      throw new ParseException();</span>
    }
<span class="fc" id="L3597">symbol = t.image;</span>
<span class="fc" id="L3598">    BooleanTerm term = termsPack.getBasicTerms().createBooleanTerm(Boolean.parseBoolean(symbol));</span>
    //look for the boolean domain reference in the predefined_Dom HashMap
<span class="fc" id="L3600">    TypeDomain dom = (TypeDomain) Utility.getBasicDomain(domainsFactory, &quot;Boolean&quot;);</span>
<span class="pc bpc" id="L3601" title="1 of 2 branches missed.">    if (dom == null)</span>
    {
<span class="nc" id="L3603">      throw new ParseException(&quot;Error: The Boolean domain is not defined.&quot;);</span>
    }
    //set references
<span class="fc" id="L3606">    term.setDomain(dom);</span>
    //constraint 1 is granted for construction
<span class="fc" id="L3608">    Logger.logDebug(&quot;\t&quot; + term.getSymbol() + &quot;\t\tBooleanTerm, TD=&quot; + term.getDomain().getName());</span>
<span class="fc" id="L3609">    {if (&quot;&quot; != null) return term;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public UndefTerm UndefTerm() throws ParseException {Token t;
  String symbol;
<span class="fc" id="L3615">    t = jj_consume_token(UNDEF);</span>
<span class="fc" id="L3616">Logger.logDebug(&quot;match:UndefTerm&quot;);</span>
<span class="fc" id="L3617">    symbol = t.image;</span>
<span class="fc" id="L3618">    UndefTerm term = termsPack.getBasicTerms().createUndefTerm();</span>
<span class="fc" id="L3619">    term.setSymbol(symbol);</span>
    //look for the Undef domain reference in the predefined_Dom HashMap
<span class="fc" id="L3621">    TypeDomain dom = (TypeDomain) Utility.getBasicDomain(domainsFactory, &quot;Undef&quot;);</span>
<span class="pc bpc" id="L3622" title="1 of 2 branches missed.">    if (dom == null)</span>
    {
<span class="nc" id="L3624">      throw new ParseException(&quot;Error: The Undef domain is not defined&quot;);</span>
    }
    //set references
<span class="fc" id="L3627">    term.setDomain(dom);</span>
    //constraint 1 is granted for construction
<span class="fc" id="L3629">    Logger.logDebug(&quot;\t&quot; + term.getSymbol() + &quot;\t\tUndefTerm, TD=&quot; + term.getDomain().getName());</span>
<span class="fc" id="L3630">    {if (&quot;&quot; != null) return term;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public EnumTerm EnumTerm() throws ParseException {String symbol;
<span class="fc" id="L3635">    symbol = ID_ENUM();</span>
//look for the enumTerm symbol in the enumElem HashMap to obtain the enumeration type-domain to which the enum term is associated.
<span class="fc" id="L3637">    TypeDomain dom = (TypeDomain) enumElem.get(symbol);</span>
<span class="pc bpc" id="L3638" title="1 of 2 branches missed.">    if (dom == null)</span>
    {
<span class="nc" id="L3640">      throw new ParseException(&quot;Error: The enumeration element &quot; + symbol + &quot; is not defined.&quot;);</span>
    }
    //create the object
<span class="fc" id="L3643">    EnumTerm term = termsPack.getFurtherTerms().createEnumTerm();</span>
<span class="fc" id="L3644">    term.setSymbol(symbol);</span>
    //set references
<span class="fc" id="L3646">    term.setDomain(dom);</span>
    //constraint 1 and 2 are granted for construction
<span class="fc" id="L3648">    Logger.logDebug(&quot;\t&quot; + term.getSymbol() + &quot;\t\tEnumTerm, TD=&quot; + term.getDomain().getName());</span>
<span class="fc" id="L3649">    {if (&quot;&quot; != null) return term;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public ExtendedTerm ExtendedTerm(HashMap localVar, boolean areAllowedNewVar, RuleDeclaration c, Domain expDom) throws ParseException {ExtendedTerm t;
<span class="pc bpc" id="L3654" title="1 of 5 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case IF:{
<span class="fc" id="L3656">      t = ConditionalTerm(localVar);</span>
<span class="fc" id="L3657">      break;</span>
      }
    case SWITCH:{
<span class="fc" id="L3660">      t = CaseTerm(localVar);</span>
<span class="fc" id="L3661">      break;</span>
      }
    default:
<span class="fc" id="L3664">      jj_la1[83] = jj_gen;</span>
<span class="fc bfc" id="L3665" title="All 2 branches covered.">      if (jj_2_30(2)) {</span>
        //to solve the conflict with the finite quantification terms  (exist... | existUnique... |forall... )
<span class="fc" id="L3667">            t = TupleTerm(localVar, areAllowedNewVar);</span>
<span class="fc bfc" id="L3668" title="All 2 branches covered.">      } else if (jj_2_31(2147483647)) {</span>
<span class="fc" id="L3669">        t = VariableBindingTerm(localVar);</span>
      } else {
<span class="pc bpc" id="L3671" title="3 of 6 branches missed.">        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
        case LT:
        case 119:
        case 124:{
<span class="fc" id="L3675">          t = CollectionTerm(localVar, areAllowedNewVar);</span>
<span class="fc" id="L3676">          break;</span>
          }
        case 126:{
<span class="fc" id="L3679">          t = RuleAsTerm(localVar, c, expDom);</span>
<span class="fc" id="L3680">          break;</span>
          }
        case PROD:
        case SEQ:
        case POWERSET:
        case BAG:
        case MAP:
        case RULEDOM:
        case ID_DOMAIN:{
<span class="nc" id="L3689">          t = DomainTerm();</span>
<span class="nc" id="L3690">          break;</span>
          }
        default:
<span class="nc" id="L3693">          jj_la1[84] = jj_gen;</span>
<span class="nc" id="L3694">          jj_consume_token(-1);</span>
<span class="nc" id="L3695">          throw new ParseException();</span>
        }
      }
    }
<span class="fc" id="L3699">{if (&quot;&quot; != null) return t;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public ConditionalTerm ConditionalTerm(HashMap localVar) throws ParseException {Term thenT, elseT, guard;
<span class="fc" id="L3704">    jj_consume_token(IF);</span>
<span class="fc" id="L3705">Logger.logDebug(&quot;\tif\t\tConditionalTerm beginning&quot;);</span>
<span class="fc" id="L3706">    guard = Term(localVar, false, null);</span>
<span class="fc" id="L3707">    jj_consume_token(THEN);</span>
<span class="fc" id="L3708">Logger.logDebug(&quot;\tthen&quot;);</span>
<span class="fc" id="L3709">    thenT = Term(localVar, false, null);</span>
<span class="fc" id="L3710">ConditionalTerm term = termsPack.getFurtherTerms().createConditionalTerm();</span>
    //set references
<span class="fc" id="L3712">    term.setGuard(guard);</span>
<span class="fc" id="L3713">    term.setThenTerm(thenT);</span>
    //create associations
    //XX AConditionalTermGuard a_conditionalT_guard = termsPack.getFurtherTerms().getAConditionalTermGuard();
    //XX a_conditionalT_guard.add(term,guard);
    //XX AConditionalTermThenTerm a_conditionalT_thenT = termsPack.getFurtherTerms().getAConditionalTermThenTerm();
    //XX a_conditionalT_thenT.add(term,thenT);

<span class="fc bfc" id="L3720" title="All 4 branches covered.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case ELSE:{
<span class="fc" id="L3722">      jj_consume_token(ELSE);</span>
<span class="fc" id="L3723">Logger.logDebug(&quot;\telse&quot;);</span>
<span class="fc" id="L3724">      elseT = Term(localVar, false, null);</span>
//set the reference
<span class="fc" id="L3726">      term.setElseTerm(elseT);</span>
      //set the association
      //XX AConditionalTermElseTerm a_conditionalT_elseT = termsPack.getFurtherTerms().getAConditionalTermElseTerm();
      //XX a_conditionalT_elseT.add(term,elseT);

<span class="fc" id="L3731">      break;</span>
      }
    default:
<span class="fc" id="L3734">      jj_la1[85] = jj_gen;</span>
      ;
    }
<span class="fc" id="L3737">    jj_consume_token(ENDIF);</span>
//set TypeDomain with &quot;then term&quot; type domain
<span class="fc" id="L3739">    TypeDomain td = OCL_Checker.getTypeDomain(thenT.getDomain());</span>
<span class="fc" id="L3740">    term.setDomain(td);</span>
    //check OCL constraints
<span class="pc bpc" id="L3742" title="1 of 2 branches missed.">    if (!OCL_Checker.checkConditionalTerm(term))</span>
    {
<span class="nc" id="L3744">      Logger.logErr(OCL_Checker.getMsgErr());</span>
<span class="nc" id="L3745">      Logger.logErr(&quot;       At a conditional term.&quot;);</span>
    }
<span class="fc" id="L3747">    Logger.logDebug(&quot;\tendif\t\tConditionalTerm end, TD=&quot; + term.getDomain().getName());</span>
<span class="fc" id="L3748">    {if (&quot;&quot; != null) return term;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public CaseTerm CaseTerm(HashMap localVar) throws ParseException {Term switchT, caseT, resT;
<span class="fc" id="L3753">    jj_consume_token(SWITCH);</span>
<span class="fc" id="L3754">Logger.logDebug(&quot;\tswitch\t\tCaseTerm beginning&quot;);</span>
<span class="fc" id="L3755">    switchT = Term(localVar, false, null);</span>
<span class="fc" id="L3756">CaseTerm term = termsPack.getFurtherTerms().createCaseTerm();</span>
    //set the reference
<span class="fc" id="L3758">    term.setComparedTerm(switchT);</span>
<span class="fc" id="L3759">    List comparingList = term.getComparingTerm();</span>
<span class="fc" id="L3760">    List resultList = term.getResultTerms();</span>
    label_32:
    while (true) {
<span class="fc" id="L3763">      jj_consume_token(CASE);</span>
<span class="fc" id="L3764">Logger.logDebug(&quot;\tcase&quot;);</span>
<span class="fc" id="L3765">      caseT = Term(localVar, false, null);</span>
<span class="fc" id="L3766">      jj_consume_token(118);</span>
<span class="fc" id="L3767">Logger.logDebug(&quot;\t:&quot;);</span>
<span class="fc" id="L3768">      resT = Term(localVar, false, null);</span>
//set the reference
<span class="fc" id="L3770">      comparingList.add(caseT);</span>
<span class="fc" id="L3771">      resultList.add(resT);</span>
<span class="fc bfc" id="L3772" title="All 4 branches covered.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case CASE:{
<span class="fc" id="L3774">        break;</span>
        }
      default:
<span class="fc" id="L3777">        jj_la1[86] = jj_gen;</span>
<span class="fc" id="L3778">        break label_32;</span>
      }
    }
<span class="pc bpc" id="L3781" title="1 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case OTHERWISE:{
<span class="fc" id="L3783">      jj_consume_token(OTHERWISE);</span>
<span class="fc" id="L3784">Logger.logDebug(&quot;\totherwise&quot;);</span>
<span class="fc" id="L3785">      resT = Term(localVar, false, null);</span>
//set the reference
<span class="fc" id="L3787">      term.setOtherwiseTerm(resT);</span>
      //create associations
      //X ACaseTermOtherwiseTerm a_caseT_otherwiseT = termsPack.getFurtherTerms().getACaseTermOtherwiseTerm();
      //X a_caseT_otherwiseT.add(term,resT);

<span class="fc" id="L3792">      break;</span>
      }
    default:
<span class="fc" id="L3795">      jj_la1[87] = jj_gen;</span>
      ;
    }
<span class="fc" id="L3798">    jj_consume_token(END_SWITCH);</span>
//set TypeDomain with either the type domain of the last case result term or the one of the otherwise term (if it exist)
<span class="fc" id="L3800">    TypeDomain td = OCL_Checker.getTypeDomain(resT.getDomain());</span>
<span class="fc" id="L3801">    term.setDomain(td);</span>
    //check OCL constraints
    //constraint 1 is granted for construction
    //check constraints 2-3
    // to be improved
<span class="pc bpc" id="L3806" title="1 of 2 branches missed.">    if (!OCL_Checker.checkCaseTerm(term))</span>
    {
<span class="nc" id="L3808">      Logger.logErr(OCL_Checker.getMsgErr());</span>
<span class="nc" id="L3809">      Logger.logErr(&quot;       At a case term&quot;);</span>
<span class="nc" id="L3810">      throw new ParseException(OCL_Checker.getMsgErr() + &quot;\n       At a case term&quot;);</span>
    }
<span class="fc" id="L3812">    Logger.logDebug(&quot;\tendswitch\t\tCaseTerm end, TD=&quot; + term.getDomain().getName());</span>
<span class="fc" id="L3813">    {if (&quot;&quot; != null) return term;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public TupleTerm TupleTerm(HashMap localVar, boolean areAllowedNewVar) throws ParseException {int arity;
  Term t;
<span class="fc" id="L3819">    jj_consume_token(115);</span>
<span class="fc" id="L3820">Logger.logDebug(&quot;\t(\t\tTupleTerm beginning&quot;);</span>
    //create the object
<span class="fc" id="L3822">    TupleTerm term = termsPack.getBasicTerms().createTupleTerm();</span>
    //List &lt; Term &gt; elemList = term.getTerms();//PA: 2018/01/08
<span class="fc" id="L3824">    List &lt; Term &gt; elemList = new ArrayList &lt; Term &gt; (); //PA: 2018/01/08</span>
<span class="fc" id="L3825">    List &lt; Domain &gt; prodDomList = new LinkedList &lt; Domain &gt; ();</span>
<span class="fc" id="L3826">    t = Term(localVar, areAllowedNewVar, null);</span>
//add the element to the terms list
<span class="fc" id="L3828">    elemList.add(t);</span>
    //add this domain to the domain list
<span class="fc" id="L3830">    prodDomList.add(t.getDomain());</span>
    //check constraint 1 (check elements type)
<span class="pc bpc" id="L3832" title="1 of 2 branches missed.">    if (!OCL_Checker.termAccepted(t)) throw new ParseException(OCL_Checker.getMsgErr() + &quot;\n       At a tuple term&quot;);</span>
    label_33:
    while (true) {
<span class="fc bfc" id="L3835" title="All 4 branches covered.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case 116:{
<span class="fc" id="L3837">        break;</span>
        }
      default:
<span class="fc" id="L3840">        jj_la1[88] = jj_gen;</span>
<span class="fc" id="L3841">        break label_33;</span>
      }
<span class="fc" id="L3843">      jj_consume_token(116);</span>
<span class="fc" id="L3844">      t = Term(localVar, areAllowedNewVar, null);</span>
//add a new element to the terms list
<span class="fc" id="L3846">      elemList.add(t);</span>
      //add this type domain to the domain list
<span class="fc" id="L3848">      prodDomList.add(t.getDomain());</span>
      //check constraint 1 (check elements type)
<span class="pc bpc" id="L3850" title="1 of 2 branches missed.">      if (!OCL_Checker.termAccepted(t)) throw new ParseException(OCL_Checker.getMsgErr() + &quot;\n       At a tuple term&quot;);</span>
    }
<span class="fc" id="L3852">    jj_consume_token(117);</span>
//set the tuple arity
<span class="fc" id="L3854">    arity = elemList.size();</span>
<span class="fc" id="L3855">    term.setArity(arity);</span>
<span class="fc" id="L3856">    term.getTerms().addAll(elemList); //PA: 2018/01/08</span>
    //set the tuple TypeDomain
    Domain dom;
<span class="fc bfc" id="L3859" title="All 2 branches covered.">    if (arity == 1)  //the domain associated to the tuple term must be equal to the one associated to its unique term</span>
<span class="fc" id="L3860">    dom = ((Term) elemList.get(0)).getDomain();</span>
    else //the type-domain associated to the tuple term must be a Cartesian product domain
<span class="fc" id="L3862">    dom = Utility.getProduct(prodDomList, defPack, header.getSignature());</span>
<span class="fc" id="L3863">    term.setDomain(dom);</span>
    //OCL constraints 2-3 granted for construction
    {
<span class="fc" id="L3866">      Logger.logDebug(&quot;\t)\t\tTupleTerm end, arity=&quot; + term.getArity() + &quot;, TD=&quot; + term.getDomain().getName());</span>
    }
<span class="fc" id="L3868">    OCL_Checker.checkTupleTerm(term);</span>
<span class="fc" id="L3869">    {if (&quot;&quot; != null) return term;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public CollectionTerm CollectionTerm(HashMap localVar, boolean areAllowedNewVar) throws ParseException {CollectionTerm t;
<span class="pc bpc" id="L3874" title="1 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case 124:{
<span class="fc" id="L3876">      t = SequenceTerm(localVar, areAllowedNewVar);</span>
<span class="fc" id="L3877">      break;</span>
      }
    default:
<span class="fc" id="L3880">      jj_la1[89] = jj_gen;</span>
<span class="fc bfc" id="L3881" title="All 2 branches covered.">      if (jj_2_32(2147483647)) {</span>
        //{-&gt;} stands for the empty map
<span class="fc" id="L3883">            t = MapTerm(localVar, areAllowedNewVar);</span>
      } else {
<span class="pc bpc" id="L3885" title="2 of 5 branches missed.">        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
        case 119:{
<span class="fc" id="L3887">          t = SetTerm(localVar, areAllowedNewVar);</span>
<span class="fc" id="L3888">          break;</span>
          }
        case LT:{
<span class="fc" id="L3891">          t = BagTerm(localVar, areAllowedNewVar);</span>
<span class="fc" id="L3892">          break;</span>
          }
        default:
<span class="nc" id="L3895">          jj_la1[90] = jj_gen;</span>
<span class="nc" id="L3896">          jj_consume_token(-1);</span>
<span class="nc" id="L3897">          throw new ParseException();</span>
        }
      }
    }
<span class="fc" id="L3901">{if (&quot;&quot; != null) return t;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

/* A collection of zero or more elements of the same nature which have an order and may be duplicated
For example, Sequence{?one?, ?table?, ?one?} and Sequence{?one?, ?one?, ?table?} are different sequences over the string domain.
*/
  final public SequenceTerm SequenceTerm(HashMap localVar, boolean areAllowedNewVar) throws ParseException {int size;
  Term elem, firstElem, lastElem;
  Token tok;
<span class="fc" id="L3911">  double step = 1;</span>
<span class="fc" id="L3912">  boolean natural_step = true;</span>
<span class="fc" id="L3913">    jj_consume_token(124);</span>
<span class="fc" id="L3914">Logger.logDebug(&quot;\t[\t\tSequenceTerm beginning&quot;);</span>
//create the object
<span class="fc" id="L3916">    SequenceTerm term = termsPack.getFurtherTerms().createSequenceTerm();</span>
<span class="fc" id="L3917">    List &lt; Term &gt; elemList = term.getTerms();</span>
<span class="fc bfc" id="L3918" title="All 2 branches covered.">    if (jj_2_33(1)) {</span>
<span class="fc" id="L3919">      firstElem = Term(localVar, areAllowedNewVar, null);</span>
//add a new element to the terms list
<span class="fc" id="L3921">      elemList.add(firstElem);</span>
      //constraint 3
<span class="pc bpc" id="L3923" title="1 of 2 branches missed.">      if (!OCL_Checker.termAccepted(firstElem)) throw new ParseException(OCL_Checker.getMsgErr() + &quot;\n       At a SequenceTerm.&quot;);</span>
<span class="pc bpc" id="L3924" title="1 of 4 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case 116:
      case 118:{
<span class="pc bpc" id="L3927" title="2 of 5 branches missed.">        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
        case 116:{
          label_34:
          while (true) {
<span class="fc" id="L3931">            jj_consume_token(116);</span>
<span class="fc" id="L3932">            elem = Term(localVar, areAllowedNewVar, null);</span>
//add a new element to the terms list
<span class="fc" id="L3934">          elemList.add(elem);</span>
          //constraint 3
<span class="pc bpc" id="L3936" title="1 of 2 branches missed.">          if (!OCL_Checker.termAccepted(elem)) throw new ParseException(OCL_Checker.getMsgErr() + &quot;\n       At a SequenceTerm.&quot;);</span>
<span class="pc bpc" id="L3937" title="1 of 4 branches missed.">            switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
            case 116:{
<span class="fc" id="L3939">              break;</span>
              }
            default:
<span class="fc" id="L3942">              jj_la1[91] = jj_gen;</span>
<span class="fc" id="L3943">              break label_34;</span>
            }
          }
          break;
          }
        case 118:{
<span class="fc" id="L3949">          jj_consume_token(118);</span>
<span class="fc" id="L3950">Logger.logDebug(&quot;\t:&quot;);</span>
          //Interval notation
<span class="fc" id="L3952">                  lastElem = Term(localVar, areAllowedNewVar, null);</span>
<span class="pc bpc" id="L3953" title="1 of 4 branches missed.">          switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
          case 116:{
<span class="fc" id="L3955">            jj_consume_token(116);</span>
<span class="fc" id="L3956">            elem = Term(localVar, areAllowedNewVar, null);</span>
<span class="fc bfc" id="L3957" title="All 2 branches covered.">if (!(elem.getDomain() instanceof IntegerDomain)) natural_step = false;</span>
<span class="fc" id="L3958">            step = Utility.convertToDouble(elem);</span>
<span class="fc" id="L3959">            Logger.logDebug(&quot;\t&quot; + step + &quot;\t\tinterval step&quot;);</span>
<span class="pc bpc" id="L3960" title="1 of 2 branches missed.">            if (step &lt;= 0) throw new ParseException(&quot;The step must be a positive number.&quot; + &quot;\n       At a sequenceTerm.&quot;);</span>
            break;
            }
          default:
<span class="fc" id="L3964">            jj_la1[92] = jj_gen;</span>
            ;
          }
<span class="fc" id="L3967">Utility.createTermCollection(firstElem, lastElem, elemList, step, natural_step, termsPack, declared_Func, declared_Dom, defPack, header.getSignature());</span>
<span class="fc" id="L3968">          break;</span>
          }
        default:
<span class="nc" id="L3971">          jj_la1[93] = jj_gen;</span>
<span class="nc" id="L3972">          jj_consume_token(-1);</span>
<span class="nc" id="L3973">          throw new ParseException();</span>
        }
        break;
        }
      default:
<span class="fc" id="L3978">        jj_la1[94] = jj_gen;</span>
        ;
      }
    } else {
      ;
    }
<span class="fc" id="L3984">    jj_consume_token(125);</span>
//set the size
<span class="fc" id="L3986">    size = elemList.size();</span>
<span class="fc" id="L3987">    term.setSize(size);</span>
    //set the TypeDomain
    TypeDomain elemTD;
<span class="fc bfc" id="L3990" title="All 2 branches covered.">    if (size == 0) //empty collection</span>
    {
<span class="fc" id="L3992">      AnyDomain anyDomain = Utility.getAnyDomain(domainsFactory, anyDomainAnyName);</span>
<span class="pc bpc" id="L3993" title="1 of 2 branches missed.">      if (anyDomain == null) throw new ParseException(&quot;Error: The genric AnyDomain is not defined&quot;);</span>
<span class="fc" id="L3994">      elemTD = anyDomain;</span>
<span class="fc" id="L3995">    }</span>
    else
    {
<span class="fc" id="L3998">      elemTD = Utility.getCommonTD(elemList);</span>
<span class="pc bpc" id="L3999" title="1 of 2 branches missed.">      if (elemTD == null) throw new ParseException(&quot;Error: every element of a sequence must have the same type-domain.\n&quot;);</span>
    }
<span class="fc" id="L4001">    Logger.logDebug(&quot;Common type-domain: &quot; + elemTD.getName());</span>
<span class="fc" id="L4002">    SequenceDomain seqDom = Utility.getSequence(elemTD, defPack, header.getSignature());</span>
    //set seqDom as the sequence TypeDomain
<span class="fc" id="L4004">    term.setDomain(seqDom);</span>
    // ocl constraints 1 and 2 granted for construction
<span class="fc" id="L4006">    Logger.logDebug(&quot;\t]\t\tSequenceTerm end, size=&quot; + term.getSize() + &quot;, TD=&quot; + term.getDomain().getName());</span>
<span class="fc" id="L4007">    {if (&quot;&quot; != null) return term;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

//A collection of zero or more elements of the same nature which have no order and cannot be duplicated
  final public SetTerm SetTerm(HashMap localVar, boolean areAllowedNewVar) throws ParseException {int size;
  Term elem, firstElem, lastElem;
  Token tok;
<span class="fc" id="L4015">  double step = 1;</span>
<span class="fc" id="L4016">  boolean natural_step = true;</span>
<span class="fc" id="L4017">    jj_consume_token(119);</span>
<span class="fc" id="L4018">Logger.logDebug(&quot;\t{\t\tSetTerm beginning&quot;);</span>
//create the object
<span class="fc" id="L4020">    SetTerm term = termsPack.getBasicTerms().createSetTerm();</span>
    //X ASetTermTerm a_SetTerm_Term = termsPack.getBasicTerms().getASetTermTerm();
<span class="fc" id="L4022">    Collection elemColl = term.getTerm();</span>
<span class="fc bfc" id="L4023" title="All 2 branches covered.">    if (jj_2_34(1)) {</span>
<span class="fc" id="L4024">      firstElem = Term(localVar, areAllowedNewVar, null);</span>
//constraint 3
<span class="pc bpc" id="L4026" title="1 of 2 branches missed.">      if (!OCL_Checker.termAccepted(firstElem)) throw new ParseException(OCL_Checker.getMsgErr() + &quot;\n       At a SetTerm.&quot;);</span>
      //add a new element to the terms list
<span class="fc" id="L4028">      elemColl.add(firstElem);</span>
      //add a new association
      //X a_SetTerm_Term.add(term,firstElem);
      //??? In this parser it is created a new term for every used symbol (number,char,string,boolean,ecc...)
      //So every term is a different object and two terms with the same value are inserted in the collection twice.
      //create an HashMap containing set elements and check if an element is duplicated
<span class="fc" id="L4034">      HashMap insertedElem = new HashMap();</span>
<span class="fc" id="L4035">      String key = Utility.appendInKey(new StringBuffer(), firstElem).toString();</span>
<span class="fc" id="L4036">      insertedElem.put(new Integer(key.hashCode()), key);</span>
<span class="fc bfc" id="L4037" title="All 4 branches covered.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case 116:
      case 118:{
<span class="pc bpc" id="L4040" title="2 of 5 branches missed.">        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
        case 116:{
          label_35:
          while (true) {
<span class="fc" id="L4044">            jj_consume_token(116);</span>
<span class="fc" id="L4045">            elem = Term(localVar, areAllowedNewVar, null);</span>
//constraint 3
<span class="pc bpc" id="L4047" title="1 of 2 branches missed.">          if (!OCL_Checker.termAccepted(elem)) throw new ParseException(OCL_Checker.getMsgErr() + &quot;\n       At a SetTerm.&quot;);</span>
          //add a new element to the term list
<span class="fc" id="L4049">          elemColl.add(elem);</span>
          //add a new association
          //X a_SetTerm_Term.add(term,elem);
          //check if the element is duplicated
<span class="fc" id="L4053">          key = Utility.appendInKey(new StringBuffer(), elem).toString();</span>
<span class="pc bpc" id="L4054" title="1 of 2 branches missed.">          if (insertedElem.containsKey(new Integer(key.hashCode()))) throw new ParseException(&quot;Error: Duplicates are not allowed in a set. &quot; + key + &quot; is present twice.&quot;);</span>
<span class="fc" id="L4055">          insertedElem.put(new Integer(key.hashCode()), key);</span>
<span class="fc bfc" id="L4056" title="All 4 branches covered.">            switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
            case 116:{
<span class="fc" id="L4058">              break;</span>
              }
            default:
<span class="fc" id="L4061">              jj_la1[95] = jj_gen;</span>
<span class="fc" id="L4062">              break label_35;</span>
            }
          }
          break;
          }
        case 118:{
<span class="fc" id="L4068">          jj_consume_token(118);</span>
<span class="fc" id="L4069">Logger.logDebug(&quot;\t:&quot;);</span>
          //Interval notation
<span class="fc" id="L4071">                  lastElem = Term(localVar, areAllowedNewVar, null);</span>
<span class="pc bpc" id="L4072" title="1 of 4 branches missed.">          switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
          case 116:{
<span class="fc" id="L4074">            jj_consume_token(116);</span>
<span class="fc" id="L4075">            elem = Term(localVar, areAllowedNewVar, null);</span>
<span class="fc bfc" id="L4076" title="All 2 branches covered.">if (!(elem.getDomain() instanceof IntegerDomain)) natural_step = false;</span>
<span class="fc" id="L4077">            step = Utility.convertToDouble(elem);</span>
<span class="fc" id="L4078">            Logger.logDebug(&quot;\t&quot; + step + &quot;\t\tinterval step&quot;);</span>
<span class="pc bpc" id="L4079" title="1 of 2 branches missed.">            if (step &lt;= 0) throw new ParseException(&quot;The step must be a positive number.&quot; + &quot;\n       At a SetTerm.&quot;);</span>
            break;
            }
          default:
<span class="fc" id="L4083">            jj_la1[96] = jj_gen;</span>
            ;
          }
<span class="fc" id="L4086">Utility.createTermCollection(firstElem, lastElem, elemColl, step, natural_step, termsPack, declared_Func, declared_Dom, defPack, header.getSignature());</span>
<span class="fc" id="L4087">          break;</span>
          }
        default:
<span class="nc" id="L4090">          jj_la1[97] = jj_gen;</span>
<span class="nc" id="L4091">          jj_consume_token(-1);</span>
<span class="nc" id="L4092">          throw new ParseException();</span>
        }
        break;
        }
      default:
<span class="fc" id="L4097">        jj_la1[98] = jj_gen;</span>
        ;
      }
    } else {
      ;
    }
<span class="fc" id="L4103">    jj_consume_token(121);</span>
//set the size
<span class="fc" id="L4105">    size = elemColl.size();</span>
<span class="fc" id="L4106">    term.setSize(size);</span>
    //set the TypeDomain
    TypeDomain elemTD;
<span class="fc bfc" id="L4109" title="All 2 branches covered.">    if (size == 0) //empty collection</span>
    {
<span class="fc" id="L4111">      AnyDomain anyDomain = Utility.getAnyDomain(domainsFactory, anyDomainAnyName);</span>
<span class="pc bpc" id="L4112" title="1 of 2 branches missed.">      if (anyDomain == null) throw new ParseException(&quot;Error: The generic AnyDomain is not defined&quot;);</span>
<span class="fc" id="L4113">      elemTD = anyDomain;</span>
<span class="fc" id="L4114">    }</span>
    else
    {
<span class="fc" id="L4117">      elemTD = Utility.getCommonTD(elemColl);</span>
<span class="pc bpc" id="L4118" title="1 of 2 branches missed.">      if (elemTD == null) throw new ParseException(&quot;Error: every element of a set must have the same type-domain.\n&quot;);</span>
    }
<span class="fc" id="L4120">    PowersetDomain setDom = Utility.getPowerset(elemTD, defPack, header.getSignature());</span>
    //set setDom as the set TypeDomain
<span class="fc" id="L4122">    term.setDomain(setDom);</span>
    // ocl constraints 1 and 2 granted for construction
<span class="fc" id="L4124">    Logger.logDebug(&quot;\t}\t\tSetTerm end, size=&quot; + term.getSize() + &quot;, TD=&quot; + term.getDomain().getName());</span>
<span class="fc" id="L4125">    {if (&quot;&quot; != null) return term;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

/*A collection of zero or more associations which have no order and cannot be duplicated,
like Map{t1 -&gt; s1, . . ., tn -&gt; sn} where t1, . . ., tn are terms of the same nature, and so s1, . . ., sn.
*/
  final public MapTerm MapTerm(HashMap localVar, boolean areAllowedNewVar) throws ParseException {Term elem1, elem2;
<span class="fc" id="L4133">  TypeDomain sourceTD = null;</span>
<span class="fc" id="L4134">  TypeDomain targetTD = null;</span>
<span class="fc" id="L4135">    jj_consume_token(119);</span>
<span class="fc" id="L4136">Logger.logDebug(&quot;\t{\t\tMapTerm beginning&quot;);</span>
//create the object
<span class="fc" id="L4138">    MapTerm term = termsPack.getFurtherTerms().createMapTerm();</span>
    //AMapTermPair a_MapTerm_Pair = termsPack.getFurtherTerms().getAMapTermPair();
<span class="fc" id="L4140">    Collection pairColl = term.getPair();</span>
<span class="pc bpc" id="L4141" title="2 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case 122:{
<span class="nc" id="L4143">      jj_consume_token(122);</span>
<span class="nc" id="L4144">Logger.logDebug(&quot;\t-&gt;&quot;);</span>
<span class="nc" id="L4145">      break;</span>
      }
    default:
<span class="fc" id="L4148">      jj_la1[100] = jj_gen;</span>
<span class="pc bpc" id="L4149" title="1 of 2 branches missed.">      if (jj_2_35(1)) {</span>
<span class="fc" id="L4150">        elem1 = Term(localVar, areAllowedNewVar, null);</span>
<span class="fc" id="L4151">        jj_consume_token(122);</span>
<span class="fc" id="L4152">Logger.logDebug(&quot;\t-&gt;&quot;);</span>
<span class="fc" id="L4153">        elem2 = Term(localVar, areAllowedNewVar, null);</span>
//create a new pair
<span class="fc" id="L4155">        TupleTerm pair = Utility.createPair(elem1, elem2, termsPack, defPack, header.getSignature());</span>
        //add a new element to the terms list
<span class="fc" id="L4157">        pairColl.add(pair);</span>
        //add a new association
        //a_MapTerm_Pair.add(term,pair);
<span class="fc" id="L4160">        sourceTD = OCL_Checker.getTypeDomain(elem1.getDomain());</span>
<span class="fc" id="L4161">        targetTD = OCL_Checker.getTypeDomain(elem2.getDomain());</span>
        //In this parser it is created a new term for every used symbol (number,char,string,boolean,ecc...)
        //So every term is a different object and two equals pair are inserted in the collection twice
        //create an HashMap containing pairs and check if a pair is duplicated
<span class="fc" id="L4165">        HashMap insertedPair = new HashMap();</span>
<span class="fc" id="L4166">        StringBuffer key = Utility.appendInKey(new StringBuffer(), elem1);</span>
<span class="fc" id="L4167">        key.append(&quot;-&gt;&quot;);</span>
<span class="fc" id="L4168">        Utility.appendInKey(key, elem2);</span>
        // TODO: elimina l'uso di String o la conversione
<span class="fc" id="L4170">        insertedPair.put(new Integer(key.toString().hashCode()), key.toString());</span>
        label_36:
        while (true) {
<span class="fc bfc" id="L4173" title="All 4 branches covered.">          switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
          case 116:{
<span class="fc" id="L4175">            break;</span>
            }
          default:
<span class="fc" id="L4178">            jj_la1[99] = jj_gen;</span>
<span class="fc" id="L4179">            break label_36;</span>
          }
<span class="fc" id="L4181">          jj_consume_token(116);</span>
<span class="fc" id="L4182">          elem1 = Term(localVar, areAllowedNewVar, null);</span>
<span class="fc" id="L4183">          jj_consume_token(122);</span>
<span class="fc" id="L4184">Logger.logDebug(&quot;\t-&gt;&quot;);</span>
<span class="fc" id="L4185">          elem2 = Term(localVar, areAllowedNewVar, null);</span>
//create a new pair
<span class="fc" id="L4187">          pair = Utility.createPair(elem1, elem2, termsPack, defPack, header.getSignature());</span>
          //add a new element to the terms list
<span class="fc" id="L4189">          pairColl.add(pair);</span>
          //add a new association
          //a_MapTerm_Pair.add(term,pair);
          //check typeDomain of this pair
<span class="pc bpc" id="L4193" title="1 of 2 branches missed.">          if (!OCL_Checker.compatible(sourceTD, elem1.getDomain())) throw new ParseException(&quot;Error: every pair of a map must be compatible with the type-domain for the first pair element. \n&quot; + &quot;domain of the first element of the first pair: &quot; + sourceTD.getName() + &quot;  domain of another pair: &quot; + elem1.getDomain().getName());</span>
<span class="pc bpc" id="L4194" title="1 of 2 branches missed.">          if (!OCL_Checker.compatible(targetTD, elem2.getDomain())) throw new ParseException(&quot;Error: every pair of a map must be compatible with the type-domain for the second pair element. &quot;);</span>
          //check if a pair is duplicated
<span class="fc" id="L4196">          key = Utility.appendInKey(new StringBuffer(), elem1);</span>
<span class="fc" id="L4197">          key.append(&quot;-&gt;&quot;);</span>
<span class="fc" id="L4198">          Utility.appendInKey(key, elem2);</span>
          // TODO : eliminare conversione a String
<span class="pc bpc" id="L4200" title="1 of 2 branches missed.">          if (insertedPair.containsKey(new Integer(key.toString().hashCode())))</span>
          {
<span class="nc" id="L4202">            Logger.logWarning(&quot;Warning: Duplicate pairs are not allowed in a map. &quot; + key + &quot; is present twice.&quot;);</span>
          }
<span class="fc" id="L4204">          insertedPair.put(new Integer(key.hashCode()), key);</span>
        }
<span class="fc" id="L4206">      } else {</span>
<span class="nc" id="L4207">        jj_consume_token(-1);</span>
<span class="nc" id="L4208">        throw new ParseException();</span>
      }
    }
<span class="fc" id="L4211">    jj_consume_token(121);</span>
//set the size
<span class="fc" id="L4213">    int size = pairColl.size();</span>
<span class="fc" id="L4214">    term.setSize(size);</span>
    //set the TypeDomain when map size is 0
<span class="pc bpc" id="L4216" title="1 of 2 branches missed.">    if (size == 0) //empty collection</span>
    {
<span class="nc" id="L4218">      AnyDomain anyDomain = Utility.getAnyDomain(domainsFactory, anyDomainAnyName);</span>
<span class="nc bnc" id="L4219" title="All 2 branches missed.">      if (anyDomain == null) throw new ParseException(&quot;Error: The AnyDomain is not defined&quot;);</span>
<span class="nc" id="L4220">      sourceTD = targetTD = anyDomain;</span>
    }
<span class="fc" id="L4222">    MapDomain mapDom = Utility.getMap(sourceTD, targetTD, defPack, header.getSignature());</span>
    //set setDom as the set TypeDomain
<span class="fc" id="L4224">    term.setDomain(mapDom);</span>
    //OCL constraints 1,2 and 3 are granted for construction
<span class="fc" id="L4226">    Logger.logDebug(&quot;\t}\t\tMapTerm end, size=&quot; + term.getSize() + &quot;, TD=&quot; + term.getDomain().getName());</span>
<span class="fc" id="L4227">    {if (&quot;&quot; != null) return term;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

//A collection of zero or more elements of the same nature which have no order and may be duplicated
  final public BagTerm BagTerm(HashMap localVar, boolean areAllowedNewVar) throws ParseException {int size;
  Term elem, firstElem, lastElem;
  Token tok;
<span class="fc" id="L4235">  double step = 1;</span>
<span class="fc" id="L4236">  boolean natural_step = true;</span>
<span class="fc" id="L4237">    jj_consume_token(LT);</span>
<span class="fc" id="L4238">Logger.logDebug(&quot;\t&lt;\t\tBagTerm beginning&quot;);</span>
//create the object
<span class="fc" id="L4240">    BagTerm term = termsPack.getFurtherTerms().createBagTerm();</span>
    //XX ABagTermTerm a_BagTerm_Term = termsPack.getFurtherTerms().getABagTermTerm();
<span class="fc" id="L4242">    Collection elemColl = term.getTerm();</span>
<span class="fc bfc" id="L4243" title="All 2 branches covered.">    if (jj_2_36(1)) {</span>
<span class="fc" id="L4244">      firstElem = Term(localVar, areAllowedNewVar, null);</span>
//add a new element to the terms list
<span class="fc" id="L4246">      elemColl.add(firstElem);</span>
      //add a new association
      //XX  a_BagTerm_Term.add(firstElem,term);
      //constraint 3
<span class="pc bpc" id="L4250" title="1 of 2 branches missed.">      if (!OCL_Checker.termAccepted(firstElem)) throw new ParseException(OCL_Checker.getMsgErr() + &quot;\n       At a BagTerm.&quot;);</span>
<span class="pc bpc" id="L4251" title="2 of 4 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case 116:
      case 118:{
<span class="pc bpc" id="L4254" title="2 of 5 branches missed.">        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
        case 116:{
          label_37:
          while (true) {
<span class="fc" id="L4258">            jj_consume_token(116);</span>
<span class="fc" id="L4259">            elem = Term(localVar, areAllowedNewVar, null);</span>
//add a new element to the terms list
<span class="fc" id="L4261">          elemColl.add(elem);</span>
          //add a new association
          //XX a_BagTerm_Term.add(elem,term);
          //constraint 3
<span class="pc bpc" id="L4265" title="1 of 2 branches missed.">          if (!OCL_Checker.termAccepted(elem)) throw new ParseException(OCL_Checker.getMsgErr() + &quot;\n       At a BagTerm.&quot;);</span>
<span class="pc bpc" id="L4266" title="1 of 4 branches missed.">            switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
            case 116:{
<span class="fc" id="L4268">              break;</span>
              }
            default:
<span class="fc" id="L4271">              jj_la1[101] = jj_gen;</span>
<span class="fc" id="L4272">              break label_37;</span>
            }
          }
          break;
          }
        case 118:{
<span class="fc" id="L4278">          jj_consume_token(118);</span>
<span class="fc" id="L4279">Logger.logDebug(&quot;\t:&quot;);</span>
          //Interval notation
<span class="fc" id="L4281">                  lastElem = Term(localVar, areAllowedNewVar, null);</span>
<span class="pc bpc" id="L4282" title="1 of 4 branches missed.">          switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
          case 116:{
<span class="fc" id="L4284">            jj_consume_token(116);</span>
<span class="fc" id="L4285">            elem = Term(localVar, areAllowedNewVar, null);</span>
<span class="fc bfc" id="L4286" title="All 2 branches covered.">if (!(elem.getDomain() instanceof IntegerDomain)) natural_step = false;</span>
<span class="fc" id="L4287">            step = Utility.convertToDouble(elem);</span>
<span class="fc" id="L4288">            Logger.logDebug(&quot;\t&quot; + step + &quot;\t\tinterval step&quot;);</span>
<span class="pc bpc" id="L4289" title="1 of 2 branches missed.">            if (step &lt;= 0) throw new ParseException(&quot;The step must be a positive number.&quot; + &quot;\n       At a sequenceTerm.&quot;);</span>
            break;
            }
          default:
<span class="fc" id="L4293">            jj_la1[102] = jj_gen;</span>
            ;
          }
<span class="fc" id="L4296">Utility.createTermCollection(firstElem, lastElem, elemColl, step, natural_step, termsPack, declared_Func, declared_Dom, defPack, header.getSignature());</span>
<span class="fc" id="L4297">          break;</span>
          }
        default:
<span class="nc" id="L4300">          jj_la1[103] = jj_gen;</span>
<span class="nc" id="L4301">          jj_consume_token(-1);</span>
<span class="nc" id="L4302">          throw new ParseException();</span>
        }
        break;
        }
      default:
<span class="nc" id="L4307">        jj_la1[104] = jj_gen;</span>
        ;
      }
    } else {
      ;
    }
<span class="fc" id="L4313">    jj_consume_token(GT);</span>
//set the bag size
<span class="fc" id="L4315">    size = elemColl.size();</span>
<span class="fc" id="L4316">    term.setSize(size);</span>
    //set the TypeDomain
    TypeDomain elemTD;
<span class="fc bfc" id="L4319" title="All 2 branches covered.">    if (size == 0) //empty collection</span>
    {
<span class="fc" id="L4321">      AnyDomain anyDomain = Utility.getAnyDomain(domainsFactory, anyDomainAnyName);</span>
<span class="pc bpc" id="L4322" title="1 of 2 branches missed.">      if (anyDomain == null) throw new ParseException(&quot;Error: The AnyDomain is not defined&quot;);</span>
<span class="fc" id="L4323">      elemTD = anyDomain;</span>
<span class="fc" id="L4324">    }</span>
    else
    {
<span class="fc" id="L4327">      elemTD = Utility.getCommonTD(elemColl);</span>
<span class="pc bpc" id="L4328" title="1 of 2 branches missed.">      if (elemTD == null) throw new ParseException(&quot;Error: every element of a bag must have the same type-domain.\n&quot;);</span>
    }
<span class="fc" id="L4330">    BagDomain bagDom = Utility.getBag(elemTD, defPack, header.getSignature());</span>
    //set bagDom as the bag TypeDomain
<span class="fc" id="L4332">    term.setDomain(bagDom);</span>
    // ocl constraints 1 and 2 granted for construction
<span class="fc" id="L4334">    Logger.logDebug(&quot;\t&gt;\t\tBagTerm end, size=&quot; + term.getSize() + &quot;, TD=&quot; + term.getDomain().getName());</span>
<span class="fc" id="L4335">    {if (&quot;&quot; != null) return term;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public VariableBindingTerm VariableBindingTerm(HashMap localVar) throws ParseException {VariableBindingTerm t;
<span class="pc bpc" id="L4340" title="3 of 6 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case LET:{
<span class="fc" id="L4342">      t = LetTerm(localVar);</span>
<span class="fc" id="L4343">      break;</span>
      }
    case 115:{
<span class="nc" id="L4346">      t = FiniteQuantificationTerm(localVar);</span>
<span class="nc" id="L4347">      break;</span>
      }
    case LT:
    case 119:
    case 124:{
<span class="fc" id="L4352">      t = ComprehensionTerm(localVar);</span>
<span class="fc" id="L4353">      break;</span>
      }
    default:
<span class="nc" id="L4356">      jj_la1[105] = jj_gen;</span>
<span class="nc" id="L4357">      jj_consume_token(-1);</span>
<span class="nc" id="L4358">      throw new ParseException();</span>
    }
<span class="fc" id="L4360">{if (&quot;&quot; != null) return t;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public FiniteQuantificationTerm FiniteQuantificationTerm(HashMap localVar) throws ParseException {FiniteQuantificationTerm t;
<span class="fc bfc" id="L4365" title="All 2 branches covered.">    if (jj_2_37(2147483647)) {</span>
<span class="fc" id="L4366">      t = ForallTerm(localVar);</span>
<span class="fc bfc" id="L4367" title="All 2 branches covered.">    } else if (jj_2_38(2147483647)) {</span>
<span class="fc" id="L4368">      t = ExistUniqueTerm(localVar);</span>
    } else {
<span class="pc bpc" id="L4370" title="2 of 4 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case 115:{
<span class="fc" id="L4372">        t = ExistTerm(localVar);</span>
<span class="fc" id="L4373">        break;</span>
        }
      default:
<span class="nc" id="L4376">        jj_la1[106] = jj_gen;</span>
<span class="nc" id="L4377">        jj_consume_token(-1);</span>
<span class="nc" id="L4378">        throw new ParseException();</span>
      }
    }
//check OCL constraints
    //(OCL constraint 1)set TypeDomain
    //look for the boolean domain reference in the predefined_Dom HashMap
<span class="fc" id="L4384">    TypeDomain td = Utility.getBasicDomain(domainsFactory, &quot;Boolean&quot;);</span>
<span class="pc bpc" id="L4385" title="1 of 2 branches missed.">    if (td == null) throw new ParseException(&quot;\nError: The Boolean domain has not been declared.&quot;);</span>
    //set the reference
<span class="fc" id="L4387">    t.setDomain(td);</span>
    //(constrains 4) check if the guard has a Boolen domain as associated TypeDomain
<span class="pc bpc" id="L4389" title="1 of 4 branches missed.">    if ((t.getGuard() != null) &amp;&amp; !OCL_Checker.isBoolean(t.getGuard()))</span>
    {
<span class="nc" id="L4391">      Logger.logErr(&quot;\nError: The type-domain of terms after \&quot;with\&quot; must be the boolean domain\n        At a Finite-Quantification term\n&quot;);</span>
    }
<span class="fc" id="L4393">    Logger.logDebug(&quot;, TD=Boolean&quot;);</span>
<span class="fc" id="L4394">    {if (&quot;&quot; != null) return t;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

//NEW by Patrizia Added ranges
  final public ExistTerm ExistTerm(HashMap localVar) throws ParseException {VariableTerm variable;
  Term inTerm, guard;
<span class="fc" id="L4401">    jj_consume_token(115);</span>
<span class="fc" id="L4402">    jj_consume_token(EXIST);</span>
<span class="fc" id="L4403">Logger.logDebug(&quot;\t(exist\t\tExistTerm beginning&quot;);</span>
<span class="fc" id="L4404">    ExistTerm term = termsPack.getFurtherTerms().createExistTerm();</span>
<span class="fc" id="L4405">    List &lt; Term &gt; rangeList = term.getRanges();</span>
    //check if the next variable is already used (look for it in the localVar HashMap)
<span class="fc" id="L4407">    String nextVar = getToken(1).image;</span>
<span class="pc bpc" id="L4408" title="1 of 2 branches missed.">    if (localVar.get(nextVar) != null) throw new ParseException(&quot;Error: The variable &quot; + nextVar + &quot; cannot be bound to a value in the ExistTerm. It is already used.&quot;);</span>
<span class="fc" id="L4409">    variable = VariableTerm(localVar, true);</span>
<span class="fc" id="L4410">    jj_consume_token(IN);</span>
<span class="fc" id="L4411">Logger.logDebug(&quot;\tin&quot;);</span>
<span class="fc" id="L4412">    inTerm = Term(localVar, false, null);</span>
//set the reference to the variable
<span class="fc" id="L4414">    Collection variableList = term.getVariable();</span>
<span class="fc" id="L4415">    variableList.add(variable);</span>
    //check constraint 2 of superclass(part of it is granted for construction)
<span class="pc bpc" id="L4417" title="1 of 2 branches missed.">    if (!(OCL_Checker.getTypeDomain(inTerm.getDomain()) instanceof PowersetDomain)) throw new ParseException(&quot;Error: The type-domain of terms after \&quot;in\&quot;  must be the power set domain \n&quot; + &quot;       At an ExistTerm&quot;);</span>
    //update variable features
<span class="fc" id="L4419">    Utility.updateVariable(variable, inTerm);</span>
<span class="fc" id="L4420">    Logger.logDebug(&quot;\t\t\t&quot; + variable.getName() + &quot; updated: TD=&quot; + variable.getDomain().getName() + &quot;, kind=&quot; + variable.getKind().toString());</span>
<span class="fc" id="L4421">    rangeList.add(inTerm);</span>
    label_38:
    while (true) {
<span class="fc bfc" id="L4424" title="All 4 branches covered.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case 116:{
<span class="fc" id="L4426">        break;</span>
        }
      default:
<span class="fc" id="L4429">        jj_la1[107] = jj_gen;</span>
<span class="fc" id="L4430">        break label_38;</span>
      }
<span class="fc" id="L4432">      jj_consume_token(116);</span>
//check if the next variable is already used (look for it in the localVar HashMap)
<span class="fc" id="L4434">      nextVar = getToken(1).image;</span>
<span class="pc bpc" id="L4435" title="1 of 2 branches missed.">      if (localVar.get(nextVar) != null) throw new ParseException(&quot;Error: The variable &quot; + nextVar + &quot; cannot be bound to a value in the ExistTerm. It is already used.&quot;);</span>
<span class="fc" id="L4436">      variable = VariableTerm(localVar, true);</span>
<span class="fc" id="L4437">      jj_consume_token(IN);</span>
<span class="fc" id="L4438">Logger.logDebug(&quot;\tin&quot;);</span>
<span class="fc" id="L4439">      inTerm = Term(localVar, false, null);</span>
//set the reference to the variable
<span class="fc" id="L4441">      variableList.add(variable);</span>
      //create the association
      //X a_FinQuantT_Var.add(variable,term);
      //check constraint 2 of superclass(part of it is granted for construction)
<span class="pc bpc" id="L4445" title="1 of 2 branches missed.">      if (!(inTerm.getDomain() instanceof PowersetDomain)) throw new ParseException(&quot;Error: The type-domain of terms after \&quot;in\&quot;  must be a power set domain \n&quot; + &quot;       At an ExistTerm&quot;);</span>
      //update variable features
<span class="fc" id="L4447">      Utility.updateVariable(variable, inTerm);</span>
<span class="fc" id="L4448">      Logger.logDebug(&quot;\t\t\t&quot; + variable.getName() + &quot; updated: TD=&quot; + variable.getDomain().getName() + &quot;, kind=&quot; + variable.getKind().toString());</span>
<span class="fc" id="L4449">      rangeList.add(inTerm);</span>
    }
<span class="pc bpc" id="L4451" title="1 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case WITH:{
<span class="fc" id="L4453">      jj_consume_token(WITH);</span>
<span class="fc" id="L4454">Logger.logDebug(&quot;\twith&quot;);</span>
<span class="fc" id="L4455">      guard = Term(localVar, false, null);</span>
//set the reference
<span class="fc" id="L4457">      term.setGuard(guard);</span>
      //create associations
      //X AFiniteQuantificationTermGuard a_FinQuantT_Guard = termsPack.getFurtherTerms().getAFiniteQuantificationTermGuard();
      //X a_FinQuantT_Guard.add(guard,term);

<span class="fc" id="L4462">      break;</span>
      }
    default:
<span class="fc" id="L4465">      jj_la1[108] = jj_gen;</span>
      ;
    }
<span class="fc" id="L4468">    jj_consume_token(117);</span>
<span class="fc" id="L4469">Logger.logDebug(&quot;\t)\t\tExistTerm end&quot;);</span>
<span class="fc" id="L4470">{if (&quot;&quot; != null) return term;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

//NEW by Patrizia Added ranges
  final public ExistUniqueTerm ExistUniqueTerm(HashMap localVar) throws ParseException {VariableTerm variable;
  Term inTerm, guard;
<span class="fc" id="L4477">    jj_consume_token(115);</span>
<span class="fc" id="L4478">    jj_consume_token(EXIST);</span>
<span class="fc" id="L4479">    jj_consume_token(UNIQUE);</span>
<span class="fc" id="L4480">Logger.logDebug(&quot;\t(exist unique\t\tExistUniqueTerm beginning&quot;);</span>
<span class="fc" id="L4481">    ExistUniqueTerm term = termsPack.getFurtherTerms().createExistUniqueTerm();</span>
<span class="fc" id="L4482">    List &lt; Term &gt; rangeList = term.getRanges();</span>
    //check if the next variable is already used (look for it in the localVar HashMap)
<span class="fc" id="L4484">    String nextVar = getToken(1).image;</span>
<span class="pc bpc" id="L4485" title="1 of 2 branches missed.">    if (localVar.get(nextVar) != null) throw new ParseException(&quot;Error: The variable &quot; + nextVar + &quot; cannot be bound to a value in the ExistUniqueTerm. It is already used.&quot;);</span>
<span class="fc" id="L4486">    variable = VariableTerm(localVar, true);</span>
<span class="fc" id="L4487">    jj_consume_token(IN);</span>
<span class="fc" id="L4488">Logger.logDebug(&quot;\tin&quot;);</span>
<span class="fc" id="L4489">    inTerm = Term(localVar, false, null);</span>
//set the reference to the variable
<span class="fc" id="L4491">    Collection variableList = term.getVariable();</span>
<span class="fc" id="L4492">    variableList.add(variable);</span>
    //create the association
    //X AFiniteQuantificationTermVariable a_FinQuantT_Var = termsPack.getFurtherTerms().getAFiniteQuantificationTermVariable();
    //X a_FinQuantT_Var.add(variable,term);
    //check constraint 2 of superclass(part of it is granted for construction)
<span class="pc bpc" id="L4497" title="1 of 2 branches missed.">    if (!(inTerm.getDomain() instanceof PowersetDomain)) throw new ParseException(&quot;Error: The type-domain of terms after \&quot;in\&quot;  must be a power set domain \n&quot; + &quot;       At an ExistUniqueTerm&quot;);</span>
    //update variable features
<span class="fc" id="L4499">    Utility.updateVariable(variable, inTerm);</span>
<span class="fc" id="L4500">    Logger.logDebug(&quot;\t\t\t&quot; + variable.getName() + &quot; updated: TD=&quot; + variable.getDomain().getName() + &quot;, kind=&quot; + variable.getKind().toString());</span>
<span class="fc" id="L4501">    rangeList.add(inTerm);</span>
    label_39:
    while (true) {
<span class="pc bpc" id="L4504" title="2 of 4 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case 116:{
<span class="nc" id="L4506">        break;</span>
        }
      default:
<span class="fc" id="L4509">        jj_la1[109] = jj_gen;</span>
<span class="fc" id="L4510">        break label_39;</span>
      }
<span class="nc" id="L4512">      jj_consume_token(116);</span>
//check if the next variable is already used (look for it in the localVar HashMap)
<span class="nc" id="L4514">      nextVar = getToken(1).image;</span>
<span class="nc bnc" id="L4515" title="All 2 branches missed.">      if (localVar.get(nextVar) != null) throw new ParseException(&quot;Error: The variable &quot; + nextVar + &quot; cannot be bound to a value in the ExistUniqueTerm. It is already used.&quot;);</span>
<span class="nc" id="L4516">      variable = VariableTerm(localVar, true);</span>
<span class="nc" id="L4517">      jj_consume_token(IN);</span>
<span class="nc" id="L4518">Logger.logDebug(&quot;\tin&quot;);</span>
<span class="nc" id="L4519">      inTerm = Term(localVar, false, null);</span>
//set the reference to the variable
<span class="nc" id="L4521">      variableList.add(variable);</span>
      //create the association
      //X a_FinQuantT_Var.add(variable,term);
      //check constraint 2 of superclass(part of it is granted for construction)
<span class="nc bnc" id="L4525" title="All 2 branches missed.">      if (!(inTerm.getDomain() instanceof PowersetDomain)) throw new ParseException(&quot;Error: The type-domain of terms after \&quot;in\&quot;  must be a power set domain \n&quot; + &quot;       At an ExistUniqueTerm&quot;);</span>
      //update variable features
<span class="nc" id="L4527">      Utility.updateVariable(variable, inTerm);</span>
<span class="nc" id="L4528">      Logger.logDebug(&quot;\t\t\t&quot; + variable.getName() + &quot; updated: TD=&quot; + variable.getDomain().getName() + &quot;, kind=&quot; + variable.getKind().toString());</span>
<span class="nc" id="L4529">      rangeList.add(inTerm);</span>
    }
<span class="pc bpc" id="L4531" title="2 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case WITH:{
<span class="fc" id="L4533">      jj_consume_token(WITH);</span>
<span class="fc" id="L4534">Logger.logDebug(&quot;\twith&quot;);</span>
<span class="fc" id="L4535">      guard = Term(localVar, false, null);</span>
//set the reference
<span class="fc" id="L4537">      term.setGuard(guard);</span>
      //create associations
      //X AFiniteQuantificationTermGuard a_FinQuantT_Guard = termsPack.getFurtherTerms().getAFiniteQuantificationTermGuard();
      //X a_FinQuantT_Guard.add(guard,term);

<span class="fc" id="L4542">      break;</span>
      }
    default:
<span class="nc" id="L4545">      jj_la1[110] = jj_gen;</span>
      ;
    }
<span class="fc" id="L4548">    jj_consume_token(117);</span>
<span class="fc" id="L4549">Logger.logDebug(&quot;\t)\t\tExistUniqueTerm end&quot;);</span>
<span class="fc" id="L4550">{if (&quot;&quot; != null) return term;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

//NEW by Patrizia Added ranges
  final public ForallTerm ForallTerm(HashMap localVar) throws ParseException {VariableTerm variable;
  Term inTerm, guard;
<span class="fc" id="L4557">    jj_consume_token(115);</span>
<span class="fc" id="L4558">    jj_consume_token(FORALL);</span>
<span class="fc" id="L4559">Logger.logDebug(&quot;\t(forall\t\tForallTerm beginning&quot;);</span>
<span class="fc" id="L4560">    ForallTerm term = termsPack.getFurtherTerms().createForallTerm();</span>
<span class="fc" id="L4561">    List &lt; Term &gt; rangeList = term.getRanges();</span>
    //check if the next variable is already used (look for it in the localVar HashMap)
<span class="fc" id="L4563">    String nextVar = getToken(1).image;</span>
<span class="pc bpc" id="L4564" title="1 of 2 branches missed.">    if (localVar.get(nextVar) != null) throw new ParseException(&quot;Error: The variable &quot; + nextVar + &quot; cannot be bound to a value in the ForallTerm. It is already used.&quot;);</span>
<span class="fc" id="L4565">    variable = VariableTerm(localVar, true);</span>
<span class="fc" id="L4566">    jj_consume_token(IN);</span>
<span class="fc" id="L4567">Logger.logDebug(&quot;\tin&quot;);</span>
<span class="fc" id="L4568">    inTerm = Term(localVar, false, null);</span>
//set the reference to the variable
<span class="fc" id="L4570">    Collection variableList = term.getVariable();</span>
<span class="fc" id="L4571">    variableList.add(variable);</span>
    //check constraint 2 of superclass(part of it is granted for construction)
<span class="pc bpc" id="L4573" title="1 of 2 branches missed.">    if (!(inTerm.getDomain() instanceof PowersetDomain)) throw new ParseException(&quot;Error: The type-domain of terms after \&quot;in\&quot;  must be a power set domain \n&quot; + &quot;       At an ForallTerm&quot;);</span>
    //update variable features
<span class="fc" id="L4575">    Utility.updateVariable(variable, inTerm);</span>
<span class="fc" id="L4576">    Logger.logDebug(&quot;\t\t\t&quot; + variable.getName() + &quot; updated: TD=&quot; + variable.getDomain().getName() + &quot;, kind=&quot; + variable.getKind().toString());</span>
<span class="fc" id="L4577">    rangeList.add(inTerm);</span>
    label_40:
    while (true) {
<span class="fc bfc" id="L4580" title="All 4 branches covered.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case 116:{
<span class="fc" id="L4582">        break;</span>
        }
      default:
<span class="fc" id="L4585">        jj_la1[111] = jj_gen;</span>
<span class="fc" id="L4586">        break label_40;</span>
      }
<span class="fc" id="L4588">      jj_consume_token(116);</span>
//check if the next variable is already used (look for it in the localVar HashMap)
<span class="fc" id="L4590">      nextVar = getToken(1).image;</span>
<span class="pc bpc" id="L4591" title="1 of 2 branches missed.">      if (localVar.get(nextVar) != null) throw new ParseException(&quot;Error: The variable &quot; + nextVar + &quot; cannot be bound to a value in the ForallTerm. It is already used.&quot;);</span>
<span class="fc" id="L4592">      variable = VariableTerm(localVar, true);</span>
<span class="fc" id="L4593">      jj_consume_token(IN);</span>
<span class="fc" id="L4594">Logger.logDebug(&quot;\tin&quot;);</span>
<span class="fc" id="L4595">      inTerm = Term(localVar, false, null);</span>
//set the reference to the variable
<span class="fc" id="L4597">      variableList.add(variable);</span>
      //check constraint 2 of superclass(part of it is granted for construction)
<span class="pc bpc" id="L4599" title="1 of 2 branches missed.">      if (!(inTerm.getDomain() instanceof PowersetDomain)) throw new ParseException(&quot;Error: The type-domain of terms after \&quot;in\&quot;  must be a power set domain \n&quot; + &quot;       At an ForallTerm&quot;);</span>
      //update variable features
<span class="fc" id="L4601">      Utility.updateVariable(variable, inTerm);</span>
<span class="fc" id="L4602">      Logger.logDebug(&quot;\t\t\t&quot; + variable.getName() + &quot; updated: TD=&quot; + variable.getDomain().getName() + &quot;, kind=&quot; + variable.getKind().toString());</span>
<span class="fc" id="L4603">      rangeList.add(inTerm);</span>
    }
<span class="pc bpc" id="L4605" title="2 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case WITH:{
<span class="fc" id="L4607">      jj_consume_token(WITH);</span>
<span class="fc" id="L4608">Logger.logDebug(&quot;\twith&quot;);</span>
<span class="fc" id="L4609">      guard = Term(localVar, false, null);</span>
//set the reference
<span class="fc" id="L4611">      term.setGuard(guard);</span>
      //create associations
      //X AFiniteQuantificationTermGuard a_FinQuantT_Guard = termsPack.getFurtherTerms().getAFiniteQuantificationTermGuard();
      //X a_FinQuantT_Guard.add(guard,term);

<span class="fc" id="L4616">      break;</span>
      }
    default:
<span class="nc" id="L4619">      jj_la1[112] = jj_gen;</span>
      ;
    }
<span class="fc" id="L4622">    jj_consume_token(117);</span>
<span class="fc" id="L4623">Logger.logDebug(&quot;\t)\t\tForallTerm end&quot;);</span>
<span class="fc" id="L4624">{if (&quot;&quot; != null) return term;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public LetTerm LetTerm(HashMap localVar) throws ParseException {VariableTerm variable;
  Term assignT, body;
<span class="fc" id="L4630">    jj_consume_token(LET);</span>
<span class="fc" id="L4631">    jj_consume_token(115);</span>
<span class="fc" id="L4632">Logger.logDebug(&quot;\tlet(\t\tLetTerm beginning&quot;);</span>
//check if the next variable is already used (look for it in the localVar HashMap)
<span class="fc" id="L4634">    String nextVar = getToken(1).image;</span>
<span class="pc bpc" id="L4635" title="1 of 2 branches missed.">    if (localVar.get(nextVar) != null) throw new ParseException(&quot;Error: The variable &quot; + nextVar + &quot; cannot be bound to a value in the LetTerm. It is already used.&quot;);</span>
<span class="fc" id="L4636">    variable = VariableTerm(localVar, true);</span>
<span class="fc" id="L4637">    jj_consume_token(EQ);</span>
<span class="fc" id="L4638">Logger.logDebug(&quot;\t=&quot;);</span>
<span class="fc" id="L4639">    assignT = Term(localVar, false, null);</span>
<span class="fc" id="L4640">LetTerm term = termsPack.getFurtherTerms().createLetTerm();</span>
<span class="fc" id="L4641">    List variableList = term.getVariable();</span>
<span class="fc" id="L4642">    List assignTList = term.getAssignmentTerm();</span>
    //ALetTermVariable a_letT_Var = termsPack.getFurtherTerms().getALetTermVariable();
    //ALetTermAssignmentTerm a_letT_assignT = termsPack.getFurtherTerms().getALetTermAssignmentTerm();
    //set variable TypeDomain         
    // FIXME 1/4/2009 the domain can be a concrete domain, not only a type domain!
<span class="fc" id="L4647">    Domain varTD = null;</span>
<span class="fc bfc" id="L4648" title="All 2 branches covered.">    if (assignT.getDomain() instanceof ConcreteDomain)</span>
    {
<span class="fc" id="L4650">      varTD = assignT.getDomain();</span>
    }
    else
    {
<span class="fc" id="L4654">      varTD = OCL_Checker.getTypeDomain(assignT.getDomain());</span>
    }
<span class="fc" id="L4656">    variable.setDomain(varTD);</span>
    //set variable kind
<span class="pc bpc" id="L4658" title="1 of 2 branches missed.">    if (varTD instanceof RuleDomain) variable.setKind(VariableKind.RULE_VAR);</span>
    //set references
<span class="fc" id="L4660">    variableList.add(variable);</span>
<span class="fc" id="L4661">    assignTList.add(assignT);</span>
    //create associations
    //a_letT_Var.add(variable,term);
    //a_letT_assignT.add(term,assignT);
<span class="fc" id="L4665">    Logger.logDebug(&quot;\t\t\t&quot; + variable.getName() + &quot; updated: TD=&quot; + variable.getDomain().getName() + &quot;, kind=&quot; + variable.getKind().toString());</span>
    label_41:
    while (true) {
<span class="fc bfc" id="L4668" title="All 4 branches covered.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case 116:{
<span class="fc" id="L4670">        break;</span>
        }
      default:
<span class="fc" id="L4673">        jj_la1[113] = jj_gen;</span>
<span class="fc" id="L4674">        break label_41;</span>
      }
<span class="fc" id="L4676">      jj_consume_token(116);</span>
//check if the next variable is already used (look for it in the localVar HashMap)
<span class="fc" id="L4678">      nextVar = getToken(1).image;</span>
<span class="pc bpc" id="L4679" title="1 of 2 branches missed.">      if (localVar.get(nextVar) != null) throw new ParseException(&quot;Error: The variable &quot; + nextVar + &quot; cannot be bound to a value in the LetTerm. It is already used.&quot;);</span>
<span class="fc" id="L4680">      variable = VariableTerm(localVar, true);</span>
<span class="fc" id="L4681">      jj_consume_token(EQ);</span>
<span class="fc" id="L4682">Logger.logDebug(&quot;\t=&quot;);</span>
<span class="fc" id="L4683">      assignT = Term(localVar, false, null);</span>
// set variable TypeDomain
      //varTD = OCL_Checker.getTypeDomain(assignT.getDomain());
<span class="fc" id="L4686">      varTD = null;</span>
<span class="fc bfc" id="L4687" title="All 2 branches covered.">      if (assignT.getDomain() instanceof ConcreteDomain)</span>
      {
<span class="fc" id="L4689">        varTD = assignT.getDomain();</span>
      }
      else
      {
<span class="fc" id="L4693">        varTD = OCL_Checker.getTypeDomain(assignT.getDomain());</span>
      }
<span class="fc" id="L4695">      variable.setDomain(varTD);</span>
      // set variable kind
<span class="pc bpc" id="L4697" title="1 of 2 branches missed.">      if (varTD instanceof RuleDomain) variable.setKind(VariableKind.RULE_VAR);</span>
      //else kind=logicalVar (it has been setted when the variable term has been created)
      //set references
<span class="fc" id="L4700">      variableList.add(variable);</span>
<span class="fc" id="L4701">      assignTList.add(assignT);</span>
      //create associations
      //a_letT_Var.add(variable,term);
      //a_letT_assignT.add(term,assignT);
<span class="fc" id="L4705">      Logger.logDebug(&quot;\t\t\t&quot; + variable.getName() + &quot; updated: TD=&quot; + variable.getDomain().getName() + &quot;, kind=&quot; + variable.getKind().toString());</span>
    }
<span class="fc" id="L4707">    jj_consume_token(117);</span>
<span class="fc" id="L4708">Logger.logDebug(&quot;\t)&quot;);</span>
<span class="fc" id="L4709">    jj_consume_token(IN);</span>
<span class="fc" id="L4710">Logger.logDebug(&quot;\tin&quot;);</span>
<span class="fc" id="L4711">    body = Term(localVar, false, null);</span>
<span class="fc" id="L4712">    jj_consume_token(ENDLET);</span>
//set the reference
<span class="fc" id="L4714">    term.setBody(body);</span>
    //create the association
    //XX ALetTermBody a_letT_body = termsPack.getFurtherTerms().getALetTermBody();
    //XX a_letT_body.add(term,body);
    //set LetTerm typeDomain
<span class="fc" id="L4719">    TypeDomain td = OCL_Checker.getTypeDomain(body.getDomain());</span>
<span class="fc" id="L4720">    term.setDomain(td);</span>
    //OCL constraint 1, 2, 3 granted for construction
    {
<span class="fc" id="L4723">      Logger.logDebug(&quot;\tendlet\t\tLetTerm end, TD=&quot; + term.getDomain().getName());</span>
    }
<span class="fc" id="L4725">    {if (&quot;&quot; != null) return term;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public ComprehensionTerm ComprehensionTerm(HashMap localVar) throws ParseException {ComprehensionTerm t;
<span class="fc bfc" id="L4730" title="All 2 branches covered.">    if (jj_2_39(2147483647)) {</span>
<span class="fc" id="L4731">      t = SetCT(localVar);</span>
    } else {
<span class="pc bpc" id="L4733" title="3 of 6 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case 119:{
<span class="nc" id="L4735">        t = MapCT(localVar);</span>
<span class="nc" id="L4736">        break;</span>
        }
      case 124:{
<span class="fc" id="L4739">        t = SequenceCT(localVar);</span>
<span class="fc" id="L4740">        break;</span>
        }
      case LT:{
<span class="fc" id="L4743">        t = BagCT(localVar);</span>
<span class="fc" id="L4744">        break;</span>
        }
      default:
<span class="nc" id="L4747">        jj_la1[114] = jj_gen;</span>
<span class="nc" id="L4748">        jj_consume_token(-1);</span>
<span class="nc" id="L4749">        throw new ParseException();</span>
      }
    }
//constraint 1 checked in the specific terms (SetCT, MapCT, SequenceCT, BagCT)
    //constraint 2 (check if the guard TypeDomain is the Boolean domain)
<span class="pc bpc" id="L4754" title="1 of 4 branches missed.">    if ((t.getGuard() != null) &amp;&amp; (!OCL_Checker.isBoolean(t.getGuard())))</span>
    {
<span class="nc" id="L4756">      Logger.logErr(&quot;Error: The type-domain of terms after \&quot;with\&quot; must be the boolean domain\n        At a comprehension term\n&quot;);</span>
    }
<span class="fc" id="L4758">    {if (&quot;&quot; != null) return t;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

//NEW by Patrizia Added ranges.
  final public SetCt SetCT(HashMap localVar) throws ParseException {Term t, inTerm, guard;
  VariableTerm variable;
<span class="fc" id="L4765">  SetCt term = termsPack.getFurtherTerms().createSetCt();</span>
<span class="fc" id="L4766">  List &lt; Term &gt; rangeList = term.getRanges();</span>
<span class="fc" id="L4767">    jj_consume_token(119);</span>
<span class="fc" id="L4768">Logger.logDebug(&quot;\t{\t\tSetCT beginning&quot;);</span>
<span class="fc" id="L4769">    variable = VariableTerm(localVar, true);</span>
<span class="fc" id="L4770">    jj_consume_token(IN);</span>
<span class="fc" id="L4771">Logger.logDebug(&quot;\tin&quot;);</span>
<span class="fc" id="L4772">    inTerm = Term(localVar, false, null);</span>
//if the TypeDomain associated to this variable is not ANY_DOMAIN then it has been used out of the Comprehensionterm
<span class="pc bpc" id="L4774" title="1 of 2 branches missed.">    if (!(variable.getDomain() instanceof AnyDomain)) throw new ParseException(&quot;Error: The variable &quot; + variable.getName() + &quot; cannot be used within the setCT. It is already used.&quot;);</span>
    //set the reference to the variable
<span class="fc" id="L4776">    Collection variableList = term.getVariable();</span>
<span class="fc" id="L4777">    variableList.add(variable);</span>
    //create the association
    //X AComprehensionTermVariable a_Comp_Var = termsPack.getFurtherTerms().getAComprehensionTermVariable();
    //X a_Comp_Var.add(term,variable);
    //check constraint 2 (part of it is granted for construction)
<span class="pc bpc" id="L4782" title="1 of 2 branches missed.">    if (!(inTerm.getDomain() instanceof PowersetDomain)) throw new ParseException(&quot;Error: The type-domain of terms after \&quot;in\&quot;  must be a power set domain \n&quot; + &quot;       At a SetCT&quot;);</span>
    //update variable features
<span class="fc" id="L4784">    Utility.updateVariable(variable, inTerm);</span>
<span class="fc" id="L4785">    Logger.logDebug(&quot;\t\t\t&quot; + variable.getName() + &quot; updated: TD=&quot; + variable.getDomain().getName() + &quot;, kind=&quot; + variable.getKind().toString());</span>
<span class="fc" id="L4786">    rangeList.add(inTerm);</span>
    label_42:
    while (true) {
<span class="fc bfc" id="L4789" title="All 4 branches covered.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case 116:{
<span class="fc" id="L4791">        break;</span>
        }
      default:
<span class="fc" id="L4794">        jj_la1[115] = jj_gen;</span>
<span class="fc" id="L4795">        break label_42;</span>
      }
<span class="fc" id="L4797">      jj_consume_token(116);</span>
<span class="fc" id="L4798">      variable = VariableTerm(localVar, true);</span>
<span class="fc" id="L4799">      jj_consume_token(IN);</span>
<span class="fc" id="L4800">Logger.logDebug(&quot;\tin&quot;);</span>
<span class="fc" id="L4801">      inTerm = Term(localVar, false, null);</span>
//if the TypeDomain associated to this variable is not ANY_DOMAIN then it has been used out of the Comprehensionterm
<span class="pc bpc" id="L4803" title="1 of 2 branches missed.">      if (!(variable.getDomain() instanceof AnyDomain)) throw new ParseException(&quot;Error: The variable &quot; + variable.getName() + &quot; cannot be used within the setCT. It is already used.&quot;);</span>
      //set the reference to the variable
<span class="fc" id="L4805">      variableList.add(variable);</span>
      //create the association
      //X a_Comp_Var.add(term,variable);
      //check constraint 2 (part of it is granted for construction)
<span class="pc bpc" id="L4809" title="1 of 2 branches missed.">      if (!(inTerm.getDomain() instanceof PowersetDomain)) throw new ParseException(&quot;Error: The type-domain of terms after \&quot;in\&quot;  must be a power set domain \n&quot; + &quot;       At a SetCT&quot;);</span>
      //update variable features
<span class="fc" id="L4811">      Utility.updateVariable(variable, inTerm);</span>
<span class="fc" id="L4812">      Logger.logDebug(&quot;\t\t\t&quot; + variable.getName() + &quot; updated: TD=&quot; + variable.getDomain().getName() + &quot;, kind=&quot; + variable.getKind().toString());</span>
<span class="fc" id="L4813">      rangeList.add(inTerm);</span>
    }
<span class="pc bpc" id="L4815" title="1 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case 120:{
<span class="fc" id="L4817">      jj_consume_token(120);</span>
<span class="fc" id="L4818">Logger.logDebug(&quot;\t|&quot;);</span>
<span class="fc" id="L4819">      guard = Term(localVar, false, null);</span>
//set the reference
<span class="fc" id="L4821">      term.setGuard(guard);</span>
      //set the association
      //X AComprehensionTermGuard a_Comp_Guard = termsPack.getFurtherTerms().getAComprehensionTermGuard();
      //X a_Comp_Guard.add(term,guard);

<span class="fc" id="L4826">      break;</span>
      }
    default:
<span class="fc" id="L4829">      jj_la1[116] = jj_gen;</span>
      ;
    }
<span class="fc" id="L4832">    jj_consume_token(118);</span>
<span class="fc" id="L4833">Logger.logDebug(&quot;\t:&quot;);</span>
<span class="fc" id="L4834">    t = Term(localVar, false, null);</span>
//set the reference
<span class="fc" id="L4836">    term.setTerm(t);</span>
    //set the association
    //X AComprehensionTermTerm a_Comp_Term = termsPack.getFurtherTerms().getAComprehensionTermTerm();
    //X a_Comp_Term.add(term,t);
    //check constraint 1 of the superclass (check elements type)
<span class="pc bpc" id="L4841" title="1 of 2 branches missed.">    if (!OCL_Checker.termAccepted(t)) throw new ParseException(OCL_Checker.getMsgErr() + &quot;\n       At a SetComprehensionTerm.\n&quot;);</span>
<span class="fc" id="L4842">    jj_consume_token(121);</span>
// set TypeDomain
<span class="fc" id="L4844">    TypeDomain td = Utility.getPowerset(OCL_Checker.getTypeDomain(t.getDomain()), defPack, header.getSignature());</span>
<span class="fc" id="L4845">    term.setDomain(td);</span>
    //OCL constraint 1 granted for construction
<span class="fc" id="L4847">    Logger.logDebug(&quot;\t}\t\tSetCT end, TD=&quot; + term.getDomain().getName());</span>
<span class="fc" id="L4848">    {if (&quot;&quot; != null) return term;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

//NEW by Patrizia Added ranges.
  final public MapCt MapCT(HashMap localVar) throws ParseException {Term t1, t2, inTerm, guard;
  VariableTerm variable;
<span class="nc" id="L4855">  List &lt; Term &gt; rangeList = new ArrayList &lt; Term &gt; ();</span>
<span class="nc" id="L4856">  MapCt term = termsPack.getFurtherTerms().createMapCt(rangeList);</span>
<span class="nc" id="L4857">    jj_consume_token(119);</span>
<span class="nc" id="L4858">Logger.logDebug(&quot;\t{\t\tMapCT beginning&quot;);</span>
<span class="nc" id="L4859">    variable = VariableTerm(localVar, true);</span>
<span class="nc" id="L4860">    jj_consume_token(IN);</span>
<span class="nc" id="L4861">Logger.logDebug(&quot;\tin&quot;);</span>
<span class="nc" id="L4862">    inTerm = Term(localVar, false, null);</span>
//if the TypeDomain associated to this variable is not ANY_DOMAIN then it has been used out of the Comprehensionterm
<span class="nc bnc" id="L4864" title="All 2 branches missed.">    if (!(variable.getDomain() instanceof AnyDomain)) throw new ParseException(&quot;Error: The variable &quot; + variable.getName() + &quot; cannot be used within the mapCT. It is already used.&quot;);</span>
    //set the reference to the variable
<span class="nc" id="L4866">    Collection variableList = term.getVariable();</span>
<span class="nc" id="L4867">    variableList.add(variable);</span>
    //create the association
    //X AComprehensionTermVariable a_Comp_Var = termsPack.getFurtherTerms().getAComprehensionTermVariable();
    //X a_Comp_Var.add(term,variable);
    //check constraint 3 (part of it is granted for construction)
<span class="nc bnc" id="L4872" title="All 2 branches missed.">    if (!(inTerm.getDomain() instanceof PowersetDomain)) throw new ParseException(&quot;Error: The type-domain of terms after \&quot;in\&quot;  must be a power set domain \n&quot; + &quot;       At a MapCT&quot;);</span>
    //update variable features
<span class="nc" id="L4874">    Utility.updateVariable(variable, inTerm);</span>
<span class="nc" id="L4875">    Logger.logDebug(&quot;\t\t\t&quot; + variable.getName() + &quot; updated: TD=&quot; + variable.getDomain().getName() + &quot;, kind=&quot; + variable.getKind().toString());</span>
<span class="nc" id="L4876">    rangeList.add(inTerm);</span>
    label_43:
    while (true) {
<span class="nc bnc" id="L4879" title="All 4 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case 116:{
<span class="nc" id="L4881">        break;</span>
        }
      default:
<span class="nc" id="L4884">        jj_la1[117] = jj_gen;</span>
<span class="nc" id="L4885">        break label_43;</span>
      }
<span class="nc" id="L4887">      jj_consume_token(116);</span>
<span class="nc" id="L4888">      variable = VariableTerm(localVar, true);</span>
<span class="nc" id="L4889">      jj_consume_token(IN);</span>
<span class="nc" id="L4890">Logger.logDebug(&quot;\tin&quot;);</span>
<span class="nc" id="L4891">      inTerm = Term(localVar, false, null);</span>
//if the TypeDomain associated to this variable is not ANY_DOMAIN then it has been used out of the Comprehensionterm
<span class="nc bnc" id="L4893" title="All 2 branches missed.">      if (!(variable.getDomain() instanceof AnyDomain)) throw new ParseException(&quot;Error: The variable &quot; + variable.getName() + &quot; cannot be used within the mapCT. It is already used.&quot;);</span>
      //set the reference to the variable
<span class="nc" id="L4895">      variableList.add(variable);</span>
      //create the association
      //X a_Comp_Var.add(term,variable);
      //check constraint 3 (part of it is granted for construction)
<span class="nc bnc" id="L4899" title="All 2 branches missed.">      if (!(inTerm.getDomain() instanceof PowersetDomain)) throw new ParseException(&quot;Error: The type-domain of terms after \&quot;in\&quot;  must be a power set domain \n&quot; + &quot;       At a MapCT&quot;);</span>
      //update variable features
<span class="nc" id="L4901">      Utility.updateVariable(variable, inTerm);</span>
<span class="nc" id="L4902">      Logger.logDebug(&quot;\t\t\t&quot; + variable.getName() + &quot; updated: TD=&quot; + variable.getDomain().getName() + &quot;, kind=&quot; + variable.getKind().toString());</span>
<span class="nc" id="L4903">      rangeList.add(inTerm);</span>
    }
<span class="nc bnc" id="L4905" title="All 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case 120:{
<span class="nc" id="L4907">      jj_consume_token(120);</span>
<span class="nc" id="L4908">Logger.logDebug(&quot;\t|&quot;);</span>
<span class="nc" id="L4909">      guard = Term(localVar, false, null);</span>
//set the reference
<span class="nc" id="L4911">      term.setGuard(guard);</span>
      //set the association
      //X AComprehensionTermGuard a_Comp_Guard = termsPack.getFurtherTerms().getAComprehensionTermGuard();
      //X a_Comp_Guard.add(term,guard);

<span class="nc" id="L4916">      break;</span>
      }
    default:
<span class="nc" id="L4919">      jj_la1[118] = jj_gen;</span>
      ;
    }
<span class="nc" id="L4922">    jj_consume_token(118);</span>
<span class="nc" id="L4923">Logger.logDebug(&quot;\t:&quot;);</span>
<span class="nc" id="L4924">    t1 = Term(localVar, false, null);</span>
<span class="nc" id="L4925">    jj_consume_token(122);</span>
<span class="nc" id="L4926">Logger.logDebug(&quot;\t-&gt;&quot;);</span>
<span class="nc" id="L4927">    t2 = Term(localVar, false, null);</span>
<span class="nc" id="L4928">    jj_consume_token(120);</span>
<span class="nc" id="L4929">Logger.logDebug(&quot;\t|&quot;);</span>
//create a new pair
<span class="nc" id="L4931">    TupleTerm pair = Utility.createPair(t1, t2, termsPack, defPack, header.getSignature());</span>
    //set the reference
<span class="nc" id="L4933">    term.setTerm(pair);</span>
    //set the association
    //X AComprehensionTermTerm a_Comp_Term = termsPack.getFurtherTerms().getAComprehensionTermTerm();
    //X a_Comp_Term.add(term,pair);

<span class="nc" id="L4938">    jj_consume_token(121);</span>
// set TypeDomain
<span class="nc" id="L4940">    TypeDomain td = Utility.getMap(OCL_Checker.getTypeDomain(t1.getDomain()), OCL_Checker.getTypeDomain(t2.getDomain()), defPack, header.getSignature());</span>
<span class="nc" id="L4941">    term.setDomain(td);</span>
    //OCL constraints 1, 2 granted for construction
<span class="nc" id="L4943">    Logger.logDebug(&quot;\t}\t\tMapCTend, TD=&quot; + term.getDomain().getName());</span>
<span class="nc" id="L4944">    {if (&quot;&quot; != null) return term;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public SequenceCt SequenceCT(HashMap localVar) throws ParseException {//Notation  [D | P : E] where D are variable declarations, P is the property, E is the espression.
  //P is optional, if not present: [D : E]
  Term t, inTerm, guard;
  VariableTerm variable;
<span class="fc" id="L4952">  SequenceCt term = termsPack.getFurtherTerms().createSequenceCt();</span>
<span class="fc" id="L4953">  List &lt; Term &gt; rangeList = term.getRanges();</span>
<span class="fc" id="L4954">    jj_consume_token(124);</span>
<span class="fc" id="L4955">Logger.logDebug(&quot;\t[\t\tSequenceCT beginning&quot;);</span>
<span class="fc" id="L4956">    variable = VariableTerm(localVar, true);</span>
<span class="fc" id="L4957">    jj_consume_token(IN);</span>
<span class="fc" id="L4958">Logger.logDebug(&quot;\tin&quot;);</span>
<span class="fc" id="L4959">    inTerm = Term(localVar, false, null);</span>
//if the TypeDomain associated to this variable is not ANY_DOMAIN then it has been used out of the Comprehensionterm
<span class="pc bpc" id="L4961" title="1 of 2 branches missed.">    if (!(variable.getDomain() instanceof AnyDomain)) throw new ParseException(&quot;Error: The variable &quot; + variable.getName() + &quot; cannot be used within the SequenceCT. It is already used.&quot;);</span>
    //set the reference to the variable
<span class="fc" id="L4963">    Collection variableList = term.getVariable();</span>
<span class="fc" id="L4964">    variableList.add(variable);</span>
    //create the association
    //X AComprehensionTermVariable a_Comp_Var = termsPack.getFurtherTerms().getAComprehensionTermVariable();
    //X a_Comp_Var.add(term,variable);
    //check constraint 2 (part of it is granted for construction)
<span class="pc bpc" id="L4969" title="1 of 2 branches missed.">    if (!(inTerm.getDomain() instanceof SequenceDomain)) throw new ParseException(&quot;Error: The type-domain of terms after \&quot;in\&quot;  must be a sequence domain \n&quot; + &quot;       At a SequenceCT&quot;);</span>
    //update variable features
<span class="fc" id="L4971">    Utility.updateVariable(variable, inTerm);</span>
<span class="fc" id="L4972">    Logger.logDebug(&quot;\t\t\t&quot; + variable.getName() + &quot; updated: TD=&quot; + variable.getDomain().getName() + &quot;, kind=&quot; + variable.getKind().toString());</span>
<span class="fc" id="L4973">    rangeList.add(inTerm);</span>
    label_44:
    while (true) {
<span class="pc bpc" id="L4976" title="1 of 4 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case 116:{
<span class="nc" id="L4978">        break;</span>
        }
      default:
<span class="fc" id="L4981">        jj_la1[119] = jj_gen;</span>
<span class="fc" id="L4982">        break label_44;</span>
      }
<span class="nc" id="L4984">      jj_consume_token(116);</span>
<span class="nc" id="L4985">      variable = VariableTerm(localVar, true);</span>
<span class="nc" id="L4986">      jj_consume_token(IN);</span>
<span class="nc" id="L4987">Logger.logDebug(&quot;\tin&quot;);</span>
<span class="nc" id="L4988">      inTerm = Term(localVar, false, null);</span>
//if the TypeDomain associated to this variable is not ANY_DOMAIN then it has been used out of the Comprehensionterm
<span class="nc bnc" id="L4990" title="All 2 branches missed.">      if (!(variable.getDomain() instanceof AnyDomain)) throw new ParseException(&quot;Error: The variable &quot; + variable.getName() + &quot; cannot be used within the SequenceCT. It is already used.&quot;);</span>
      //set the reference to the variable
<span class="nc" id="L4992">      variableList.add(variable);</span>
      //create the association
      //X a_Comp_Var.add(term,variable);
      //check constraint 2 (part of it is granted for construction)
<span class="nc bnc" id="L4996" title="All 2 branches missed.">      if (!(inTerm.getDomain() instanceof SequenceDomain)) throw new ParseException(&quot;Error: The type-domain of terms after \&quot;in\&quot;  must be a sequence domain \n&quot; + &quot;       At a SequenceCT&quot;);</span>
      //update variable features
<span class="nc" id="L4998">      Utility.updateVariable(variable, inTerm);</span>
<span class="nc" id="L4999">      Logger.logDebug(&quot;\t\t\t&quot; + variable.getName() + &quot; updated: TD=&quot; + variable.getDomain().getName() + &quot;, kind=&quot; + variable.getKind().toString());</span>
<span class="nc" id="L5000">      rangeList.add(inTerm);</span>
    }
<span class="pc bpc" id="L5002" title="1 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case 120:{
<span class="fc" id="L5004">      jj_consume_token(120);</span>
<span class="fc" id="L5005">Logger.logDebug(&quot;\t|&quot;);</span>
<span class="fc" id="L5006">      guard = Term(localVar, false, null);</span>
//set the reference
<span class="fc" id="L5008">      term.setGuard(guard);</span>
      //set the association
      //AComprehensionTermGuard a_Comp_Guard = termsPack.getFurtherTerms().getAComprehensionTermGuard();
      //a_Comp_Guard.add(term,guard);

<span class="fc" id="L5013">      break;</span>
      }
    default:
<span class="fc" id="L5016">      jj_la1[120] = jj_gen;</span>
      ;
    }
<span class="fc" id="L5019">    jj_consume_token(118);</span>
<span class="fc" id="L5020">Logger.logDebug(&quot;\t:&quot;);</span>
<span class="fc" id="L5021">    t = Term(localVar, false, null);</span>
//set the expression reference
<span class="fc" id="L5023">    term.setTerm(t);</span>
    //set the association
    //X AComprehensionTermTerm a_Comp_Term = termsPack.getFurtherTerms().getAComprehensionTermTerm();
    //X a_Comp_Term.add(term,t);
    //check constraint 1 of the superclass (check elements type)
<span class="pc bpc" id="L5028" title="1 of 2 branches missed.">    if (!OCL_Checker.termAccepted(t)) throw new ParseException(OCL_Checker.getMsgErr() + &quot;\n       At a sequence-comprehension term.\n&quot;);</span>
<span class="fc" id="L5029">    jj_consume_token(125);</span>
// set TypeDomain
<span class="fc" id="L5031">    TypeDomain td = Utility.getSequence(OCL_Checker.getTypeDomain(t.getDomain()), defPack, header.getSignature());</span>
<span class="fc" id="L5032">    term.setDomain(td);</span>
    //OCL constraint 1 granted for construction
<span class="fc" id="L5034">    Logger.logDebug(&quot;\t]\t\tSequenceCT end, TD=&quot; + term.getDomain().getName());</span>
<span class="fc" id="L5035">    {if (&quot;&quot; != null) return term;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

//NEW by Patrizia Added ranges
  final public BagCt BagCT(HashMap localVar) throws ParseException {Term t, inTerm, guard;
  VariableTerm variable;
<span class="fc" id="L5042">  BagCt term = termsPack.getFurtherTerms().createBagCt();</span>
<span class="fc" id="L5043">  List &lt; Term &gt; rangeList = term.getRanges();</span>
<span class="fc" id="L5044">    jj_consume_token(LT);</span>
<span class="fc" id="L5045">Logger.logDebug(&quot;\t&lt;\t\tBagCT beginning&quot;);</span>
<span class="fc" id="L5046">    variable = VariableTerm(localVar, true);</span>
<span class="fc" id="L5047">    jj_consume_token(IN);</span>
<span class="fc" id="L5048">Logger.logDebug(&quot;\tin&quot;);</span>
<span class="fc" id="L5049">    inTerm = Term(localVar, false, null);</span>
//if the TypeDomain associated to this variable is not ANY_DOMAIN then it has been used out of the Comprehensionterm
<span class="pc bpc" id="L5051" title="1 of 2 branches missed.">    if (!(variable.getDomain() instanceof AnyDomain)) throw new ParseException(&quot;Error: The variable &quot; + variable.getName() + &quot; cannot be used within the BagCT. It is already used.&quot;);</span>
    //set the reference to the variable
<span class="fc" id="L5053">    Collection variableList = term.getVariable();</span>
<span class="fc" id="L5054">    variableList.add(variable);</span>
    //create the association
    //X AComprehensionTermVariable a_Comp_Var = termsPack.getFurtherTerms().getAComprehensionTermVariable();
    //X a_Comp_Var.add(term,variable);
    //check constraint 2 (part of it is granted for construction)
<span class="pc bpc" id="L5059" title="1 of 2 branches missed.">    if (!(inTerm.getDomain() instanceof BagDomain)) throw new ParseException(&quot;Error: The type-domain of terms after \&quot;in\&quot;  must be a bag domain \n&quot; + &quot;       At a BagCT&quot;);</span>
    //update variable features
<span class="fc" id="L5061">    Utility.updateVariable(variable, inTerm);</span>
<span class="fc" id="L5062">    Logger.logDebug(&quot;\t\t\t&quot; + variable.getName() + &quot; updated: TD=&quot; + variable.getDomain().getName() + &quot;, kind=&quot; + variable.getKind().toString());</span>
<span class="fc" id="L5063">    rangeList.add(inTerm);</span>
    label_45:
    while (true) {
<span class="pc bpc" id="L5066" title="1 of 4 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case 116:{
<span class="nc" id="L5068">        break;</span>
        }
      default:
<span class="fc" id="L5071">        jj_la1[121] = jj_gen;</span>
<span class="fc" id="L5072">        break label_45;</span>
      }
<span class="nc" id="L5074">      jj_consume_token(116);</span>
<span class="nc" id="L5075">      variable = VariableTerm(localVar, true);</span>
<span class="nc" id="L5076">      jj_consume_token(IN);</span>
<span class="nc" id="L5077">Logger.logDebug(&quot;\tin&quot;);</span>
<span class="nc" id="L5078">      inTerm = Term(localVar, false, null);</span>
//if the TypeDomain associated to this variable is not ANY_DOMAIN then it has been used out of the Comprehensionterm
<span class="nc bnc" id="L5080" title="All 2 branches missed.">      if (!(variable.getDomain() instanceof AnyDomain)) throw new ParseException(&quot;Error: The variable &quot; + variable.getName() + &quot; cannot be used within the BagCT. It is already used.&quot;);</span>
      //set the reference to the variable
<span class="nc" id="L5082">      variableList.add(variable);</span>
      //create the association
      //X a_Comp_Var.add(term,variable);
      //check constraint 2 (part of it is granted for construction)
<span class="nc bnc" id="L5086" title="All 2 branches missed.">      if (!(inTerm.getDomain() instanceof BagDomain)) throw new ParseException(&quot;Error: The type-domain of terms after \&quot;in\&quot;  must be a bag domain \n&quot; + &quot;       At a BagCT&quot;);</span>
      //update variable features
<span class="nc" id="L5088">      Utility.updateVariable(variable, inTerm);</span>
<span class="nc" id="L5089">      Logger.logDebug(&quot;\t\t\t&quot; + variable.getName() + &quot; updated: TD=&quot; + variable.getDomain().getName() + &quot;, kind=&quot; + variable.getKind().toString());</span>
<span class="nc" id="L5090">      rangeList.add(inTerm);</span>
    }
<span class="pc bpc" id="L5092" title="1 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case 120:{
<span class="fc" id="L5094">      jj_consume_token(120);</span>
<span class="fc" id="L5095">Logger.logDebug(&quot;\t|&quot;);</span>
<span class="fc" id="L5096">      guard = Term(localVar, false, null);</span>
//set the reference
<span class="fc" id="L5098">      term.setGuard(guard);</span>
      //set the association
      //AComprehensionTermGuard a_Comp_Guard = termsPack.getFurtherTerms().getAComprehensionTermGuard();
      //a_Comp_Guard.add(term,guard);

<span class="fc" id="L5103">      break;</span>
      }
    default:
<span class="fc" id="L5106">      jj_la1[122] = jj_gen;</span>
      ;
    }
<span class="fc" id="L5109">    jj_consume_token(118);</span>
<span class="fc" id="L5110">Logger.logDebug(&quot;\t:&quot;);</span>
<span class="fc" id="L5111">    t = Term(localVar, false, null);</span>
//set the reference
<span class="fc" id="L5113">    term.setTerm(t);</span>
    //set the association
    //X AComprehensionTermTerm a_Comp_Term = termsPack.getFurtherTerms().getAComprehensionTermTerm();
    //X a_Comp_Term.add(term,t);
    //check constraint 1 of the superclass (check elements type)
<span class="pc bpc" id="L5118" title="1 of 2 branches missed.">    if (!OCL_Checker.termAccepted(t)) throw new ParseException(OCL_Checker.getMsgErr() + &quot;\n       At a bag-comprehension term.\n&quot;);</span>
<span class="fc" id="L5119">    jj_consume_token(GT);</span>
// set TypeDomain
<span class="fc" id="L5121">    TypeDomain td = Utility.getBag(OCL_Checker.getTypeDomain(t.getDomain()), defPack, header.getSignature());</span>
<span class="fc" id="L5122">    term.setDomain(td);</span>
    //OCL constraint 1 granted for construction
<span class="fc" id="L5124">    Logger.logDebug(&quot;\t&gt;\t\tBagCT end, TD=&quot; + term.getDomain().getName());</span>
<span class="fc" id="L5125">    {if (&quot;&quot; != null) return term;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public DomainTerm DomainTerm() throws ParseException {Domain d;
<span class="fc" id="L5130">    d = getDomainByID();</span>
//create the object
<span class="fc" id="L5132">    DomainTerm term = termsPack.getBasicTerms().createDomainTerm();</span>
    //set references
<span class="fc" id="L5134">    term.setDomain(d);</span>
    //set the TypeDomain
<span class="fc" id="L5136">    PowersetDomain powersetDom = Utility.getPowerset(d, defPack, header.getSignature());</span>
    //set references
<span class="fc" id="L5138">    term.setDomain(powersetDom);</span>
    //OCL constraint 1 granted for construction
<span class="fc" id="L5140">    Logger.logDebug(&quot;\t&quot; + d.getName() + &quot;\t\tDomainTerm, D=&quot; + term.getDomain().getName());</span>
<span class="fc" id="L5141">    {if (&quot;&quot; != null) return term;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

/*
* modified 10 Jan 2008 by acarioni
*
*/
  final public RuleAsTerm RuleAsTerm(HashMap localVar, RuleDeclaration c, Domain expDom) throws ParseException {RuleDeclaration r;
  Object [ ] dcl;
  String ruleName;
  List &lt; Domain &gt; ruleDomList;
<span class="fc" id="L5153">    jj_consume_token(126);</span>
<span class="fc" id="L5154">Logger.logDebug(&quot;\t&lt;&lt;\t\tRuleAsTerm beginning&quot;);</span>
    // ruleName=ID_RULE()
<span class="fc" id="L5156">      dcl = MacroDcl();</span>
<span class="fc" id="L5157">ruleName = (String) dcl [ 0 ];</span>
<span class="fc" id="L5158">    ruleDomList = (List &lt; Domain &gt;) dcl [ 1 ];</span>
<span class="fc" id="L5159">    jj_consume_token(127);</span>
<span class="fc" id="L5160">Logger.logDebug(&quot;\t&gt;&gt;\t&quot;);</span>
<span class="fc" id="L5161">    RuleAsTerm term = termsPack.getBasicTerms().createRuleAsTerm();</span>
    /* commented 10 Jan 2008 by acarioni
      //look for the Rule domain reference; it is created in case it does note yet exist
      // convert expDomn to RuleDomain
	  RuleDomain rDom = (RuleDomain) expDom;
      List&lt;Domain&gt; ruleDomList = null;
      if(rDom.getDomains()!=null){
            ruleDomList = new LinkedList();
      		for(Object o : rDom.getDomains()){
	  			Domain d = MDRConnector.toDomain(o);
				ruleDomList.add(d);
	  		}
      }
      */
    //look for the rule declaration in the rule HashMap
<span class="fc" id="L5176">    r = Utility.getRuleByNameDom(declared_Rules, ruleName, ruleDomList);</span>
<span class="pc bpc" id="L5177" title="1 of 2 branches missed.">    if (r == null)</span>
    {
<span class="nc" id="L5179">      throw new ParseException(&quot;ERROR: Unresolved reference to &quot; + ruleName + Utility.toString(ruleDomList));</span>
    }
    //set the rule reference
<span class="fc" id="L5182">    term.setRule(r);</span>
<span class="fc" id="L5183">    RuleDomain dom = Utility.getRuleDomain(ruleDomList, defPack, header.getSignature());</span>
    //set the domain reference
<span class="fc" id="L5185">    term.setDomain(dom);</span>
<span class="fc" id="L5186">    Logger.logDebug(&quot;\tRuleAsTerm end, TD=&quot; + dom.getName());</span>
<span class="fc" id="L5187">    {if (&quot;&quot; != null) return term;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

/*
* added 10 Jan 2008 by acarioni
*
* Returns a 2-value array containing a macro rule name and a list of domains
* as the formal parameter domains.
* It is used by RuleAsTerm.
*
*/
<span class="fc" id="L5199">  final public Object [ ] MacroDcl() throws ParseException {Logger.logDebug(&quot;begin - macro rule in RuleAsTerm&quot;);</span>
  String ruleName;
  Domain inDom;
<span class="fc" id="L5202">  List &lt; Domain &gt; domains = new ArrayList &lt; Domain &gt; ();</span>
<span class="fc" id="L5203">    ruleName = ID_RULE();</span>
<span class="fc" id="L5204">Logger.logDebug(&quot;\t&quot; + ruleName);</span>
<span class="pc bpc" id="L5205" title="1 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case 115:{
<span class="fc" id="L5207">Logger.logDebug(&quot;domains: &quot;);</span>
<span class="fc" id="L5208">      jj_consume_token(115);</span>
<span class="fc" id="L5209">      inDom = getDomainByID();</span>
//add it to the list
<span class="fc" id="L5211">      domains.add(inDom);</span>
<span class="fc" id="L5212">      Logger.logDebug(&quot;\t&quot; + inDom.getName());</span>
      label_46:
      while (true) {
<span class="pc bpc" id="L5215" title="1 of 4 branches missed.">        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
        case 116:{
<span class="fc" id="L5217">          break;</span>
          }
        default:
<span class="fc" id="L5220">          jj_la1[123] = jj_gen;</span>
<span class="fc" id="L5221">          break label_46;</span>
        }
<span class="fc" id="L5223">        jj_consume_token(116);</span>
<span class="fc" id="L5224">        inDom = getDomainByID();</span>
//add it to the list
<span class="fc" id="L5226">        domains.add(inDom);</span>
<span class="fc" id="L5227">        Logger.logDebug(&quot;\t&quot; + inDom.getName());</span>
      }
<span class="fc" id="L5229">      jj_consume_token(117);</span>
<span class="fc" id="L5230">      break;</span>
      }
    default:
<span class="fc" id="L5233">      jj_la1[124] = jj_gen;</span>
      ;
    }
<span class="fc" id="L5236">Logger.logDebug(&quot;end - macro rule in RuleAsTerm&quot;);</span>
<span class="fc" id="L5237">    {if (&quot;&quot; != null) return new Object [ ]</span>
    {
      ruleName, domains
    }
    ;}
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

////////////////////////////////////// RULES ////////////////////////////////////////////
//OK! No derived rules
  final public Rule Rule(HashMap localVar, RuleDeclaration c) throws ParseException {Rule r;
<span class="fc bfc" id="L5248" title="All 2 branches covered.">    if (jj_2_40(2)) {</span>
<span class="fc" id="L5249">      r = BasicRule(localVar, c);</span>
    } else {
<span class="fc bfc" id="L5251" title="All 4 branches covered.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case DYNAMIC:
      case seq:
      case ITERATE:
      case LOCAL:
      case ID_RULE:{
<span class="fc" id="L5257">        r = TurboRule(localVar, c);</span>
<span class="fc" id="L5258">        break;</span>
        }
      default:
<span class="fc" id="L5261">        jj_la1[125] = jj_gen;</span>
<span class="fc bfc" id="L5262" title="All 2 branches covered.">        if (jj_2_41(2147483647)) {</span>
<span class="fc" id="L5263">          r = UpdateRule(localVar, c);</span>
<span class="fc bfc" id="L5264" title="All 2 branches covered.">        } else if (jj_2_42(2147483647)) {</span>
<span class="fc" id="L5265">          r = TurboReturnRule(localVar, c);</span>
        } else {
<span class="pc bpc" id="L5267" title="2 of 5 branches missed.">          switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
          case ID_VARIABLE:
          case ID_FUNCTION:{
<span class="fc" id="L5270">            r = TermAsRule(localVar, c);</span>
<span class="fc" id="L5271">            break;</span>
            }
          case SWITCH:
          case WHILE:
          case WHILEREC:{
<span class="fc" id="L5276">            r = DerivedRule(localVar, c);</span>
<span class="fc" id="L5277">            break;</span>
            }
          default:
<span class="nc" id="L5280">            jj_la1[126] = jj_gen;</span>
<span class="nc" id="L5281">            jj_consume_token(-1);</span>
<span class="nc" id="L5282">            throw new ParseException();</span>
          }
        }
      }
    }
<span class="fc" id="L5287">{if (&quot;&quot; != null) return r;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

//OK!
<span class="fc" id="L5292">  final public TermAsRule TermAsRule(HashMap localVar, RuleDeclaration c) throws ParseException {Logger.logDebug(&quot;\t\t\tTermAsRule beginning&quot;);</span>
<span class="fc" id="L5293">  Term par, t = null;</span>
<span class="fc" id="L5294">  TermAsRule rule = rulesPack.getBasicTransitionRules().createTermAsRule();</span>
<span class="fc" id="L5295">  List &lt; Term &gt; actualParamList = rule.getParameters();</span>
<span class="pc bpc" id="L5296" title="2 of 5 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case ID_FUNCTION:{
<span class="fc" id="L5298">      t = FunctionTerm(localVar, false);</span>
<span class="fc" id="L5299">      break;</span>
      }
    case ID_VARIABLE:{
<span class="fc" id="L5302">      t = VariableTerm(localVar, false);</span>
<span class="fc" id="L5303">      break;</span>
      }
    default:
<span class="nc" id="L5306">      jj_la1[127] = jj_gen;</span>
<span class="nc" id="L5307">      jj_consume_token(-1);</span>
<span class="nc" id="L5308">      throw new ParseException();</span>
    }
<span class="fc bfc" id="L5310" title="All 4 branches covered.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case 124:{
<span class="fc" id="L5312">      jj_consume_token(124);</span>
<span class="fc" id="L5313">Logger.logDebug(&quot;\t[&quot;);</span>
<span class="fc" id="L5314">      par = Term(localVar, false, c);</span>
<span class="fc" id="L5315">actualParamList.add(par);</span>
      label_47:
      while (true) {
<span class="pc bpc" id="L5318" title="1 of 4 branches missed.">        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
        case 116:{
<span class="fc" id="L5320">          break;</span>
          }
        default:
<span class="fc" id="L5323">          jj_la1[128] = jj_gen;</span>
<span class="fc" id="L5324">          break label_47;</span>
        }
<span class="fc" id="L5326">        jj_consume_token(116);</span>
<span class="fc" id="L5327">        par = Term(localVar, false, c);</span>
<span class="fc" id="L5328">actualParamList.add(par);</span>
      }
<span class="fc" id="L5330">      jj_consume_token(125);</span>
<span class="fc" id="L5331">      break;</span>
      }
    default:
<span class="fc" id="L5334">      jj_la1[129] = jj_gen;</span>
      ;
    }
//set the references
<span class="fc" id="L5338">    rule.setTerm(t);</span>
    // check OCL constraint
<span class="pc bpc" id="L5340" title="1 of 2 branches missed.">    if (!OCL_Checker.checkTermAsRule(rule)) throw new ParseException(OCL_Checker.getMsgErr() + &quot;\n       At a RuleAsTerm&quot;);</span>
<span class="fc" id="L5341">    Logger.logDebug(&quot;\t\t\tTermAsRule end&quot;);</span>
<span class="fc" id="L5342">    {if (&quot;&quot; != null) return rule;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public Rule BasicRule(HashMap localVar, RuleDeclaration c) throws ParseException {Rule r;
<span class="pc bpc" id="L5347" title="1 of 11 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case Skip:{
<span class="fc" id="L5349">      r = SkipRule();</span>
<span class="fc" id="L5350">      break;</span>
      }
    case ID_RULE:{
<span class="fc" id="L5353">      r = MacroCallRule(localVar, c);</span>
<span class="fc" id="L5354">      break;</span>
      }
    case PAR:{
<span class="fc" id="L5357">      r = BlockRule(localVar, c);</span>
<span class="fc" id="L5358">      break;</span>
      }
    case IF:{
<span class="fc" id="L5361">      r = ConditionalRule(localVar, c);</span>
<span class="fc" id="L5362">      break;</span>
      }
    case CHOOSE:{
<span class="fc" id="L5365">      r = ChooseRule(localVar, c);</span>
<span class="fc" id="L5366">      break;</span>
      }
    case FORALL:{
<span class="fc" id="L5369">      r = ForallRule(localVar, c);</span>
<span class="fc" id="L5370">      break;</span>
      }
    case LET:{
<span class="fc" id="L5373">      r = LetRule(localVar, c);</span>
<span class="fc" id="L5374">      break;</span>
      }
    case EXTEND:{
<span class="fc" id="L5377">      r = ExtendRule(localVar, c);</span>
<span class="fc" id="L5378">      break;</span>
      }
    default:
<span class="nc" id="L5381">      jj_la1[130] = jj_gen;</span>
<span class="nc" id="L5382">      jj_consume_token(-1);</span>
<span class="nc" id="L5383">      throw new ParseException();</span>
    }
<span class="fc" id="L5385">{if (&quot;&quot; != null) return r;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

///////////////////////// BASIC RULES //////////////////////////////////////////
//OK!
  final public SkipRule SkipRule() throws ParseException {SkipRule rule;
<span class="fc" id="L5392">    jj_consume_token(Skip);</span>
<span class="fc" id="L5393">Logger.logDebug(&quot;\tskip\t\tSkipRule&quot;);</span>
<span class="fc" id="L5394">    rule = rulesPack.getBasicTransitionRules().createSkipRule();</span>
<span class="fc" id="L5395">    {if (&quot;&quot; != null) return rule;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

/* build an updateRule*/
<span class="fc" id="L5400">  final public UpdateRule UpdateRule(HashMap localVar, RuleDeclaration c) throws ParseException {Term loc = null;</span>
  Term updatingT;
<span class="fc" id="L5402">Logger.logDebug(&quot;\t\t\tUpdateRule beginning&quot;);</span>
    //create the object
<span class="fc" id="L5404">    UpdateRule rule = rulesPack.getBasicTransitionRules().createUpdateRule();</span>
<span class="pc bpc" id="L5405" title="2 of 5 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case ID_FUNCTION:{
<span class="fc" id="L5407">      loc = LocationTerm(localVar, false);</span>
//set the reference to the location to be updated
<span class="fc" id="L5409">      rule.setLocation(loc);</span>
<span class="fc" id="L5410">      break;</span>
      }
    case ID_VARIABLE:{
<span class="fc" id="L5413">      loc = VariableTerm(localVar, false);</span>
//set the reference to the variable
<span class="fc" id="L5415">      VariableTerm locVar = (VariableTerm) loc;</span>
<span class="fc" id="L5416">      rule.setLocation(locVar);</span>
      // check and update the variable kind
<span class="fc bfc" id="L5418" title="All 2 branches covered.">      if (locVar.getKind() == VariableKind.LOGICAL_VAR)</span>
      {
<span class="fc" id="L5420">        locVar.setKind(VariableKind.LOCATION_VAR);</span>
<span class="fc" id="L5421">        Logger.logDebug(&quot;\t\t\t&quot; + locVar.getName() + &quot; updated: TD=&quot; + locVar.getDomain().getName() + &quot;, kind=&quot; + locVar.getKind().toString());</span>
      }
<span class="pc bpc" id="L5423" title="1 of 2 branches missed.">      else if (locVar.getKind() == VariableKind.RULE_VAR) throw new ParseException(&quot;Error: In an Updating rule, the variable to update must be a location variable, not a rule variable. &quot;);</span>
      break;
      }
    default:
<span class="nc" id="L5427">      jj_la1[131] = jj_gen;</span>
<span class="nc" id="L5428">      jj_consume_token(-1);</span>
<span class="nc" id="L5429">      throw new ParseException();</span>
    }
<span class="fc" id="L5431">    jj_consume_token(128);</span>
<span class="fc" id="L5432">Logger.logDebug(&quot;\t:=&quot;);</span>
<span class="fc" id="L5433">    updatingT = TermForUpdateRule(localVar, false, c, loc.getDomain());</span>
<span class="pc bpc" id="L5434" title="2 of 4 branches missed.">assert updatingT != null;</span>
    //set the references
<span class="fc" id="L5436">    rule.setUpdatingTerm(updatingT);</span>
    // OCL check R1
    //NEW by Patrizia to allow result:=... to pass constraint R1
    //****
<span class="pc bpc" id="L5440" title="1 of 6 branches missed.">    if (loc != null &amp;&amp; (loc instanceof LocationTerm) &amp;&amp; ((LocationTerm) loc).getFunction().getName().equals(&quot;result&quot;))</span>
    {
<span class="fc" id="L5442">      rule.getLocation().setDomain(rule.getUpdatingTerm().getDomain());</span>
<span class="fc" id="L5443">      Logger.logDebug(&quot;\t\t\t Location term \&quot;result\&quot; updated: TD=&quot; + rule.getUpdatingTerm().getDomain().getName());</span>
    }
    //****
<span class="pc bpc" id="L5446" title="1 of 2 branches missed.">    if (!OCL_Checker.checkUpdateRule(rule)) throw new ParseException(OCL_Checker.getMsgErr() + &quot;\n       At the application of the update-rule.\n&quot; + c);</span>
<span class="fc" id="L5447">    Logger.logDebug(&quot;\t\t\tUpdateRule end&quot;);</span>
<span class="fc" id="L5448">    {if (&quot;&quot; != null) return rule;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

//OK (a parte controllare il metamodello)
  final public BlockRule BlockRule(HashMap localVar, RuleDeclaration c) throws ParseException {Rule r;
<span class="fc" id="L5454">    jj_consume_token(PAR);</span>
<span class="fc" id="L5455">Logger.logDebug(&quot;\tpar\t\tBlockRule beginning&quot;);</span>
<span class="fc" id="L5456">    BlockRule rule = rulesPack.getBasicTransitionRules().createBlockRule();</span>
<span class="fc" id="L5457">    List &lt; Rule &gt; rulesList = rule.getRules();</span>
<span class="fc" id="L5458">    r = Rule(localVar, c);</span>
//set the reference
<span class="fc" id="L5460">    rulesList.add(r);</span>
    label_48:
    while (true) {
<span class="fc" id="L5463">      r = Rule(localVar, c);</span>
//set the reference
<span class="fc" id="L5465">      rulesList.add(r);</span>
<span class="fc bfc" id="L5466" title="All 4 branches covered.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case DYNAMIC:
      case IF:
      case SWITCH:
      case LET:
      case FORALL:
      case Skip:
      case PAR:
      case CHOOSE:
      case EXTEND:
      case seq:
      case ITERATE:
      case LOCAL:
      case WHILE:
      case WHILEREC:
      case ID_VARIABLE:
      case ID_RULE:
      case ID_FUNCTION:{
<span class="fc" id="L5484">        break;</span>
        }
      default:
<span class="fc" id="L5487">        jj_la1[132] = jj_gen;</span>
<span class="fc" id="L5488">        break label_48;</span>
      }
    }
<span class="fc" id="L5491">    jj_consume_token(ENDPAR);</span>
<span class="fc" id="L5492">Logger.logDebug(&quot;\tendpar\t\tBlockRule end\n&quot;);</span>
<span class="fc" id="L5493">    {if (&quot;&quot; != null) return rule;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

//OK!
  final public ConditionalRule ConditionalRule(HashMap localVar, RuleDeclaration c) throws ParseException {Rule thenR, elseR;
  Term guard;
<span class="fc" id="L5500">    jj_consume_token(IF);</span>
<span class="fc" id="L5501">Logger.logDebug(&quot;\tif\t\tConditionalRule beginning&quot;);</span>
<span class="fc" id="L5502">    guard = Term(localVar, false, c);</span>
<span class="fc" id="L5503">    jj_consume_token(THEN);</span>
<span class="fc" id="L5504">Logger.logDebug(&quot;\tthen&quot;);</span>
<span class="fc" id="L5505">    thenR = Rule(localVar, c);</span>
<span class="fc" id="L5506">ConditionalRule rule = rulesPack.getBasicTransitionRules().createConditionalRule();</span>
    //set references
<span class="fc" id="L5508">    rule.setGuard(guard);</span>
<span class="fc" id="L5509">    rule.setThenRule(thenR);</span>
<span class="fc bfc" id="L5510" title="All 4 branches covered.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case ELSE:{
<span class="fc" id="L5512">      jj_consume_token(ELSE);</span>
<span class="fc" id="L5513">Logger.logDebug(&quot;\telse&quot;);</span>
<span class="fc" id="L5514">      elseR = Rule(localVar, c);</span>
//set the reference
<span class="fc" id="L5516">      rule.setElseRule(elseR);</span>
<span class="fc" id="L5517">      break;</span>
      }
    default:
<span class="fc" id="L5520">      jj_la1[133] = jj_gen;</span>
      ;
    }
<span class="fc" id="L5523">    jj_consume_token(ENDIF);</span>
//(OCL constraints 1) check if the guard TypeDomain is the Boolean domain
<span class="pc bpc" id="L5525" title="1 of 2 branches missed.">    if (!OCL_Checker.isBoolean(guard))</span>
    {
      //PA 31 gen 2011. commentato logger ed introdotta ParseException
      //Logger.logErr(&quot;Error: In a conditional rule the type-domain associated to the term after \&quot;if\&quot; must be the Boolean domain.&quot;);
<span class="nc" id="L5529">      throw new ParseException(&quot;Error: In a conditional rule the type-domain associated to the term after \&quot;if\&quot; must be the Boolean domain.&quot;);</span>
    }
<span class="fc" id="L5531">    Logger.logDebug(&quot;\tendif\t\tConditionalRule end&quot;);</span>
<span class="fc" id="L5532">    {if (&quot;&quot; != null) return rule;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

//NEW by Patrizia Added ranges. Please don't touch!
  final public ChooseRule ChooseRule(HashMap localVar, RuleDeclaration c) throws ParseException {VariableTerm variable;
  Term inTerm, guard;
  Rule doRule, ifnone;
<span class="fc" id="L5540">    jj_consume_token(CHOOSE);</span>
<span class="fc" id="L5541">Logger.logDebug(&quot;\tchoose\t\tChooseRule beginning&quot;);</span>
<span class="fc" id="L5542">    ChooseRule rule = rulesPack.getBasicTransitionRules().createChooseRule();</span>
<span class="fc" id="L5543">    List &lt; Term &gt; rangeList = rule.getRanges();</span>
    //check if the next variable is already used (look for it in the localVar HashMap)
<span class="fc" id="L5545">    String nextVar = getToken(1).image;</span>
<span class="pc bpc" id="L5546" title="1 of 2 branches missed.">    if (localVar.get(nextVar) != null) throw new ParseException(&quot;Error: The variable &quot; + nextVar + &quot; cannot be bound to a value in the ChooseRule. It is already used.&quot;);</span>
<span class="fc" id="L5547">    variable = VariableTerm(localVar, true);</span>
<span class="fc" id="L5548">    jj_consume_token(IN);</span>
<span class="fc" id="L5549">Logger.logDebug(&quot;\tin&quot;);</span>
<span class="fc" id="L5550">    inTerm = Term(localVar, false, c);</span>
//set the reference to the variable
<span class="fc" id="L5552">    Collection variableList = rule.getVariable();</span>
<span class="fc" id="L5553">    variableList.add(variable);</span>
    //check constraint R7
<span class="pc bpc" id="L5555" title="1 of 2 branches missed.">    if (!(OCL_Checker.getTypeDomain(inTerm.getDomain()) instanceof PowersetDomain)) throw new ParseException(&quot;Error: The type-domain of terms after \&quot;in\&quot;  must be a power set domain \n&quot; + &quot;       At a ChooseRule&quot;);</span>
    //update variable features
<span class="fc" id="L5557">    Utility.updateVariable(variable, inTerm);</span>
<span class="fc" id="L5558">    Logger.logDebug(&quot;\t\t\t&quot; + variable.getName() + &quot; updated: D=&quot; + variable.getDomain().getName() + &quot;, kind=&quot; + variable.getKind().toString());</span>
    //set the reference to the variable range
<span class="fc" id="L5560">    rangeList.add(inTerm);</span>
    //Constraints R10, R8 granted for construction

    label_49:
    while (true) {
<span class="fc bfc" id="L5565" title="All 4 branches covered.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case 116:{
<span class="fc" id="L5567">        break;</span>
        }
      default:
<span class="fc" id="L5570">        jj_la1[134] = jj_gen;</span>
<span class="fc" id="L5571">        break label_49;</span>
      }
<span class="fc" id="L5573">      jj_consume_token(116);</span>
//check if the next variable is already used (look for it in the localVar HashMap)
<span class="fc" id="L5575">      nextVar = getToken(1).image;</span>
<span class="pc bpc" id="L5576" title="1 of 2 branches missed.">      if (localVar.get(nextVar) != null) throw new ParseException(&quot;Error: The variable &quot; + nextVar + &quot; cannot be bound to a value in the ChooseRule. It is already used.&quot;);</span>
<span class="fc" id="L5577">      variable = VariableTerm(localVar, true);</span>
<span class="fc" id="L5578">      jj_consume_token(IN);</span>
<span class="fc" id="L5579">Logger.logDebug(&quot;\tin&quot;);</span>
<span class="fc" id="L5580">      inTerm = Term(localVar, false, c);</span>
//set the reference to the variable
<span class="fc" id="L5582">      variableList.add(variable);</span>
<span class="pc bpc" id="L5583" title="1 of 2 branches missed.">      if (!(OCL_Checker.getTypeDomain(inTerm.getDomain()) instanceof PowersetDomain)) throw new ParseException(&quot;Error: The type-domain of terms after \&quot;in\&quot;  must be a power set domain \n&quot; + &quot;       At a ChooseRule&quot;);</span>
      //update variable features
<span class="fc" id="L5585">      Utility.updateVariable(variable, inTerm);</span>
<span class="fc" id="L5586">      Logger.logDebug(&quot;\t\t\t&quot; + variable.getName() + &quot; updated: TD=&quot; + variable.getDomain().getName() + &quot;, kind=&quot; + variable.getKind().toString());</span>
      //set the reference to the variable range
<span class="fc" id="L5588">      rangeList.add(inTerm);</span>
      //Constraints R10, R8 granted for construction

    }
<span class="fc" id="L5592">    jj_consume_token(WITH);</span>
<span class="fc" id="L5593">Logger.logDebug(&quot;\twith&quot;);</span>
<span class="fc" id="L5594">    guard = Term(localVar, false, c);</span>
//set the reference to the guard
<span class="fc" id="L5596">    rule.setGuard(guard);</span>
    //Check constraint R9
<span class="pc bpc" id="L5598" title="1 of 2 branches missed.">    if (!OCL_Checker.isBoolean(guard))</span>
    {
<span class="nc" id="L5600">      Logger.logErr(&quot;Error: In a ChooseRule the type-domain associated to the term after \&quot;with\&quot; must be the Boolean domain&quot;);</span>
    }
<span class="fc" id="L5602">    jj_consume_token(DO);</span>
<span class="fc" id="L5603">Logger.logDebug(&quot;\tdo&quot;);</span>
<span class="fc" id="L5604">    doRule = Rule(localVar, c);</span>
//set the reference to the body rule
<span class="fc" id="L5606">    rule.setDoRule(doRule);</span>
<span class="fc bfc" id="L5607" title="All 4 branches covered.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case IFNONE:{
<span class="fc" id="L5609">      jj_consume_token(IFNONE);</span>
<span class="fc" id="L5610">Logger.logDebug(&quot;\tifnone&quot;);</span>
<span class="fc" id="L5611">      ifnone = Rule(localVar, c);</span>
//set the reference to the ifnone rule
<span class="fc" id="L5613">      rule.setIfnone(ifnone);</span>
<span class="fc" id="L5614">      break;</span>
      }
    default:
<span class="fc" id="L5617">      jj_la1[135] = jj_gen;</span>
      ;
    }
<span class="fc" id="L5620">Logger.logDebug(&quot;\t\t\tChooseRule end&quot;);</span>
<span class="fc" id="L5621">    {if (&quot;&quot; != null) return rule;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

//NEW by Patrizia Added ranges. Please don't touch!
  final public ForallRule ForallRule(HashMap localVar, RuleDeclaration c) throws ParseException {VariableTerm variable;
  Term inTerm, guard;
  Rule doRule;
<span class="fc" id="L5629">    jj_consume_token(FORALL);</span>
<span class="fc" id="L5630">Logger.logDebug(&quot;\tforall\t\tForallRule beginning&quot;);</span>
<span class="fc" id="L5631">    ForallRule rule = rulesPack.getBasicTransitionRules().createForallRule();</span>
<span class="fc" id="L5632">    List &lt; Term &gt; rangeList = rule.getRanges();</span>
    //check if the next variable is already used (look for it in the localVar HashMap)
<span class="fc" id="L5634">    String nextVar = getToken(1).image;</span>
<span class="pc bpc" id="L5635" title="1 of 2 branches missed.">    if (localVar.get(nextVar) != null) throw new ParseException(&quot;Error: The variable &quot; + nextVar + &quot; cannot be bound to a value in the ForallRule. It is already used.&quot;);</span>
<span class="fc" id="L5636">    variable = VariableTerm(localVar, true);</span>
<span class="fc" id="L5637">    jj_consume_token(IN);</span>
<span class="fc" id="L5638">Logger.logDebug(&quot;\tin&quot;);</span>
<span class="fc" id="L5639">    inTerm = Term(localVar, false, c);</span>
//set the reference to the variable
<span class="fc" id="L5641">    Collection variableList = rule.getVariable();</span>
<span class="fc" id="L5642">    variableList.add(variable);</span>
    //check constraint 1 (part of it is granted for construction)
<span class="pc bpc" id="L5644" title="1 of 2 branches missed.">    if (!(inTerm.getDomain() instanceof PowersetDomain)) throw new ParseException(&quot;Error: The type-domain of terms after \&quot;in\&quot;  must be a power set domain \n&quot; + &quot;       At a ForallRule&quot;);</span>
    //update variable features
<span class="fc" id="L5646">    Utility.updateVariable(variable, inTerm);</span>
<span class="fc" id="L5647">    Logger.logDebug(&quot;\t\t\t&quot; + variable.getName() + &quot; updated: TD=&quot; + variable.getDomain().getName() + &quot;, kind=&quot; + variable.getKind().toString());</span>
    //set the reference to the variable range
<span class="fc" id="L5649">    rangeList.add(inTerm);</span>
    label_50:
    while (true) {
<span class="fc bfc" id="L5652" title="All 4 branches covered.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case 116:{
<span class="fc" id="L5654">        break;</span>
        }
      default:
<span class="fc" id="L5657">        jj_la1[136] = jj_gen;</span>
<span class="fc" id="L5658">        break label_50;</span>
      }
<span class="fc" id="L5660">      jj_consume_token(116);</span>
//check if the next variable is already used (look for it in the localVar HashMap)
<span class="fc" id="L5662">      nextVar = getToken(1).image;</span>
<span class="pc bpc" id="L5663" title="1 of 2 branches missed.">      if (localVar.get(nextVar) != null) throw new ParseException(&quot;Error: The variable &quot; + nextVar + &quot; cannot be bound to a value in the ForallRule. It is already used.&quot;);</span>
<span class="fc" id="L5664">      variable = VariableTerm(localVar, true);</span>
<span class="fc" id="L5665">      jj_consume_token(IN);</span>
<span class="fc" id="L5666">Logger.logDebug(&quot;\tin&quot;);</span>
<span class="fc" id="L5667">      inTerm = Term(localVar, false, c);</span>
//set the reference to the variable
<span class="fc" id="L5669">      variableList.add(variable);</span>
      //check constraint 1 (part of it is granted for construction)
<span class="pc bpc" id="L5671" title="1 of 2 branches missed.">      if (!(inTerm.getDomain() instanceof PowersetDomain)) throw new ParseException(&quot;Error: The type-domain of terms after \&quot;in\&quot;  must be a power set domain \n&quot; + &quot;       At a ForallRule&quot;);</span>
      //update variable features
<span class="fc" id="L5673">      Utility.updateVariable(variable, inTerm);</span>
<span class="fc" id="L5674">      Logger.logDebug(&quot;\t\t\t&quot; + variable.getName() + &quot; updated: TD=&quot; + variable.getDomain().getName() + &quot;, kind=&quot; + variable.getKind().toString());</span>
      //set the reference to the variable range
<span class="fc" id="L5676">      rangeList.add(inTerm);</span>
    }
<span class="fc" id="L5678">guard = termsPack.getBasicTerms().createBooleanTerm(true);</span>
<span class="pc bpc" id="L5679" title="1 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case WITH:{
<span class="fc" id="L5681">      jj_consume_token(WITH);</span>
<span class="fc" id="L5682">Logger.logDebug(&quot;\twith&quot;);</span>
<span class="fc" id="L5683">      guard = Term(localVar, false, c);</span>
//(OCL constraints 2) check if the guard TypeDomain is the Boolean domain
<span class="pc bpc" id="L5685" title="1 of 2 branches missed.">      if (!OCL_Checker.isBoolean(guard))</span>
      {
<span class="nc" id="L5687">        Logger.logErr(&quot;Error: In a ForallRule the type-domain associated to the term after \&quot;with\&quot; must be the Boolean domain&quot;);</span>
      }
      break;
      }
    default:
<span class="fc" id="L5692">      jj_la1[137] = jj_gen;</span>
      ;
    }
//set the reference
<span class="fc" id="L5696">    rule.setGuard(guard);</span>
<span class="fc" id="L5697">    jj_consume_token(DO);</span>
<span class="fc" id="L5698">Logger.logDebug(&quot;\tdo&quot;);</span>
<span class="fc" id="L5699">    doRule = Rule(localVar, c);</span>
//set the reference
<span class="fc" id="L5701">    rule.setDoRule(doRule);</span>
<span class="fc" id="L5702">    Logger.logDebug(&quot;\t\t\tForallRule end&quot;);</span>
<span class="fc" id="L5703">    {if (&quot;&quot; != null) return rule;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

// DA CONTROLLARE IL METAMODELLO
  final public LetRule LetRule(HashMap localVar, RuleDeclaration c) throws ParseException {VariableTerm variable;
  Term initExp;
  Rule inRule;
<span class="fc" id="L5711">    jj_consume_token(LET);</span>
<span class="fc" id="L5712">    jj_consume_token(115);</span>
<span class="fc" id="L5713">Logger.logDebug(&quot;\tlet(\t\tLetRule beginning&quot;);</span>
    //check if the next variable is already used (look for it in the localVar HashMap)
<span class="fc" id="L5715">    String nextVar = getToken(1).image;</span>
<span class="pc bpc" id="L5716" title="1 of 2 branches missed.">    if (localVar.get(nextVar) != null) throw new ParseException(&quot;Error: The variable &quot; + nextVar + &quot; cannot be bound to a value in the LetRule. It is already used.&quot;);</span>
<span class="fc" id="L5717">    variable = VariableTerm(localVar, true);</span>
<span class="fc" id="L5718">    jj_consume_token(EQ);</span>
<span class="fc" id="L5719">Logger.logDebug(&quot;\t=&quot;);</span>
<span class="fc" id="L5720">    initExp = Term(localVar, false, c);</span>
<span class="fc" id="L5721">LetRule rule = rulesPack.getBasicTransitionRules().createLetRule();</span>
<span class="fc" id="L5722">    List &lt; VariableTerm &gt; variableList = rule.getVariable();</span>
<span class="fc" id="L5723">    List &lt; Term &gt; initExpList = rule.getInitExpression();</span>
    Domain varD;
    //set variable TypeDomain
<span class="fc" id="L5726">    varD = initExp.getDomain();</span>
<span class="fc" id="L5727">    variable.setDomain(varD);</span>
    //set variable kind
<span class="pc bpc" id="L5729" title="1 of 2 branches missed.">    if (varD instanceof RuleDomain) variable.setKind(VariableKind.RULE_VAR);</span>
    //set references
<span class="fc" id="L5731">    variableList.add(variable);</span>
<span class="fc" id="L5732">    initExpList.add(initExp);</span>
<span class="fc" id="L5733">    Logger.logDebug(&quot;\t\t\t&quot; + variable.getName() + &quot; updated: D=&quot; + variable.getDomain().getName() + &quot;, kind=&quot; + variable.getKind().toString());</span>
    label_51:
    while (true) {
<span class="fc bfc" id="L5736" title="All 4 branches covered.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case 116:{
<span class="fc" id="L5738">        break;</span>
        }
      default:
<span class="fc" id="L5741">        jj_la1[138] = jj_gen;</span>
<span class="fc" id="L5742">        break label_51;</span>
      }
<span class="fc" id="L5744">      jj_consume_token(116);</span>
<span class="fc" id="L5745">nextVar = getToken(1).image;</span>
<span class="pc bpc" id="L5746" title="1 of 2 branches missed.">      if (localVar.get(nextVar) != null) throw new ParseException(&quot;Error: The variable &quot; + nextVar + &quot; cannot be bound to a value in the LetRule. It is already used.&quot;);</span>
<span class="fc" id="L5747">      variable = VariableTerm(localVar, true);</span>
<span class="fc" id="L5748">      jj_consume_token(EQ);</span>
<span class="fc" id="L5749">Logger.logDebug(&quot;\t=&quot;);</span>
<span class="fc" id="L5750">      initExp = Term(localVar, false, c);</span>
// set variable TypeDomain
<span class="fc" id="L5752">      varD = initExp.getDomain();</span>
<span class="fc" id="L5753">      variable.setDomain(varD);</span>
      // set variable kind
<span class="pc bpc" id="L5755" title="1 of 2 branches missed.">      if (varD instanceof RuleDomain) variable.setKind(VariableKind.RULE_VAR);</span>
      //set references
<span class="fc" id="L5757">      variableList.add(variable);</span>
<span class="fc" id="L5758">      initExpList.add(initExp);</span>
<span class="fc" id="L5759">      Logger.logDebug(&quot;\t\t\t&quot; + variable.getName() + &quot; updated: D=&quot; + variable.getDomain().getName() + &quot;, kind=&quot; + variable.getKind().toString());</span>
    }
<span class="fc" id="L5761">    jj_consume_token(117);</span>
<span class="fc" id="L5762">Logger.logDebug(&quot;\t)&quot;);</span>
<span class="fc" id="L5763">    jj_consume_token(IN);</span>
<span class="fc" id="L5764">Logger.logDebug(&quot;\tin&quot;);</span>
<span class="fc" id="L5765">    inRule = Rule(localVar, c);</span>
//set the reference
<span class="fc" id="L5767">    rule.setInRule(inRule);</span>
    //create the association
    //check OCL constraints
<span class="pc bpc" id="L5770" title="1 of 2 branches missed.">    if (!OCL_Checker.checkLetRule(rule)) throw new ParseException(OCL_Checker.getMsgErr() + &quot;\n       At the application of the let-rule.&quot;);</span>
<span class="fc" id="L5771">    jj_consume_token(ENDLET);</span>
<span class="fc" id="L5772">Logger.logDebug(&quot;\tendlet\t\tLetRule end&quot;);</span>
<span class="fc" id="L5773">    {if (&quot;&quot; != null) return rule;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

//Ok!
/*
* modified 10 Jan 2008 by acarioni
*
*/
  final public MacroCallRule MacroCallRule(HashMap localVar, RuleDeclaration c) throws ParseException {String ruleName;
  Term par;
<span class="fc" id="L5784">    ruleName = ID_RULE();</span>
<span class="fc" id="L5785">Logger.logDebug(&quot;\t&quot; + ruleName + &quot;\t\tMacroCallRule beginning&quot;);</span>
    //create the object
<span class="fc" id="L5787">    MacroCallRule rule = rulesPack.getBasicTransitionRules().createMacroCallRule();</span>
<span class="fc" id="L5788">    List &lt; Term &gt; actualParamList = rule.getParameters();</span>
<span class="fc" id="L5789">    jj_consume_token(124);</span>
<span class="fc" id="L5790">Logger.logDebug(&quot;\t[&quot;);</span>
<span class="fc bfc" id="L5791" title="All 2 branches covered.">    if (jj_2_43(1)) {</span>
<span class="fc" id="L5792">      par = Term(localVar, false, c);</span>
<span class="fc" id="L5793">actualParamList.add(par);</span>
      label_52:
      while (true) {
<span class="fc bfc" id="L5796" title="All 4 branches covered.">        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
        case 116:{
<span class="fc" id="L5798">          break;</span>
          }
        default:
<span class="fc" id="L5801">          jj_la1[139] = jj_gen;</span>
<span class="fc" id="L5802">          break label_52;</span>
        }
<span class="fc" id="L5804">        jj_consume_token(116);</span>
<span class="fc" id="L5805">        par = Term(localVar, false, c);</span>
<span class="fc" id="L5806">actualParamList.add(par);</span>
      }
    } else {
      ;
    }
<span class="fc" id="L5811">    jj_consume_token(125);</span>
<span class="fc" id="L5812">Logger.logDebug(&quot;\t]\t\tMacroCallRule end&quot;);</span>
//look for the rule in the rule HashMap
<span class="fc" id="L5814">    RuleDeclaration r = Utility.getRuleByNameTerm(declared_Rules, ruleName, actualParamList);</span>
    //PA: 15/10/2011
    /*List&lt;Domain&gt; doms = Utility.buildDomains(actualParamList);
		List&lt;VariableTerm&gt; list = r.getVariable();
		Iterator&lt;VariableTerm&gt; it = list.iterator();
		HashMap&lt;String, Domain&gt; genericDomValue =  new HashMap&lt;String, Domain&gt;();		
		for(Domain domain: doms)	{
		  Domain other = it.next().getDomain();
		  System.out.println(domain.getName() + &quot; &quot; + other.getName() +&quot; &quot; +OCL_Checker.applicable(domain, other));
		  System.out.println(other.getName() + &quot; &quot; + domain.getName() +&quot; &quot; +OCL_Checker.applicable(other, domain));
		  
		  //if(!OCL_Checker.compareFixingAnyDomain(other, domain, genericDomValue))
		  if(!OCL_Checker.applicable(domain, other))
		  {
		    throw new ParseException(&quot;Error: &quot;);
		  }
		}*/
    //PA: 15/10/2011 - end
    // added 10 Jan 2008 by acarioni
<span class="pc bpc" id="L5833" title="1 of 2 branches missed.">    if (r == null)</span>
    {
<span class="nc" id="L5835">      List &lt; Domain &gt; domains = Utility.buildDomains(actualParamList);</span>
<span class="nc" id="L5836">      Logger.logErr(&quot;rules already declared: &quot; + Utility.toString(declared_Rules));</span>
<span class="nc" id="L5837">      throw new ParseException(&quot;Error: Unresolved reference to &quot; + ruleName + Utility.toString(domains));</span>
    }
    //******* NEW by Patrizia to manage recursion
    // NON FUNZIONA PIU' if (c!= null &amp;&amp; ruleName.equals(c.getName()))
    //         	   r = c;
<span class="pc bpc" id="L5842" title="1 of 2 branches missed.">    if (!(r instanceof MacroDeclaration)) throw new ParseException(&quot;Error: The rule &quot; + ruleName + &quot; is not a macro&quot;);</span>
    //set reference
<span class="fc" id="L5844">    rule.setCalledMacro((MacroDeclaration) r);</span>
    //PA: 15/10/2011 - start
<span class="fc" id="L5846">    StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L5847">    sb.append(&quot;Macro call rule &quot; + rule.getCalledMacro().getName() + &quot; has been associated to the rule &quot; + r.getName() + &quot;[&quot;);</span>
<span class="fc bfc" id="L5848" title="All 2 branches covered.">    for (VariableTerm v : r.getVariable())</span>
    {
<span class="fc" id="L5850">      sb.append(v.getDomain().getName());</span>
<span class="fc" id="L5851">    }</span>
<span class="fc" id="L5852">    sb.append(&quot;]&quot;);</span>
<span class="fc" id="L5853">    Logger.logDebug(sb.toString());</span>
    //PA: 15/10/2011 - end
    //check OCL constraints
<span class="pc bpc" id="L5856" title="1 of 2 branches missed.">    if (!OCL_Checker.checkMacroCallRule(rule)) throw new ParseException(OCL_Checker.getMsgErr() + &quot;\n       At the application of the rule &quot; + ruleName + &quot; as a macro.&quot;);</span>
<span class="fc" id="L5857">    Logger.logDebug(&quot;The macro call rule respects the OCL constraints.&quot;);</span>
<span class="fc" id="L5858">    {if (&quot;&quot; != null) return rule;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

//OK!
  final public ExtendRule ExtendRule(HashMap localVar, RuleDeclaration c) throws ParseException {String id_dom;
  VariableTerm v;
  Rule doRule;
<span class="fc" id="L5866">    jj_consume_token(EXTEND);</span>
<span class="fc" id="L5867">Logger.logDebug(&quot;\textend\t\tExtendRule beginning&quot;);</span>
<span class="fc" id="L5868">    id_dom = ID_DOMAIN();</span>
<span class="fc" id="L5869">ExtendRule rule = rulesPack.getBasicTransitionRules().createExtendRule();</span>
<span class="fc" id="L5870">    Domain dom = (Domain) declared_Dom.get(id_dom);</span>
<span class="fc" id="L5871">    rule.setExtendedDomain(dom);</span>
    //XAExtendRuleExtendedDomain a_ExtendR_Dom= rulesPack.getBasicTransitionRules().getAExtendRuleExtendedDomain();
    //Xa_ExtendR_Dom.add(rule,(AbstractTd)dom);

<span class="fc" id="L5875">    jj_consume_token(WITH);</span>
<span class="fc" id="L5876">Logger.logDebug(&quot;\twith&quot;);</span>
<span class="fc" id="L5877">String nextVar = getToken(1).image;</span>
<span class="pc bpc" id="L5878" title="1 of 2 branches missed.">    if (localVar.get(nextVar) != null) throw new ParseException(&quot;Error: The variable &quot; + nextVar + &quot; cannot be bound to a value in the ExtendRule. It is already used.&quot;);</span>
<span class="fc" id="L5879">    v = VariableTerm(localVar, true);</span>
<span class="fc" id="L5880">Collection VariablesList = rule.getBoundVar();</span>
<span class="fc" id="L5881">    VariablesList.add(v);</span>
    //XAExtendRuleBoundVar a_ExtendR_Var= rulesPack.getBasicTransitionRules().getAExtendRuleBoundVar();
    //Xa_ExtendR_Var.add(rule,v);
<span class="fc" id="L5884">    ReserveDomain Reservedom = (ReserveDomain) Utility.getPredefinedAbstractDomain(domainsFactory, &quot;Reserve&quot;);</span>
<span class="pc bpc" id="L5885" title="1 of 2 branches missed.">    if (Reservedom == null) throw new ParseException(&quot;Error: The domain Reserve has not been declared.&quot;);</span>
<span class="fc" id="L5886">    Utility.updateVariable(v, dom);</span>
    //constraint R6 is granted for construction
<span class="fc" id="L5888">    Logger.logDebug(&quot;\t\t\tTD assigned to &quot; + v.getName() + &quot;: &quot; + v.getDomain().getName());</span>
    label_53:
    while (true) {
<span class="pc bpc" id="L5891" title="1 of 4 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case 116:{
<span class="fc" id="L5893">        break;</span>
        }
      default:
<span class="fc" id="L5896">        jj_la1[140] = jj_gen;</span>
<span class="fc" id="L5897">        break label_53;</span>
      }
<span class="fc" id="L5899">      jj_consume_token(116);</span>
<span class="fc" id="L5900">nextVar = getToken(1).image;</span>
<span class="pc bpc" id="L5901" title="1 of 2 branches missed.">      if (localVar.get(nextVar) != null) throw new ParseException(&quot;Error: The variable &quot; + nextVar + &quot; cannot be bound to a value in the ExtendRule. It is already used.&quot;);</span>
<span class="fc" id="L5902">      v = VariableTerm(localVar, true);</span>
<span class="fc" id="L5903">VariablesList.add(v);</span>
      //Xa_ExtendR_Var.add(rule,v);
<span class="fc" id="L5905">      Utility.updateVariable(v, dom);</span>
      //constraint R6 is granted for construction
<span class="fc" id="L5907">      Logger.logDebug(&quot;\t\t\tTD assigned to &quot; + v.getName() + &quot;: &quot; + v.getDomain().getName());</span>
    }
<span class="fc" id="L5909">    jj_consume_token(DO);</span>
<span class="fc" id="L5910">Logger.logDebug(&quot;\tdo&quot;);</span>
<span class="fc" id="L5911">    doRule = Rule(localVar, c);</span>
<span class="fc" id="L5912">rule.setDoRule(doRule);</span>
    //X AExtendRuleDoRule a_ExtendR_DoRule= rulesPack.getBasicTransitionRules().getAExtendRuleDoRule();
    //X a_ExtendR_DoRule.add(rule,doRule);
    //check OCL constraints
<span class="pc bpc" id="L5916" title="1 of 2 branches missed.">    if (!OCL_Checker.checkExtendRule(rule)) throw new ParseException(OCL_Checker.getMsgErr() + &quot;\n       At the application of the extend rule.&quot;);</span>
<span class="fc" id="L5917">    Logger.logDebug(&quot;\t\t\tExtendRule end&quot;);</span>
<span class="fc" id="L5918">    {if (&quot;&quot; != null) return rule;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

/////////////////////////////////////////////////////////////////////////
  final public TurboRule TurboRule(HashMap localVar, RuleDeclaration c) throws ParseException {TurboRule result;
<span class="pc bpc" id="L5924" title="3 of 7 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case seq:{
<span class="fc" id="L5926">      result = SeqRule(localVar, c);</span>
<span class="fc" id="L5927">      break;</span>
      }
    case ITERATE:{
<span class="nc" id="L5930">      result = IterateRule(localVar, c);</span>
<span class="nc" id="L5931">      break;</span>
      }
    case ID_RULE:{
<span class="fc" id="L5934">      result = TurboCallRule(localVar, c);</span>
<span class="fc" id="L5935">      break;</span>
      }
    case DYNAMIC:
    case LOCAL:{
<span class="fc" id="L5939">      result = TurboLocalStateRule(localVar, c);</span>
<span class="fc" id="L5940">      break;</span>
      }
    default:
<span class="nc" id="L5943">      jj_la1[141] = jj_gen;</span>
<span class="nc" id="L5944">      jj_consume_token(-1);</span>
<span class="nc" id="L5945">      throw new ParseException();</span>
    }
<span class="fc" id="L5947">{if (&quot;&quot; != null) return result;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

///////////////// TURBO RULE /////////////////
  final public SeqRule SeqRule(HashMap localVar, RuleDeclaration c) throws ParseException {Rule r;
<span class="fc" id="L5953">    jj_consume_token(seq);</span>
<span class="fc" id="L5954">Logger.logDebug(&quot;\tseq\t\tSeqRule beginning&quot;);</span>
<span class="fc" id="L5955">    SeqRule rule = rulesPack.getTurboTransitionRules().createSeqRule();</span>
<span class="fc" id="L5956">    List &lt; Rule &gt; rulesList = rule.getRules();</span>
<span class="fc" id="L5957">    r = Rule(localVar, c);</span>
//add rules
<span class="fc" id="L5959">    rulesList.add(r);</span>
    label_54:
    while (true) {
<span class="fc" id="L5962">      r = Rule(localVar, c);</span>
//set the reference
<span class="fc" id="L5964">      rulesList.add(r);</span>
<span class="fc bfc" id="L5965" title="All 4 branches covered.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case DYNAMIC:
      case IF:
      case SWITCH:
      case LET:
      case FORALL:
      case Skip:
      case PAR:
      case CHOOSE:
      case EXTEND:
      case seq:
      case ITERATE:
      case LOCAL:
      case WHILE:
      case WHILEREC:
      case ID_VARIABLE:
      case ID_RULE:
      case ID_FUNCTION:{
<span class="fc" id="L5983">        break;</span>
        }
      default:
<span class="fc" id="L5986">        jj_la1[142] = jj_gen;</span>
<span class="fc" id="L5987">        break label_54;</span>
      }
    }
<span class="fc" id="L5990">    jj_consume_token(ENDSEQ);</span>
<span class="fc" id="L5991">Logger.logDebug(&quot;\tendseq\t\tSeqRule end&quot;);</span>
<span class="fc" id="L5992">    {if (&quot;&quot; != null) return rule;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public IterateRule IterateRule(HashMap localVar, RuleDeclaration c) throws ParseException {Rule r;
<span class="nc" id="L5997">    jj_consume_token(ITERATE);</span>
<span class="nc" id="L5998">Logger.logDebug(&quot;\titerate\t\tIterateRule beginning&quot;);</span>
<span class="nc" id="L5999">    r = Rule(localVar, c);</span>
<span class="nc" id="L6000">    jj_consume_token(ENDITERATE);</span>
<span class="nc" id="L6001">Logger.logDebug(&quot;\tenditerate\t\tIterateRule end&quot;);</span>
<span class="nc" id="L6002">IterateRule rule = rulesPack.getTurboTransitionRules().createIterateRule();</span>
    //set the reference
<span class="nc" id="L6004">    rule.setRule(r);</span>
<span class="nc" id="L6005">    {if (&quot;&quot; != null) return rule;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public TurboCallRule TurboCallRule(HashMap localVar, RuleDeclaration c) throws ParseException {String ruleName;
  Term par;
<span class="fc" id="L6011">    ruleName = ID_RULE();</span>
<span class="fc" id="L6012">Logger.logDebug(&quot;\t&quot; + ruleName + &quot;\t\tTurboCallRule beginning&quot;);</span>
<span class="pc bpc" id="L6013" title="1 of 2 branches missed.">    Logger.logDebug(&quot;\t context: &quot; + ((c == null) ? &quot;null&quot; : c.getName()));</span>
    //create the object
<span class="fc" id="L6015">    TurboCallRule rule = rulesPack.getTurboTransitionRules().createTurboCallRule();</span>
<span class="fc" id="L6016">    List &lt; Term &gt; actualParamList = rule.getParameters();</span>
<span class="fc" id="L6017">    jj_consume_token(115);</span>
<span class="fc" id="L6018">Logger.logDebug(&quot;\t(&quot;);</span>
<span class="fc bfc" id="L6019" title="All 2 branches covered.">    if (jj_2_44(1)) {</span>
<span class="fc" id="L6020">      par = Term(localVar, false, c);</span>
<span class="fc" id="L6021">actualParamList.add(par);</span>
      label_55:
      while (true) {
<span class="fc bfc" id="L6024" title="All 4 branches covered.">        switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
        case 116:{
<span class="fc" id="L6026">          break;</span>
          }
        default:
<span class="fc" id="L6029">          jj_la1[143] = jj_gen;</span>
<span class="fc" id="L6030">          break label_55;</span>
        }
<span class="fc" id="L6032">        jj_consume_token(116);</span>
<span class="fc" id="L6033">        par = Term(localVar, false, c);</span>
<span class="fc" id="L6034">actualParamList.add(par);</span>
      }
    } else {
      ;
    }
<span class="fc" id="L6039">    jj_consume_token(117);</span>
<span class="fc" id="L6040">Logger.logDebug(&quot;\t)\t\tTurboCallRule end&quot;);</span>
//look for the rule in the rule HashMap
<span class="fc" id="L6042">    RuleDeclaration r = Utility.getRuleByNameTerm(declared_Rules, ruleName, actualParamList);</span>
    //******* NEW by Patrizia to manage recursion
<span class="pc bpc" id="L6044" title="1 of 4 branches missed.">    if (c != null &amp;&amp; ruleName.equals(c.getName())) r = c;</span>
    //*************
    // added 10 Jan 2008 by acarioni
<span class="pc bpc" id="L6047" title="1 of 2 branches missed.">    if (r == null)</span>
    {
<span class="nc" id="L6049">      List &lt; Domain &gt; domains = Utility.buildDomains(actualParamList);</span>
<span class="nc" id="L6050">      Logger.logErr(&quot;rules already declared: &quot; + Utility.toString(declared_Rules));</span>
      //Logger.logErr(&quot;Asbtract domains:&quot; + Utility.toString(Utility.abstractTds.values()));
<span class="nc" id="L6052">      throw new ParseException(&quot;Error: Unresolved reference to &quot; + ruleName + Utility.toString(domains));</span>
    }
<span class="pc bpc" id="L6054" title="1 of 2 branches missed.">    if (!(r instanceof TurboDeclaration)) throw new ParseException(&quot;Error: The rule &quot; + ruleName + &quot; is not declared as turbo, but it is called as it was.&quot;);</span>
    //set reference
<span class="fc" id="L6056">    rule.setCalledRule((TurboDeclaration) r);</span>
<span class="fc bfc" id="L6057" title="All 2 branches covered.">    if (ruleName.equals(c.getName()))  //***NEW by Patrizia - in case of recursion, don't check OCL constraints</span>
<span class="fc" id="L6058">    {if (&quot;&quot; != null) return rule;}</span>
    //check OCL constraints
<span class="pc bpc" id="L6060" title="1 of 2 branches missed.">    if (!OCL_Checker.checkTurboCallRule(rule))</span>
    { //For debugging
<span class="nc" id="L6062">      Logger.logDebug(rule.getParameters().size() + &quot; &quot; + rule.getCalledRule().getArity());</span>
<span class="nc" id="L6063">      throw new ParseException(OCL_Checker.getMsgErr() + &quot;\n       At the application of the rule &quot; + ruleName + &quot; as a submachine.&quot;);</span>
    }
<span class="fc" id="L6065">    {if (&quot;&quot; != null) return rule;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public TurboReturnRule TurboReturnRule(HashMap localVar, RuleDeclaration c) throws ParseException {LocationTerm loc;
  VariableTerm locVar;
  TurboCallRule updateR;
<span class="fc" id="L6072">Logger.logDebug(&quot;\t\t\tTurboReturnRule beginning&quot;);</span>
<span class="fc" id="L6073">    TurboReturnRule rule = rulesPack.getTurboTransitionRules().createTurboReturnRule();</span>
<span class="pc bpc" id="L6074" title="2 of 5 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case ID_FUNCTION:{
<span class="fc" id="L6076">      loc = LocationTerm(localVar, false);</span>
//set the reference
<span class="fc" id="L6078">      rule.setLocation(loc);</span>
<span class="fc" id="L6079">      break;</span>
      }
    case ID_VARIABLE:{
<span class="fc" id="L6082">      locVar = VariableTerm(localVar, false);</span>
//set the reference
<span class="fc" id="L6084">      rule.setLocation(locVar);</span>
      // check and update the variable kind
<span class="pc bpc" id="L6086" title="1 of 2 branches missed.">      if (locVar.getKind() == VariableKind.LOGICAL_VAR)</span>
      {
<span class="fc" id="L6088">        locVar.setKind(VariableKind.LOCATION_VAR);</span>
<span class="fc" id="L6089">        Logger.logDebug(&quot;\t\t\t&quot; + locVar.getName() + &quot; updated: TD=&quot; + locVar.getDomain().getName() + &quot;, kind=&quot; + locVar.getKind().toString());</span>
      }
<span class="nc bnc" id="L6091" title="All 2 branches missed.">      else if (locVar.getKind() == VariableKind.RULE_VAR) throw new ParseException(&quot;Error: In a turbo-return rule, the variable to update must be a location variable, not a rule variable. &quot;);</span>
      break;
      }
    default:
<span class="nc" id="L6095">      jj_la1[144] = jj_gen;</span>
<span class="nc" id="L6096">      jj_consume_token(-1);</span>
<span class="nc" id="L6097">      throw new ParseException();</span>
    }
<span class="fc" id="L6099">    jj_consume_token(129);</span>
<span class="fc" id="L6100">Logger.logDebug(&quot;\t&lt;-&quot;);</span>
<span class="fc" id="L6101">    updateR = TurboCallRule(localVar, c);</span>
//set the references
<span class="fc" id="L6103">    rule.setUpdateRule(updateR);</span>
    // constraint 1 and 2 are granted for construction
<span class="fc" id="L6105">    Logger.logDebug(&quot;\t\t\tTurboReturnRule end&quot;);</span>
<span class="fc" id="L6106">    {if (&quot;&quot; != null) return rule;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public TurboLocalStateRule TurboLocalStateRule(HashMap localVar, RuleDeclaration c) throws ParseException {Rule init, body;
  LocalFunction localF;
<span class="fc" id="L6112">  LinkedList localFunctions = new LinkedList();</span>
<span class="fc" id="L6113">Logger.logDebug(&quot;\t\t\tTurboLocalStateRule beginning&quot;);</span>
<span class="fc" id="L6114">    Logger.logDebug(&quot;\t&quot;);</span>
<span class="fc" id="L6115">    localF = LocalFunction();</span>
<span class="fc" id="L6116">boolean inserted = Utility.insert(localF, declared_Func);</span>
<span class="pc bpc" id="L6117" title="1 of 2 branches missed.">    if (inserted) localFunctions.add(localF);</span>
<span class="nc bnc" id="L6118" title="All 2 branches missed.">    else throw new ParseException(&quot;Error: The function &quot; + localF.getName() + &quot;:&quot; + ((localF.getDomain() == null) ? &quot;&quot; : (localF.getDomain().getName() + &quot;-&gt;&quot;)) + localF.getCodomain().getName() + &quot; has been declared twice.&quot;);</span>
<span class="fc" id="L6119">    jj_consume_token(124);</span>
<span class="fc" id="L6120">Logger.logDebug(&quot;\t[&quot;);</span>
<span class="fc" id="L6121">    init = Rule(localVar, c);</span>
<span class="fc" id="L6122">    jj_consume_token(125);</span>
<span class="fc" id="L6123">Logger.logDebug(&quot;\t]&quot;);</span>
<span class="fc" id="L6124">TurboLocalStateRule rule = rulesPack.getTurboTransitionRules().createTurboLocalStateRule();</span>
<span class="fc" id="L6125">    List LocFunList = rule.getLocalFunction();</span>
<span class="fc" id="L6126">    List InitRulesList = rule.getInit();</span>
    //X ATurboLocalStateRuleInit a_TurLocStaTR_Init = rulesPack.getTurboTransitionRules().getATurboLocalStateRuleInit();
    //X ATurboLocalStateRuleLocalFunction a_TurLocStaTR_LocF = rulesPack.getTurboTransitionRules().getATurboLocalStateRuleLocalFunction();
    //set references
<span class="fc" id="L6130">    LocFunList.add(localF);</span>
<span class="fc" id="L6131">    InitRulesList.add(init);</span>
    //create associations
    //X a_TurLocStaTR_LocF.add(rule,localF);
    //X a_TurLocStaTR_Init.add(rule,init);
    //(OCL constraints 1) the dynamic functions must be local
    //if(!(localF.getKind().toString().equals(&quot;local&quot;)))
    //  throw new ParseException(&quot;Error: In a turbo rule with local state, the dynamic functions must be local.&quot;);

    label_56:
    while (true) {
<span class="pc bpc" id="L6141" title="2 of 4 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case DYNAMIC:
      case LOCAL:{
<span class="nc" id="L6144">        break;</span>
        }
      default:
<span class="fc" id="L6147">        jj_la1[145] = jj_gen;</span>
<span class="fc" id="L6148">        break label_56;</span>
      }
<span class="nc" id="L6150">Logger.logDebug(&quot;\t&quot;);</span>
<span class="nc" id="L6151">      localF = LocalFunction();</span>
<span class="nc" id="L6152">inserted = Utility.insert(localF, declared_Func);</span>
<span class="nc bnc" id="L6153" title="All 2 branches missed.">      if (inserted) localFunctions.add(localF);</span>
<span class="nc bnc" id="L6154" title="All 2 branches missed.">      else throw new ParseException(&quot;Error: The function &quot; + localF.getName() + &quot;:&quot; + ((localF.getDomain() == null) ? &quot;&quot; : (localF.getDomain().getName() + &quot;-&gt;&quot;)) + localF.getCodomain().getName() + &quot; has been declared twice.&quot;);</span>
<span class="nc" id="L6155">      jj_consume_token(124);</span>
<span class="nc" id="L6156">Logger.logDebug(&quot;\t[&quot;);</span>
<span class="nc" id="L6157">      init = Rule(localVar, c);</span>
<span class="nc" id="L6158">      jj_consume_token(125);</span>
<span class="nc" id="L6159">Logger.logDebug(&quot;\t]&quot;);</span>
//set references
<span class="nc" id="L6161">      LocFunList.add(localF);</span>
<span class="nc" id="L6162">      InitRulesList.add(init);</span>
      //create associations
      //X a_TurLocStaTR_LocF.add(rule,localF);
      //X a_TurLocStaTR_Init.add(rule,init);
      //(OCL constraints 1) the dynamic functions must be local
      //if(!(localF.getKind().toString().equals(&quot;local&quot;)))
      //   throw new ParseException(&quot;Error: In a turbo rule with local state, the dynamic functions must be local.&quot;);

    }
<span class="fc" id="L6171">    body = Rule(localVar, c);</span>
<span class="fc" id="L6172">rule.setBody(body);</span>
    //X ATurboLocalStateRuleBody a_TurLocStaTR_Body = rulesPack.getTurboTransitionRules().getATurboLocalStateRuleBody();
    //X a_TurLocStaTR_Body.add(rule,body);
    LocalFunction f;
<span class="fc bfc" id="L6176" title="All 2 branches covered.">    for (int count = 0; count &lt; localFunctions.size(); count++)</span>
    {
<span class="fc" id="L6178">      f = (LocalFunction) localFunctions.get(count);</span>
<span class="fc" id="L6179">      Utility.remove(f, declared_Func);</span>
    }
<span class="fc" id="L6181">    Logger.logDebug(&quot;\t\t\tTurboLocalStateRule end&quot;);</span>
    //Check OCL constraints
<span class="pc bpc" id="L6183" title="1 of 2 branches missed.">    if (!OCL_Checker.checkTurboLocalStateRule(rule))</span>
    {
<span class="nc" id="L6185">      Logger.logErr(OCL_Checker.getMsgErr());</span>
<span class="nc" id="L6186">      Logger.logErr(&quot;       At the TurboLocalStateRule.\n&quot;);</span>
    }
<span class="fc" id="L6188">    {if (&quot;&quot; != null) return rule;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public TryCatchRule TryCatchRule(HashMap localVar, RuleDeclaration c) throws ParseException {Rule tryR, catchR;
  Term loc;
<span class="nc" id="L6194">    jj_consume_token(TRY);</span>
<span class="nc" id="L6195">Logger.logDebug(&quot;\ttry\t\tTryCatchRule beginning&quot;);</span>
<span class="nc" id="L6196">    tryR = Rule(localVar, c);</span>
//create the object
<span class="nc" id="L6198">    TryCatchRule rule = rulesPack.getTurboTransitionRules().createTryCatchRule();</span>
    //set the reference
<span class="nc" id="L6200">    rule.setTryRule(tryR);</span>
    //create the association
    //X ATryCatchRuleTryRule a_TryCatchR_TryR = rulesPack.getTurboTransitionRules().getATryCatchRuleTryRule();
    //X a_TryCatchR_TryR.add(rule,tryR);
<span class="nc" id="L6204">    Collection locColl = rule.getLocation();</span>
    //X ATryCatchRuleLocation a_TryCatchR_Loc = rulesPack.getTurboTransitionRules().getATryCatchRuleLocation();
    //X ATryCatchRuleLocationVar a_TryCatchR_LocVar = rulesPack.getTurboTransitionRules().getATryCatchRuleLocationVar();

<span class="nc" id="L6208">    jj_consume_token(CATCH);</span>
<span class="nc" id="L6209">Logger.logDebug(&quot;\tcatch&quot;);</span>
<span class="nc" id="L6210">    loc = Term(localVar, false, c);</span>
//add location term to collection
<span class="nc" id="L6212">      locColl.add(loc);</span>
      //create the association
      //X a_TryCatchR_Loc.add(rule,loc);
      // check and update the variable kind
<span class="nc bnc" id="L6216" title="All 2 branches missed.">      if (loc instanceof VariableTerm)</span>
      {
<span class="nc" id="L6218">        VariableTerm locVar = (VariableTerm) loc;</span>
<span class="nc bnc" id="L6219" title="All 2 branches missed.">        if (locVar.getKind() == VariableKind.LOGICAL_VAR)</span>
        {
<span class="nc" id="L6221">          ((VariableTerm) loc).setKind(VariableKind.LOCATION_VAR);</span>
<span class="nc" id="L6222">          Logger.logDebug(&quot;\t\t\t&quot; + locVar.getName() + &quot; updated: TD=&quot; + locVar.getDomain().getName() + &quot;, kind=&quot; + locVar.getKind().toString());</span>
        }
<span class="nc bnc" id="L6224" title="All 2 branches missed.">        else if (locVar.getKind() == VariableKind.RULE_VAR) throw new ParseException(&quot;Error: In a try-catch rule, the variable to catch must be a location variable, not a rule variable. &quot;);</span>
      }
    label_57:
    while (true) {
<span class="nc bnc" id="L6228" title="All 4 branches missed.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case 116:{
<span class="nc" id="L6230">        break;</span>
        }
      default:
<span class="nc" id="L6233">        jj_la1[146] = jj_gen;</span>
<span class="nc" id="L6234">        break label_57;</span>
      }
<span class="nc" id="L6236">      jj_consume_token(116);</span>
<span class="nc" id="L6237">      loc = Term(localVar, false, c);</span>
//add location term to collection
<span class="nc" id="L6239">        locColl.add(loc);</span>
        // check and update the variable kind
<span class="nc bnc" id="L6241" title="All 2 branches missed.">        if (loc instanceof VariableTerm)</span>
        {
<span class="nc" id="L6243">          VariableTerm locVar = (VariableTerm) loc;</span>
<span class="nc bnc" id="L6244" title="All 2 branches missed.">          if (locVar.getKind() == VariableKind.LOGICAL_VAR)</span>
          {
<span class="nc" id="L6246">            ((VariableTerm) loc).setKind(VariableKind.LOCATION_VAR);</span>
<span class="nc" id="L6247">            Logger.logDebug(&quot;\t\t\t&quot; + locVar.getName() + &quot; updated: TD=&quot; + locVar.getDomain().getName() + &quot;, kind=&quot; + locVar.getKind().toString());</span>
          }
<span class="nc bnc" id="L6249" title="All 2 branches missed.">          else if (locVar.getKind() == VariableKind.RULE_VAR) throw new ParseException(&quot;Error: In a try-catch rule, the variable to catch must be a location variable, not a rule variable. &quot;);</span>
<span class="nc" id="L6250">        }</span>
    }
<span class="nc" id="L6252">    catchR = Rule(localVar, c);</span>
//set the reference
<span class="nc" id="L6254">    rule.setCatchRule(catchR);</span>
    //create the association
    //X ATryCatchRuleCatchRule a_TryCatchR_CatchR = rulesPack.getTurboTransitionRules().getATryCatchRuleCatchRule();
    //X a_TryCatchR_CatchR.add(rule,catchR);
<span class="nc" id="L6258">    Logger.logDebug(&quot;\t\t\tTryCatchRule end&quot;);</span>
    //OCL constraints granted for construction!
<span class="nc" id="L6260">    {if (&quot;&quot; != null) return rule;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

//////////////////////////////////////////////////////////////////////////////////////////////
  final public DerivedRule DerivedRule(HashMap localVar, RuleDeclaration c) throws ParseException {DerivedRule r;
<span class="pc bpc" id="L6266" title="2 of 5 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case SWITCH:{
<span class="fc" id="L6268">      r = BasicDerivedRule(localVar, c);</span>
<span class="fc" id="L6269">      break;</span>
      }
    case WHILE:
    case WHILEREC:{
<span class="fc" id="L6273">      r = TurboDerivedRule(localVar, c);</span>
<span class="fc" id="L6274">      break;</span>
      }
    default:
<span class="nc" id="L6277">      jj_la1[147] = jj_gen;</span>
<span class="nc" id="L6278">      jj_consume_token(-1);</span>
<span class="nc" id="L6279">      throw new ParseException();</span>
    }
<span class="fc" id="L6281">{if (&quot;&quot; != null) return r;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public BasicDerivedRule BasicDerivedRule(HashMap localVar, RuleDeclaration c) throws ParseException {BasicDerivedRule r;
<span class="fc" id="L6286">    r = CaseRule(localVar, c);</span>
<span class="fc" id="L6287">{if (&quot;&quot; != null) return r;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public CaseRule CaseRule(HashMap localVar, RuleDeclaration c) throws ParseException {Term caseT, term;
  Rule resRule;
<span class="fc" id="L6293">    jj_consume_token(SWITCH);</span>
<span class="fc" id="L6294">Logger.logDebug(&quot;\tswitch\t\tCaseRule beginning&quot;);</span>
<span class="fc" id="L6295">    term = Term(localVar, false, c);</span>
//create the object
<span class="fc" id="L6297">    CaseRule rule = rulesPack.getDerivedTransitionRules().createCaseRule();</span>
    //set the reference
<span class="fc" id="L6299">    rule.setTerm(term);</span>
<span class="fc" id="L6300">    List &lt; Term &gt; caseTermsList = rule.getCaseTerm();</span>
<span class="fc" id="L6301">    List &lt; Rule &gt; resList = rule.getCaseBranches();</span>
    label_58:
    while (true) {
<span class="fc" id="L6304">      jj_consume_token(CASE);</span>
<span class="fc" id="L6305">Logger.logDebug(&quot;\tcase&quot;);</span>
<span class="fc" id="L6306">      term = Term(localVar, false, c);</span>
<span class="fc" id="L6307">      jj_consume_token(118);</span>
<span class="fc" id="L6308">Logger.logDebug(&quot;\t:&quot;);</span>
<span class="fc" id="L6309">      resRule = Rule(localVar, c);</span>
<span class="fc" id="L6310">caseTermsList.add(term);</span>
<span class="fc" id="L6311">      resList.add(resRule);</span>
<span class="fc bfc" id="L6312" title="All 4 branches covered.">      switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
      case CASE:{
<span class="fc" id="L6314">        break;</span>
        }
      default:
<span class="fc" id="L6317">        jj_la1[148] = jj_gen;</span>
<span class="fc" id="L6318">        break label_58;</span>
      }
    }
<span class="pc bpc" id="L6321" title="1 of 4 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case OTHERWISE:{
<span class="fc" id="L6323">      jj_consume_token(OTHERWISE);</span>
<span class="fc" id="L6324">Logger.logDebug(&quot;\totherwise&quot;);</span>
<span class="fc" id="L6325">      resRule = Rule(localVar, c);</span>
//set the reference
<span class="fc" id="L6327">      rule.setOtherwiseBranch(resRule);</span>
<span class="fc" id="L6328">      break;</span>
      }
    default:
<span class="fc" id="L6331">      jj_la1[149] = jj_gen;</span>
      ;
    }
<span class="fc" id="L6334">    jj_consume_token(END_SWITCH);</span>
//check OCL constraints
<span class="pc bpc" id="L6336" title="1 of 2 branches missed.">    if (!OCL_Checker.checkCaseRule(rule))</span>
    {
<span class="nc" id="L6338">      Logger.logErr(OCL_Checker.getMsgErr());</span>
<span class="nc" id="L6339">      Logger.logErr(&quot;       At a case rule&quot;);</span>
    }
<span class="fc" id="L6341">    Logger.logDebug(&quot;\tendswitch\t\tCaseRule end&quot;);</span>
<span class="fc" id="L6342">    {if (&quot;&quot; != null) return rule;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public TurboDerivedRule TurboDerivedRule(HashMap localVar, RuleDeclaration c) throws ParseException {TurboDerivedRule r;
<span class="pc bpc" id="L6347" title="3 of 5 branches missed.">    switch (jj_ntk == -1 ? jj_ntk_f() : jj_ntk) {</span>
    case WHILEREC:{
<span class="nc" id="L6349">      r = RecursiveWhileRule(localVar, c);</span>
<span class="nc" id="L6350">      break;</span>
      }
    case WHILE:{
<span class="fc" id="L6353">      r = IterativeWhileRule(localVar, c);</span>
<span class="fc" id="L6354">      break;</span>
      }
    default:
<span class="nc" id="L6357">      jj_la1[150] = jj_gen;</span>
<span class="nc" id="L6358">      jj_consume_token(-1);</span>
<span class="nc" id="L6359">      throw new ParseException();</span>
    }
<span class="fc" id="L6361">{if (&quot;&quot; != null) return r;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public RecursiveWhileRule RecursiveWhileRule(HashMap localVar, RuleDeclaration c) throws ParseException {Term guard;
  Rule r;
<span class="nc" id="L6367">    jj_consume_token(WHILEREC);</span>
<span class="nc" id="L6368">Logger.logDebug(&quot;\twhilerec\t\tRecursiveWhileRule beginning&quot;);</span>
<span class="nc" id="L6369">    guard = Term(localVar, false, c);</span>
<span class="nc" id="L6370">    jj_consume_token(DO);</span>
<span class="nc" id="L6371">Logger.logDebug(&quot;\tdo&quot;);</span>
<span class="nc" id="L6372">    r = Rule(localVar, c);</span>
<span class="nc" id="L6373">RecursiveWhileRule rule = rulesPack.getDerivedTransitionRules().createRecursiveWhileRule();</span>
    //set references
<span class="nc" id="L6375">    rule.setGuard(guard);</span>
<span class="nc" id="L6376">    rule.setRule(r);</span>
    //create associations
    //X ARecursiveWhileRuleGuard a_RecWhileR_Guard = rulesPack.getDerivedTransitionRules().getARecursiveWhileRuleGuard();
    //X a_RecWhileR_Guard.add(rule,guard);
    //X ARecursiveWhileRuleRule a_RecWhileR_Rule = rulesPack.getDerivedTransitionRules().getARecursiveWhileRuleRule();
    //X a_RecWhileR_Rule.add(r,rule);
    //OCL constraints
<span class="nc bnc" id="L6383" title="All 2 branches missed.">    if (!OCL_Checker.checkRecursiveWhileRule(rule))</span>
    {
<span class="nc" id="L6385">      Logger.logErr(OCL_Checker.getMsgErr());</span>
<span class="nc" id="L6386">      Logger.logErr(&quot;       At a RecursiveWhileRule&quot;);</span>
    }
<span class="nc" id="L6388">    Logger.logDebug(&quot;\t\t\tRecursiveWhileRule end&quot;);</span>
<span class="nc" id="L6389">    {if (&quot;&quot; != null) return rule;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public IterativeWhileRule IterativeWhileRule(HashMap localVar, RuleDeclaration c) throws ParseException {Term guard;
  Rule r;
<span class="fc" id="L6395">    jj_consume_token(WHILE);</span>
<span class="fc" id="L6396">Logger.logDebug(&quot;\twhile\t\tIterativeWhileRule beginning&quot;);</span>
<span class="fc" id="L6397">    guard = Term(localVar, false, c);</span>
<span class="fc" id="L6398">    jj_consume_token(DO);</span>
<span class="fc" id="L6399">Logger.logDebug(&quot;\tdo&quot;);</span>
<span class="fc" id="L6400">    r = Rule(localVar, c);</span>
<span class="fc" id="L6401">IterativeWhileRule rule = rulesPack.getDerivedTransitionRules().createIterativeWhileRule();</span>
    //set references
<span class="fc" id="L6403">    rule.setGuard(guard);</span>
<span class="fc" id="L6404">    rule.setRule(r);</span>
    //create associations
    //X AIterativeWhileRuleGuard a_ItWhileR_Guard = rulesPack.getDerivedTransitionRules().getAIterativeWhileRuleGuard();
    //X a_ItWhileR_Guard.add(rule,guard);
    //X AIterativeWhileRuleRule a_ItWhileR_Rule = rulesPack.getDerivedTransitionRules().getAIterativeWhileRuleRule();
    //X a_ItWhileR_Rule.add(r,rule);
    //OCL constraints
<span class="pc bpc" id="L6411" title="1 of 2 branches missed.">    if (!OCL_Checker.checkIterativeWhileRule(rule))</span>
    {
<span class="nc" id="L6413">      Logger.logErr(OCL_Checker.getMsgErr());</span>
<span class="nc" id="L6414">      Logger.logErr(&quot;       At a IterativeWhileRule&quot;);</span>
    }
<span class="fc" id="L6416">    Logger.logDebug(&quot;\t\t\tIterativeWhileRule end&quot;);</span>
<span class="fc" id="L6417">    {if (&quot;&quot; != null) return rule;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

////////////////////////////////////////////////////////
/////////////////////////////////// END OF GRAMMAR ///////////////////////////
  final public String ID_VARIABLE() throws ParseException {Token t;
<span class="fc" id="L6424">    t = jj_consume_token(ID_VARIABLE);</span>
<span class="fc" id="L6425">{if (&quot;&quot; != null) return t.image;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public String ID_ENUM() throws ParseException {Token t;
<span class="fc" id="L6430">    t = jj_consume_token(ID_ENUM);</span>
<span class="fc" id="L6431">{if (&quot;&quot; != null) return t.image;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public String ID_DOMAIN() throws ParseException {Token t;
<span class="fc" id="L6436">    t = jj_consume_token(ID_DOMAIN);</span>
<span class="fc" id="L6437">{if (&quot;&quot; != null) return t.image;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public String ID_RULE() throws ParseException {Token t;
<span class="fc" id="L6442">    t = jj_consume_token(ID_RULE);</span>
<span class="fc" id="L6443">{if (&quot;&quot; != null) return t.image;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public String ID_AXIOM() throws ParseException {Token t;
<span class="fc" id="L6448">    t = jj_consume_token(ID_AXIOM);</span>
<span class="fc" id="L6449">{if (&quot;&quot; != null) return t.image;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public String ID_CTL() throws ParseException {Token t;
<span class="fc" id="L6454">    t = jj_consume_token(ID_CTL);</span>
<span class="fc" id="L6455">{if (&quot;&quot; != null) return t.image;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public String ID_LTL() throws ParseException {Token t;
<span class="fc" id="L6460">    t = jj_consume_token(ID_LTL);</span>
<span class="fc" id="L6461">{if (&quot;&quot; != null) return t.image;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public String ID_FUNCTION() throws ParseException {Token t;
<span class="fc" id="L6466">    t = jj_consume_token(ID_FUNCTION);</span>
<span class="fc" id="L6467">{if (&quot;&quot; != null) return t.image;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public String ID_AGENT() throws ParseException {Token t;
<span class="nc" id="L6472">    t = jj_consume_token(ID_FUNCTION);</span>
<span class="nc" id="L6473">{if (&quot;&quot; != null) return t.image;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public String ID() throws ParseException {Token t;
<span class="fc" id="L6478">    t = jj_consume_token(ID);</span>
<span class="fc" id="L6479">{if (&quot;&quot; != null) return t.image;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  final public String MOD_ID() throws ParseException {Token t;
<span class="fc" id="L6484">    t = jj_consume_token(MOD_ID);</span>
<span class="fc" id="L6485">{if (&quot;&quot; != null) return t.image;}</span>
    throw new IllegalStateException (&quot;Missing return statement in function&quot;);
}

  private boolean jj_2_1(int xla)
 {
<span class="fc" id="L6491">    jj_la = xla;</span>
<span class="fc" id="L6492">    jj_scanpos = token;</span>
<span class="fc" id="L6493">    jj_lastpos = token;</span>
<span class="pc bpc" id="L6494" title="1 of 2 branches missed.">    try { return (!jj_3_1()); }</span>
<span class="fc" id="L6495">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6496">    finally { jj_save(0, xla); }</span>
  }

  private boolean jj_2_2(int xla)
 {
<span class="fc" id="L6501">    jj_la = xla;</span>
<span class="fc" id="L6502">    jj_scanpos = token;</span>
<span class="fc" id="L6503">    jj_lastpos = token;</span>
<span class="pc bpc" id="L6504" title="1 of 2 branches missed.">    try { return (!jj_3_2()); }</span>
<span class="fc" id="L6505">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6506">    finally { jj_save(1, xla); }</span>
  }

  private boolean jj_2_3(int xla)
 {
<span class="fc" id="L6511">    jj_la = xla;</span>
<span class="fc" id="L6512">    jj_scanpos = token;</span>
<span class="fc" id="L6513">    jj_lastpos = token;</span>
<span class="pc bpc" id="L6514" title="1 of 2 branches missed.">    try { return (!jj_3_3()); }</span>
<span class="fc" id="L6515">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6516">    finally { jj_save(2, xla); }</span>
  }

  private boolean jj_2_4(int xla)
 {
<span class="fc" id="L6521">    jj_la = xla;</span>
<span class="fc" id="L6522">    jj_scanpos = token;</span>
<span class="fc" id="L6523">    jj_lastpos = token;</span>
<span class="pc bpc" id="L6524" title="1 of 2 branches missed.">    try { return (!jj_3_4()); }</span>
<span class="fc" id="L6525">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6526">    finally { jj_save(3, xla); }</span>
  }

  private boolean jj_2_5(int xla)
 {
<span class="fc" id="L6531">    jj_la = xla;</span>
<span class="fc" id="L6532">    jj_scanpos = token;</span>
<span class="fc" id="L6533">    jj_lastpos = token;</span>
<span class="pc bpc" id="L6534" title="1 of 2 branches missed.">    try { return (!jj_3_5()); }</span>
<span class="fc" id="L6535">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6536">    finally { jj_save(4, xla); }</span>
  }

  private boolean jj_2_6(int xla)
 {
<span class="fc" id="L6541">    jj_la = xla;</span>
<span class="fc" id="L6542">    jj_scanpos = token;</span>
<span class="fc" id="L6543">    jj_lastpos = token;</span>
<span class="fc bfc" id="L6544" title="All 2 branches covered.">    try { return (!jj_3_6()); }</span>
<span class="nc" id="L6545">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6546">    finally { jj_save(5, xla); }</span>
  }

  private boolean jj_2_7(int xla)
 {
<span class="fc" id="L6551">    jj_la = xla;</span>
<span class="fc" id="L6552">    jj_scanpos = token;</span>
<span class="fc" id="L6553">    jj_lastpos = token;</span>
<span class="fc bfc" id="L6554" title="All 2 branches covered.">    try { return (!jj_3_7()); }</span>
<span class="nc" id="L6555">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6556">    finally { jj_save(6, xla); }</span>
  }

  private boolean jj_2_8(int xla)
 {
<span class="fc" id="L6561">    jj_la = xla;</span>
<span class="fc" id="L6562">    jj_scanpos = token;</span>
<span class="fc" id="L6563">    jj_lastpos = token;</span>
<span class="pc bpc" id="L6564" title="1 of 2 branches missed.">    try { return (!jj_3_8()); }</span>
<span class="fc" id="L6565">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6566">    finally { jj_save(7, xla); }</span>
  }

  private boolean jj_2_9(int xla)
 {
<span class="fc" id="L6571">    jj_la = xla;</span>
<span class="fc" id="L6572">    jj_scanpos = token;</span>
<span class="fc" id="L6573">    jj_lastpos = token;</span>
<span class="pc bpc" id="L6574" title="1 of 2 branches missed.">    try { return (!jj_3_9()); }</span>
<span class="fc" id="L6575">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6576">    finally { jj_save(8, xla); }</span>
  }

  private boolean jj_2_10(int xla)
 {
<span class="fc" id="L6581">    jj_la = xla;</span>
<span class="fc" id="L6582">    jj_scanpos = token;</span>
<span class="fc" id="L6583">    jj_lastpos = token;</span>
<span class="pc bpc" id="L6584" title="1 of 2 branches missed.">    try { return (!jj_3_10()); }</span>
<span class="fc" id="L6585">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6586">    finally { jj_save(9, xla); }</span>
  }

  private boolean jj_2_11(int xla)
 {
<span class="fc" id="L6591">    jj_la = xla;</span>
<span class="fc" id="L6592">    jj_scanpos = token;</span>
<span class="fc" id="L6593">    jj_lastpos = token;</span>
<span class="nc bnc" id="L6594" title="All 2 branches missed.">    try { return (!jj_3_11()); }</span>
<span class="fc" id="L6595">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6596">    finally { jj_save(10, xla); }</span>
  }

  private boolean jj_2_12(int xla)
 {
<span class="fc" id="L6601">    jj_la = xla;</span>
<span class="fc" id="L6602">    jj_scanpos = token;</span>
<span class="fc" id="L6603">    jj_lastpos = token;</span>
<span class="pc bpc" id="L6604" title="1 of 2 branches missed.">    try { return (!jj_3_12()); }</span>
<span class="nc" id="L6605">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6606">    finally { jj_save(11, xla); }</span>
  }

  private boolean jj_2_13(int xla)
 {
<span class="fc" id="L6611">    jj_la = xla;</span>
<span class="fc" id="L6612">    jj_scanpos = token;</span>
<span class="fc" id="L6613">    jj_lastpos = token;</span>
<span class="fc bfc" id="L6614" title="All 2 branches covered.">    try { return (!jj_3_13()); }</span>
<span class="nc" id="L6615">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6616">    finally { jj_save(12, xla); }</span>
  }

  private boolean jj_2_14(int xla)
 {
<span class="fc" id="L6621">    jj_la = xla;</span>
<span class="fc" id="L6622">    jj_scanpos = token;</span>
<span class="fc" id="L6623">    jj_lastpos = token;</span>
<span class="fc bfc" id="L6624" title="All 2 branches covered.">    try { return (!jj_3_14()); }</span>
<span class="nc" id="L6625">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6626">    finally { jj_save(13, xla); }</span>
  }

  private boolean jj_2_15(int xla)
 {
<span class="fc" id="L6631">    jj_la = xla;</span>
<span class="fc" id="L6632">    jj_scanpos = token;</span>
<span class="fc" id="L6633">    jj_lastpos = token;</span>
<span class="fc bfc" id="L6634" title="All 2 branches covered.">    try { return (!jj_3_15()); }</span>
<span class="nc" id="L6635">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6636">    finally { jj_save(14, xla); }</span>
  }

  private boolean jj_2_16(int xla)
 {
<span class="fc" id="L6641">    jj_la = xla;</span>
<span class="fc" id="L6642">    jj_scanpos = token;</span>
<span class="fc" id="L6643">    jj_lastpos = token;</span>
<span class="fc bfc" id="L6644" title="All 2 branches covered.">    try { return (!jj_3_16()); }</span>
<span class="nc" id="L6645">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6646">    finally { jj_save(15, xla); }</span>
  }

  private boolean jj_2_17(int xla)
 {
<span class="fc" id="L6651">    jj_la = xla;</span>
<span class="fc" id="L6652">    jj_scanpos = token;</span>
<span class="fc" id="L6653">    jj_lastpos = token;</span>
<span class="fc bfc" id="L6654" title="All 2 branches covered.">    try { return (!jj_3_17()); }</span>
<span class="nc" id="L6655">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6656">    finally { jj_save(16, xla); }</span>
  }

  private boolean jj_2_18(int xla)
 {
<span class="fc" id="L6661">    jj_la = xla;</span>
<span class="fc" id="L6662">    jj_scanpos = token;</span>
<span class="fc" id="L6663">    jj_lastpos = token;</span>
<span class="pc bpc" id="L6664" title="1 of 2 branches missed.">    try { return (!jj_3_18()); }</span>
<span class="fc" id="L6665">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6666">    finally { jj_save(17, xla); }</span>
  }

  private boolean jj_2_19(int xla)
 {
<span class="fc" id="L6671">    jj_la = xla;</span>
<span class="fc" id="L6672">    jj_scanpos = token;</span>
<span class="fc" id="L6673">    jj_lastpos = token;</span>
<span class="pc bpc" id="L6674" title="1 of 2 branches missed.">    try { return (!jj_3_19()); }</span>
<span class="fc" id="L6675">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6676">    finally { jj_save(18, xla); }</span>
  }

  private boolean jj_2_20(int xla)
 {
<span class="fc" id="L6681">    jj_la = xla;</span>
<span class="fc" id="L6682">    jj_scanpos = token;</span>
<span class="fc" id="L6683">    jj_lastpos = token;</span>
<span class="pc bpc" id="L6684" title="1 of 2 branches missed.">    try { return (!jj_3_20()); }</span>
<span class="fc" id="L6685">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6686">    finally { jj_save(19, xla); }</span>
  }

  private boolean jj_2_21(int xla)
 {
<span class="fc" id="L6691">    jj_la = xla;</span>
<span class="fc" id="L6692">    jj_scanpos = token;</span>
<span class="fc" id="L6693">    jj_lastpos = token;</span>
<span class="pc bpc" id="L6694" title="1 of 2 branches missed.">    try { return (!jj_3_21()); }</span>
<span class="fc" id="L6695">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6696">    finally { jj_save(20, xla); }</span>
  }

  private boolean jj_2_22(int xla)
 {
<span class="fc" id="L6701">    jj_la = xla;</span>
<span class="fc" id="L6702">    jj_scanpos = token;</span>
<span class="fc" id="L6703">    jj_lastpos = token;</span>
<span class="pc bpc" id="L6704" title="1 of 2 branches missed.">    try { return (!jj_3_22()); }</span>
<span class="fc" id="L6705">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6706">    finally { jj_save(21, xla); }</span>
  }

  private boolean jj_2_23(int xla)
 {
<span class="fc" id="L6711">    jj_la = xla;</span>
<span class="fc" id="L6712">    jj_scanpos = token;</span>
<span class="fc" id="L6713">    jj_lastpos = token;</span>
<span class="pc bpc" id="L6714" title="1 of 2 branches missed.">    try { return (!jj_3_23()); }</span>
<span class="fc" id="L6715">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6716">    finally { jj_save(22, xla); }</span>
  }

  private boolean jj_2_24(int xla)
 {
<span class="fc" id="L6721">    jj_la = xla;</span>
<span class="fc" id="L6722">    jj_scanpos = token;</span>
<span class="fc" id="L6723">    jj_lastpos = token;</span>
<span class="fc bfc" id="L6724" title="All 2 branches covered.">    try { return (!jj_3_24()); }</span>
<span class="nc" id="L6725">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6726">    finally { jj_save(23, xla); }</span>
  }

  private boolean jj_2_25(int xla)
 {
<span class="fc" id="L6731">    jj_la = xla;</span>
<span class="fc" id="L6732">    jj_scanpos = token;</span>
<span class="fc" id="L6733">    jj_lastpos = token;</span>
<span class="fc bfc" id="L6734" title="All 2 branches covered.">    try { return (!jj_3_25()); }</span>
<span class="nc" id="L6735">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6736">    finally { jj_save(24, xla); }</span>
  }

  private boolean jj_2_26(int xla)
 {
<span class="fc" id="L6741">    jj_la = xla;</span>
<span class="fc" id="L6742">    jj_scanpos = token;</span>
<span class="fc" id="L6743">    jj_lastpos = token;</span>
<span class="pc bpc" id="L6744" title="1 of 2 branches missed.">    try { return (!jj_3_26()); }</span>
<span class="nc" id="L6745">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6746">    finally { jj_save(25, xla); }</span>
  }

  private boolean jj_2_27(int xla)
 {
<span class="fc" id="L6751">    jj_la = xla;</span>
<span class="fc" id="L6752">    jj_scanpos = token;</span>
<span class="fc" id="L6753">    jj_lastpos = token;</span>
<span class="pc bpc" id="L6754" title="1 of 2 branches missed.">    try { return (!jj_3_27()); }</span>
<span class="nc" id="L6755">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6756">    finally { jj_save(26, xla); }</span>
  }

  private boolean jj_2_28(int xla)
 {
<span class="fc" id="L6761">    jj_la = xla;</span>
<span class="fc" id="L6762">    jj_scanpos = token;</span>
<span class="fc" id="L6763">    jj_lastpos = token;</span>
<span class="pc bpc" id="L6764" title="1 of 2 branches missed.">    try { return (!jj_3_28()); }</span>
<span class="nc" id="L6765">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6766">    finally { jj_save(27, xla); }</span>
  }

  private boolean jj_2_29(int xla)
 {
<span class="fc" id="L6771">    jj_la = xla;</span>
<span class="fc" id="L6772">    jj_scanpos = token;</span>
<span class="fc" id="L6773">    jj_lastpos = token;</span>
<span class="fc bfc" id="L6774" title="All 2 branches covered.">    try { return (!jj_3_29()); }</span>
<span class="nc" id="L6775">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6776">    finally { jj_save(28, xla); }</span>
  }

  private boolean jj_2_30(int xla)
 {
<span class="fc" id="L6781">    jj_la = xla;</span>
<span class="fc" id="L6782">    jj_scanpos = token;</span>
<span class="fc" id="L6783">    jj_lastpos = token;</span>
<span class="pc bpc" id="L6784" title="1 of 2 branches missed.">    try { return (!jj_3_30()); }</span>
<span class="fc" id="L6785">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6786">    finally { jj_save(29, xla); }</span>
  }

  private boolean jj_2_31(int xla)
 {
<span class="fc" id="L6791">    jj_la = xla;</span>
<span class="fc" id="L6792">    jj_scanpos = token;</span>
<span class="fc" id="L6793">    jj_lastpos = token;</span>
<span class="fc bfc" id="L6794" title="All 2 branches covered.">    try { return (!jj_3_31()); }</span>
<span class="nc" id="L6795">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6796">    finally { jj_save(30, xla); }</span>
  }

  private boolean jj_2_32(int xla)
 {
<span class="fc" id="L6801">    jj_la = xla;</span>
<span class="fc" id="L6802">    jj_scanpos = token;</span>
<span class="fc" id="L6803">    jj_lastpos = token;</span>
<span class="fc bfc" id="L6804" title="All 2 branches covered.">    try { return (!jj_3_32()); }</span>
<span class="nc" id="L6805">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6806">    finally { jj_save(31, xla); }</span>
  }

  private boolean jj_2_33(int xla)
 {
<span class="fc" id="L6811">    jj_la = xla;</span>
<span class="fc" id="L6812">    jj_scanpos = token;</span>
<span class="fc" id="L6813">    jj_lastpos = token;</span>
<span class="pc bpc" id="L6814" title="1 of 2 branches missed.">    try { return (!jj_3_33()); }</span>
<span class="fc" id="L6815">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6816">    finally { jj_save(32, xla); }</span>
  }

  private boolean jj_2_34(int xla)
 {
<span class="fc" id="L6821">    jj_la = xla;</span>
<span class="fc" id="L6822">    jj_scanpos = token;</span>
<span class="fc" id="L6823">    jj_lastpos = token;</span>
<span class="pc bpc" id="L6824" title="1 of 2 branches missed.">    try { return (!jj_3_34()); }</span>
<span class="fc" id="L6825">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6826">    finally { jj_save(33, xla); }</span>
  }

  private boolean jj_2_35(int xla)
 {
<span class="fc" id="L6831">    jj_la = xla;</span>
<span class="fc" id="L6832">    jj_scanpos = token;</span>
<span class="fc" id="L6833">    jj_lastpos = token;</span>
<span class="nc bnc" id="L6834" title="All 2 branches missed.">    try { return (!jj_3_35()); }</span>
<span class="fc" id="L6835">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6836">    finally { jj_save(34, xla); }</span>
  }

  private boolean jj_2_36(int xla)
 {
<span class="fc" id="L6841">    jj_la = xla;</span>
<span class="fc" id="L6842">    jj_scanpos = token;</span>
<span class="fc" id="L6843">    jj_lastpos = token;</span>
<span class="pc bpc" id="L6844" title="1 of 2 branches missed.">    try { return (!jj_3_36()); }</span>
<span class="fc" id="L6845">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6846">    finally { jj_save(35, xla); }</span>
  }

  private boolean jj_2_37(int xla)
 {
<span class="fc" id="L6851">    jj_la = xla;</span>
<span class="fc" id="L6852">    jj_scanpos = token;</span>
<span class="fc" id="L6853">    jj_lastpos = token;</span>
<span class="fc bfc" id="L6854" title="All 2 branches covered.">    try { return (!jj_3_37()); }</span>
<span class="nc" id="L6855">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6856">    finally { jj_save(36, xla); }</span>
  }

  private boolean jj_2_38(int xla)
 {
<span class="fc" id="L6861">    jj_la = xla;</span>
<span class="fc" id="L6862">    jj_scanpos = token;</span>
<span class="fc" id="L6863">    jj_lastpos = token;</span>
<span class="fc bfc" id="L6864" title="All 2 branches covered.">    try { return (!jj_3_38()); }</span>
<span class="nc" id="L6865">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6866">    finally { jj_save(37, xla); }</span>
  }

  private boolean jj_2_39(int xla)
 {
<span class="fc" id="L6871">    jj_la = xla;</span>
<span class="fc" id="L6872">    jj_scanpos = token;</span>
<span class="fc" id="L6873">    jj_lastpos = token;</span>
<span class="fc bfc" id="L6874" title="All 2 branches covered.">    try { return (!jj_3_39()); }</span>
<span class="nc" id="L6875">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6876">    finally { jj_save(38, xla); }</span>
  }

  private boolean jj_2_40(int xla)
 {
<span class="fc" id="L6881">    jj_la = xla;</span>
<span class="fc" id="L6882">    jj_scanpos = token;</span>
<span class="fc" id="L6883">    jj_lastpos = token;</span>
<span class="fc bfc" id="L6884" title="All 2 branches covered.">    try { return (!jj_3_40()); }</span>
<span class="fc" id="L6885">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6886">    finally { jj_save(39, xla); }</span>
  }

  private boolean jj_2_41(int xla)
 {
<span class="fc" id="L6891">    jj_la = xla;</span>
<span class="fc" id="L6892">    jj_scanpos = token;</span>
<span class="fc" id="L6893">    jj_lastpos = token;</span>
<span class="fc bfc" id="L6894" title="All 2 branches covered.">    try { return (!jj_3_41()); }</span>
<span class="nc" id="L6895">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6896">    finally { jj_save(40, xla); }</span>
  }

  private boolean jj_2_42(int xla)
 {
<span class="fc" id="L6901">    jj_la = xla;</span>
<span class="fc" id="L6902">    jj_scanpos = token;</span>
<span class="fc" id="L6903">    jj_lastpos = token;</span>
<span class="fc bfc" id="L6904" title="All 2 branches covered.">    try { return (!jj_3_42()); }</span>
<span class="nc" id="L6905">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6906">    finally { jj_save(41, xla); }</span>
  }

  private boolean jj_2_43(int xla)
 {
<span class="fc" id="L6911">    jj_la = xla;</span>
<span class="fc" id="L6912">    jj_scanpos = token;</span>
<span class="fc" id="L6913">    jj_lastpos = token;</span>
<span class="pc bpc" id="L6914" title="1 of 2 branches missed.">    try { return (!jj_3_43()); }</span>
<span class="fc" id="L6915">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6916">    finally { jj_save(42, xla); }</span>
  }

  private boolean jj_2_44(int xla)
 {
<span class="fc" id="L6921">    jj_la = xla;</span>
<span class="fc" id="L6922">    jj_scanpos = token;</span>
<span class="fc" id="L6923">    jj_lastpos = token;</span>
<span class="pc bpc" id="L6924" title="1 of 2 branches missed.">    try { return (!jj_3_44()); }</span>
<span class="fc" id="L6925">    catch(LookaheadSuccess ls) { return true; }</span>
<span class="pc" id="L6926">    finally { jj_save(43, xla); }</span>
  }

  private boolean jj_3R_268()
 {
<span class="nc bnc" id="L6931" title="All 2 branches missed.">    if (jj_3R_282()) return true;</span>
<span class="nc" id="L6932">    return false;</span>
  }

  private boolean jj_3R_269()
 {
<span class="nc bnc" id="L6937" title="All 2 branches missed.">    if (jj_3R_283()) return true;</span>
<span class="nc" id="L6938">    return false;</span>
  }

  private boolean jj_3R_291()
 {
<span class="nc bnc" id="L6943" title="All 2 branches missed.">    if (jj_scan_token(116)) return true;</span>
<span class="nc bnc" id="L6944" title="All 2 branches missed.">    if (jj_3R_64()) return true;</span>
<span class="nc" id="L6945">    return false;</span>
  }

  private boolean jj_3R_174()
 {
<span class="fc bfc" id="L6950" title="All 2 branches covered.">    if (jj_3R_80()) return true;</span>
    Token xsp;
    while (true) {
<span class="fc" id="L6953">      xsp = jj_scanpos;</span>
<span class="fc bfc" id="L6954" title="All 2 branches covered.">      if (jj_3R_270()) { jj_scanpos = xsp; break; }</span>
    }
<span class="fc" id="L6956">    return false;</span>
  }

  private boolean jj_3R_301()
 {
<span class="fc bfc" id="L6961" title="All 2 branches covered.">    if (jj_scan_token(116)) return true;</span>
<span class="pc bpc" id="L6962" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="pc bpc" id="L6963" title="1 of 2 branches missed.">    if (jj_scan_token(122)) return true;</span>
<span class="pc bpc" id="L6964" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="fc" id="L6965">    return false;</span>
  }

  private boolean jj_3R_151()
 {
<span class="fc bfc" id="L6970" title="All 2 branches covered.">    if (jj_3R_196()) return true;</span>
<span class="pc bpc" id="L6971" title="1 of 2 branches missed.">    if (jj_scan_token(124)) return true;</span>
<span class="nc" id="L6972">    return false;</span>
  }

  private boolean jj_3R_282()
 {
<span class="nc bnc" id="L6977" title="All 2 branches missed.">    if (jj_3R_292()) return true;</span>
<span class="nc" id="L6978">    return false;</span>
  }

  private boolean jj_3R_216()
 {
<span class="fc bfc" id="L6983" title="All 2 branches covered.">    if (jj_scan_token(UNDEF)) return true;</span>
<span class="fc" id="L6984">    return false;</span>
  }

  private boolean jj_3R_270()
 {
    Token xsp;
<span class="fc" id="L6990">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L6991" title="All 2 branches covered.">    if (jj_3_21()) {</span>
<span class="fc" id="L6992">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L6993" title="All 2 branches covered.">    if (jj_3R_284()) return true;</span>
    }
<span class="fc" id="L6995">    return false;</span>
  }

  private boolean jj_3R_272()
 {
    Token xsp;
<span class="fc" id="L7001">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L7002" title="All 2 branches covered.">    if (jj_3R_285()) {</span>
<span class="fc" id="L7003">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7004" title="1 of 2 branches missed.">    if (jj_3R_286()) {</span>
<span class="fc" id="L7005">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L7006" title="All 2 branches covered.">    if (jj_3R_287()) {</span>
<span class="fc" id="L7007">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L7008" title="All 2 branches covered.">    if (jj_3R_288()) return true;</span>
    }
    }
    }
<span class="fc" id="L7012">    return false;</span>
  }

  private boolean jj_3_6()
 {
<span class="pc bpc" id="L7017" title="1 of 2 branches missed.">    if (jj_3R_64()) return true;</span>
<span class="fc bfc" id="L7018" title="All 2 branches covered.">    if (jj_scan_token(122)) return true;</span>
<span class="fc" id="L7019">    return false;</span>
  }

  private boolean jj_3_21()
 {
<span class="fc bfc" id="L7024" title="All 2 branches covered.">    if (jj_scan_token(PLUS)) return true;</span>
<span class="pc bpc" id="L7025" title="1 of 2 branches missed.">    if (jj_3R_80()) return true;</span>
<span class="fc" id="L7026">    return false;</span>
  }

  private boolean jj_3R_285()
 {
<span class="fc bfc" id="L7031" title="All 2 branches covered.">    if (jj_3R_296()) return true;</span>
<span class="fc" id="L7032">    return false;</span>
  }

  private boolean jj_3R_286()
 {
<span class="pc bpc" id="L7037" title="1 of 2 branches missed.">    if (jj_3R_297()) return true;</span>
<span class="nc" id="L7038">    return false;</span>
  }

  private boolean jj_3R_287()
 {
<span class="fc bfc" id="L7043" title="All 2 branches covered.">    if (jj_3R_298()) return true;</span>
<span class="fc" id="L7044">    return false;</span>
  }

  private boolean jj_3R_197()
 {
    Token xsp;
<span class="fc" id="L7050">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L7051" title="1 of 2 branches missed.">    if (jj_3_40()) {</span>
<span class="fc" id="L7052">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7053" title="1 of 2 branches missed.">    if (jj_3R_224()) {</span>
<span class="fc" id="L7054">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7055" title="1 of 2 branches missed.">    if (jj_3R_225()) {</span>
<span class="fc" id="L7056">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7057" title="1 of 2 branches missed.">    if (jj_3R_226()) {</span>
<span class="fc" id="L7058">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7059" title="1 of 2 branches missed.">    if (jj_3R_227()) {</span>
<span class="fc" id="L7060">    jj_scanpos = xsp;</span>
<span class="nc bnc" id="L7061" title="All 2 branches missed.">    if (jj_3R_228()) return true;</span>
    }
    }
    }
    }
    }
<span class="nc" id="L7067">    return false;</span>
  }

  private boolean jj_3R_284()
 {
<span class="fc bfc" id="L7072" title="All 2 branches covered.">    if (jj_scan_token(MINUS)) return true;</span>
<span class="pc bpc" id="L7073" title="1 of 2 branches missed.">    if (jj_3R_80()) return true;</span>
<span class="fc" id="L7074">    return false;</span>
  }

  private boolean jj_3R_288()
 {
<span class="fc bfc" id="L7079" title="All 2 branches covered.">    if (jj_3R_299()) return true;</span>
<span class="fc" id="L7080">    return false;</span>
  }

  private boolean jj_3R_292()
 {
<span class="nc bnc" id="L7085" title="All 2 branches missed.">    if (jj_scan_token(SWITCH)) return true;</span>
<span class="nc" id="L7086">    return false;</span>
  }

  private boolean jj_3_43()
 {
<span class="pc bpc" id="L7091" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="nc" id="L7092">    return false;</span>
  }

  private boolean jj_3_40()
 {
<span class="fc bfc" id="L7097" title="All 2 branches covered.">    if (jj_3R_97()) return true;</span>
<span class="fc" id="L7098">    return false;</span>
  }

  private boolean jj_3R_224()
 {
<span class="pc bpc" id="L7103" title="1 of 2 branches missed.">    if (jj_3R_240()) return true;</span>
<span class="nc" id="L7104">    return false;</span>
  }

  private boolean jj_3_39()
 {
<span class="fc bfc" id="L7109" title="All 2 branches covered.">    if (jj_scan_token(119)) return true;</span>
<span class="pc bpc" id="L7110" title="1 of 2 branches missed.">    if (jj_3R_94()) return true;</span>
<span class="pc bpc" id="L7111" title="1 of 2 branches missed.">    if (jj_scan_token(IN)) return true;</span>
<span class="pc bpc" id="L7112" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
    Token xsp;
    while (true) {
<span class="fc" id="L7115">      xsp = jj_scanpos;</span>
<span class="fc bfc" id="L7116" title="All 2 branches covered.">      if (jj_3R_95()) { jj_scanpos = xsp; break; }</span>
    }
<span class="fc" id="L7118">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L7119" title="All 2 branches covered.">    if (jj_3R_96()) jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7120" title="1 of 2 branches missed.">    if (jj_scan_token(118)) return true;</span>
<span class="pc bpc" id="L7121" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="pc bpc" id="L7122" title="1 of 2 branches missed.">    if (jj_scan_token(121)) return true;</span>
<span class="fc" id="L7123">    return false;</span>
  }

  private boolean jj_3R_225()
 {
<span class="pc bpc" id="L7128" title="1 of 2 branches missed.">    if (jj_3R_241()) return true;</span>
<span class="nc" id="L7129">    return false;</span>
  }

  private boolean jj_3R_99()
 {
<span class="fc bfc" id="L7134" title="All 2 branches covered.">    if (jj_3R_133()) return true;</span>
<span class="fc" id="L7135">    return false;</span>
  }

  private boolean jj_3R_202()
 {
<span class="pc bpc" id="L7140" title="1 of 2 branches missed.">    if (jj_scan_token(STATIC)) return true;</span>
<span class="nc bnc" id="L7141" title="All 2 branches missed.">    if (jj_3R_109()) return true;</span>
<span class="nc" id="L7142">    return false;</span>
  }

  private boolean jj_3R_226()
 {
<span class="pc bpc" id="L7147" title="1 of 2 branches missed.">    if (jj_3R_242()) return true;</span>
<span class="nc" id="L7148">    return false;</span>
  }

  private boolean jj_3R_101()
 {
<span class="fc bfc" id="L7153" title="All 2 branches covered.">    if (jj_3R_133()) return true;</span>
<span class="fc" id="L7154">    return false;</span>
  }

  private boolean jj_3R_227()
 {
<span class="pc bpc" id="L7159" title="1 of 2 branches missed.">    if (jj_3R_243()) return true;</span>
<span class="nc" id="L7160">    return false;</span>
  }

  private boolean jj_3_3()
 {
<span class="pc bpc" id="L7165" title="1 of 2 branches missed.">    if (jj_3R_61()) return true;</span>
<span class="nc" id="L7166">    return false;</span>
  }

  private boolean jj_3R_228()
 {
<span class="nc bnc" id="L7171" title="All 2 branches missed.">    if (jj_3R_244()) return true;</span>
<span class="nc" id="L7172">    return false;</span>
  }

  private boolean jj_3_41()
 {
    Token xsp;
<span class="fc" id="L7178">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L7179" title="All 2 branches covered.">    if (jj_3R_98()) {</span>
<span class="fc" id="L7180">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L7181" title="All 2 branches covered.">    if (jj_3R_99()) return true;</span>
    }
<span class="fc bfc" id="L7183" title="All 2 branches covered.">    if (jj_scan_token(128)) return true;</span>
<span class="fc" id="L7184">    return false;</span>
  }

  private boolean jj_3R_217()
 {
<span class="fc bfc" id="L7189" title="All 2 branches covered.">    if (jj_3R_234()) return true;</span>
<span class="fc" id="L7190">    return false;</span>
  }

  private boolean jj_3R_98()
 {
<span class="fc bfc" id="L7195" title="All 2 branches covered.">    if (jj_3R_94()) return true;</span>
<span class="fc" id="L7196">    return false;</span>
  }

  private boolean jj_3_42()
 {
    Token xsp;
<span class="fc" id="L7202">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L7203" title="All 2 branches covered.">    if (jj_3R_100()) {</span>
<span class="fc" id="L7204">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L7205" title="All 2 branches covered.">    if (jj_3R_101()) return true;</span>
    }
<span class="fc bfc" id="L7207" title="All 2 branches covered.">    if (jj_scan_token(129)) return true;</span>
<span class="fc" id="L7208">    return false;</span>
  }

  private boolean jj_3R_296()
 {
<span class="fc bfc" id="L7213" title="All 2 branches covered.">    if (jj_scan_token(119)) return true;</span>
<span class="fc bfc" id="L7214" title="All 2 branches covered.">    if (jj_3R_94()) return true;</span>
<span class="pc bpc" id="L7215" title="1 of 2 branches missed.">    if (jj_scan_token(IN)) return true;</span>
<span class="pc bpc" id="L7216" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
    Token xsp;
    while (true) {
<span class="fc" id="L7219">      xsp = jj_scanpos;</span>
<span class="fc bfc" id="L7220" title="All 2 branches covered.">      if (jj_3R_306()) { jj_scanpos = xsp; break; }</span>
    }
<span class="fc" id="L7222">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L7223" title="All 2 branches covered.">    if (jj_3R_307()) jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7224" title="1 of 2 branches missed.">    if (jj_scan_token(118)) return true;</span>
<span class="pc bpc" id="L7225" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="pc bpc" id="L7226" title="1 of 2 branches missed.">    if (jj_scan_token(121)) return true;</span>
<span class="fc" id="L7227">    return false;</span>
  }

  private boolean jj_3R_100()
 {
<span class="fc bfc" id="L7232" title="All 2 branches covered.">    if (jj_3R_94()) return true;</span>
<span class="fc" id="L7233">    return false;</span>
  }

  private boolean jj_3R_80()
 {
<span class="fc bfc" id="L7238" title="All 2 branches covered.">    if (jj_3R_112()) return true;</span>
    Token xsp;
    while (true) {
<span class="fc" id="L7241">      xsp = jj_scanpos;</span>
<span class="fc bfc" id="L7242" title="All 2 branches covered.">      if (jj_3_22()) { jj_scanpos = xsp; break; }</span>
    }
<span class="fc" id="L7244">    return false;</span>
  }

  private boolean jj_3_22()
 {
    Token xsp;
<span class="fc" id="L7250">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L7251" title="All 2 branches covered.">    if (jj_3R_81()) {</span>
<span class="fc" id="L7252">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L7253" title="All 2 branches covered.">    if (jj_3R_82()) {</span>
<span class="fc" id="L7254">    jj_scanpos = xsp;</span>
<span class="fc" id="L7255">    jj_lookingAhead = true;</span>
<span class="fc bfc" id="L7256" title="All 4 branches covered.">    jj_semLA = getToken(1).kind == ID_FUNCTION &amp;&amp; getToken(1).image.equals(&quot;mod&quot;);</span>
<span class="fc" id="L7257">    jj_lookingAhead = false;</span>
<span class="pc bpc" id="L7258" title="1 of 4 branches missed.">    if (!jj_semLA || jj_3R_83()) return true;</span>
    }
    }
<span class="fc" id="L7261">    return false;</span>
  }

  private boolean jj_3R_243()
 {
    Token xsp;
<span class="fc" id="L7267">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L7268" title="1 of 2 branches missed.">    if (jj_3R_266()) {</span>
<span class="fc" id="L7269">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7270" title="1 of 2 branches missed.">    if (jj_3R_267()) return true;</span>
    }
<span class="nc" id="L7272">    return false;</span>
  }

  private boolean jj_3_7()
 {
<span class="pc bpc" id="L7277" title="1 of 2 branches missed.">    if (jj_3R_64()) return true;</span>
<span class="fc bfc" id="L7278" title="All 2 branches covered.">    if (jj_scan_token(122)) return true;</span>
<span class="fc" id="L7279">    return false;</span>
  }

  private boolean jj_3R_81()
 {
<span class="fc bfc" id="L7284" title="All 2 branches covered.">    if (jj_scan_token(MULT)) return true;</span>
<span class="pc bpc" id="L7285" title="1 of 2 branches missed.">    if (jj_3R_112()) return true;</span>
<span class="fc" id="L7286">    return false;</span>
  }

  private boolean jj_3R_266()
 {
<span class="pc bpc" id="L7291" title="1 of 2 branches missed.">    if (jj_3R_144()) return true;</span>
<span class="nc" id="L7292">    return false;</span>
  }

  private boolean jj_3R_267()
 {
<span class="pc bpc" id="L7297" title="1 of 2 branches missed.">    if (jj_3R_94()) return true;</span>
<span class="nc" id="L7298">    return false;</span>
  }

  private boolean jj_3R_82()
 {
<span class="fc bfc" id="L7303" title="All 2 branches covered.">    if (jj_scan_token(DIV)) return true;</span>
<span class="pc bpc" id="L7304" title="1 of 2 branches missed.">    if (jj_3R_112()) return true;</span>
<span class="fc" id="L7305">    return false;</span>
  }

  private boolean jj_3R_83()
 {
<span class="pc bpc" id="L7310" title="1 of 2 branches missed.">    if (jj_scan_token(ID_FUNCTION)) return true;</span>
<span class="pc bpc" id="L7311" title="1 of 2 branches missed.">    if (jj_3R_112()) return true;</span>
<span class="fc" id="L7312">    return false;</span>
  }

  private boolean jj_3R_195()
 {
    Token xsp;
<span class="fc" id="L7318">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L7319" title="1 of 2 branches missed.">    if (jj_3R_218()) {</span>
<span class="fc" id="L7320">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7321" title="1 of 2 branches missed.">    if (jj_3R_219()) {</span>
<span class="fc" id="L7322">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L7323" title="All 2 branches covered.">    if (jj_3_30()) {</span>
<span class="fc" id="L7324">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L7325" title="All 2 branches covered.">    if (jj_3R_220()) {</span>
<span class="fc" id="L7326">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L7327" title="All 2 branches covered.">    if (jj_3R_221()) {</span>
<span class="fc" id="L7328">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7329" title="1 of 2 branches missed.">    if (jj_3R_222()) {</span>
<span class="fc" id="L7330">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7331" title="1 of 2 branches missed.">    if (jj_3R_223()) return true;</span>
    }
    }
    }
    }
    }
    }
<span class="fc" id="L7338">    return false;</span>
  }

  private boolean jj_3R_203()
 {
    Token xsp;
<span class="fc" id="L7344">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L7345" title="1 of 2 branches missed.">    if (jj_3_8()) {</span>
<span class="fc" id="L7346">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7347" title="1 of 2 branches missed.">    if (jj_3_9()) {</span>
<span class="fc" id="L7348">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7349" title="1 of 2 branches missed.">    if (jj_3_10()) {</span>
<span class="fc" id="L7350">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7351" title="1 of 2 branches missed.">    if (jj_3_11()) {</span>
<span class="fc" id="L7352">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7353" title="1 of 2 branches missed.">    if (jj_3R_231()) return true;</span>
    }
    }
    }
    }
<span class="nc" id="L7358">    return false;</span>
  }

  private boolean jj_3R_276()
 {
<span class="fc bfc" id="L7363" title="All 2 branches covered.">    if (jj_scan_token(LT)) return true;</span>
    Token xsp;
<span class="fc" id="L7365">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L7366" title="All 2 branches covered.">    if (jj_3_36()) jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7367" title="1 of 2 branches missed.">    if (jj_scan_token(GT)) return true;</span>
<span class="fc" id="L7368">    return false;</span>
  }

  private boolean jj_3R_95()
 {
<span class="fc bfc" id="L7373" title="All 2 branches covered.">    if (jj_scan_token(116)) return true;</span>
<span class="pc bpc" id="L7374" title="1 of 2 branches missed.">    if (jj_3R_94()) return true;</span>
<span class="pc bpc" id="L7375" title="1 of 2 branches missed.">    if (jj_scan_token(IN)) return true;</span>
<span class="pc bpc" id="L7376" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="fc" id="L7377">    return false;</span>
  }

  private boolean jj_3_8()
 {
<span class="pc bpc" id="L7382" title="1 of 2 branches missed.">    if (jj_3R_65()) return true;</span>
<span class="nc" id="L7383">    return false;</span>
  }

  private boolean jj_3R_218()
 {
<span class="pc bpc" id="L7388" title="1 of 2 branches missed.">    if (jj_3R_235()) return true;</span>
<span class="nc" id="L7389">    return false;</span>
  }

  private boolean jj_3R_219()
 {
<span class="pc bpc" id="L7394" title="1 of 2 branches missed.">    if (jj_3R_236()) return true;</span>
<span class="nc" id="L7395">    return false;</span>
  }

  private boolean jj_3_9()
 {
<span class="pc bpc" id="L7400" title="1 of 2 branches missed.">    if (jj_3R_66()) return true;</span>
<span class="nc" id="L7401">    return false;</span>
  }

  private boolean jj_3_30()
 {
<span class="fc bfc" id="L7406" title="All 2 branches covered.">    if (jj_3R_90()) return true;</span>
<span class="fc" id="L7407">    return false;</span>
  }

  private boolean jj_3R_61()
 {
<span class="pc bpc" id="L7412" title="1 of 2 branches missed.">    if (jj_scan_token(DOMAIN)) return true;</span>
<span class="nc bnc" id="L7413" title="All 2 branches missed.">    if (jj_3R_105()) return true;</span>
<span class="nc" id="L7414">    return false;</span>
  }

  private boolean jj_3_10()
 {
<span class="pc bpc" id="L7419" title="1 of 2 branches missed.">    if (jj_3R_67()) return true;</span>
<span class="nc" id="L7420">    return false;</span>
  }

  private boolean jj_3R_220()
 {
<span class="fc bfc" id="L7425" title="All 2 branches covered.">    if (jj_3R_237()) return true;</span>
<span class="fc" id="L7426">    return false;</span>
  }

  private boolean jj_3R_306()
 {
<span class="fc bfc" id="L7431" title="All 2 branches covered.">    if (jj_scan_token(116)) return true;</span>
<span class="pc bpc" id="L7432" title="1 of 2 branches missed.">    if (jj_3R_94()) return true;</span>
<span class="pc bpc" id="L7433" title="1 of 2 branches missed.">    if (jj_scan_token(IN)) return true;</span>
<span class="pc bpc" id="L7434" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="fc" id="L7435">    return false;</span>
  }

  private boolean jj_3_11()
 {
<span class="pc bpc" id="L7440" title="1 of 2 branches missed.">    if (jj_3R_68()) return true;</span>
<span class="nc" id="L7441">    return false;</span>
  }

  private boolean jj_3R_91()
 {
    Token xsp;
<span class="fc" id="L7447">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L7448" title="All 2 branches covered.">    if (jj_scan_token(119)) {</span>
<span class="fc" id="L7449">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L7450" title="All 2 branches covered.">    if (jj_scan_token(124)) {</span>
<span class="fc" id="L7451">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L7452" title="All 2 branches covered.">    if (jj_scan_token(87)) return true;</span>
    }
    }
<span class="fc bfc" id="L7455" title="All 2 branches covered.">    if (jj_3R_94()) return true;</span>
<span class="pc bpc" id="L7456" title="1 of 2 branches missed.">    if (jj_scan_token(IN)) return true;</span>
<span class="pc bpc" id="L7457" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
    while (true) {
<span class="fc" id="L7459">      xsp = jj_scanpos;</span>
<span class="fc bfc" id="L7460" title="All 2 branches covered.">      if (jj_3R_121()) { jj_scanpos = xsp; break; }</span>
    }
<span class="fc" id="L7462">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L7463" title="All 2 branches covered.">    if (jj_3R_122()) jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7464" title="1 of 2 branches missed.">    if (jj_scan_token(118)) return true;</span>
<span class="fc" id="L7465">    return false;</span>
  }

  private boolean jj_3R_231()
 {
<span class="pc bpc" id="L7470" title="1 of 2 branches missed.">    if (jj_3R_245()) return true;</span>
<span class="nc" id="L7471">    return false;</span>
  }

  private boolean jj_3_36()
 {
<span class="fc bfc" id="L7476" title="All 2 branches covered.">    if (jj_3R_93()) return true;</span>
    Token xsp;
<span class="fc" id="L7478">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L7479" title="1 of 2 branches missed.">    if (jj_3R_303()) jj_scanpos = xsp;</span>
<span class="fc" id="L7480">    return false;</span>
  }

  private boolean jj_3R_221()
 {
<span class="fc bfc" id="L7485" title="All 2 branches covered.">    if (jj_3R_238()) return true;</span>
<span class="fc" id="L7486">    return false;</span>
  }

  private boolean jj_3R_222()
 {
<span class="pc bpc" id="L7491" title="1 of 2 branches missed.">    if (jj_3R_239()) return true;</span>
<span class="nc" id="L7492">    return false;</span>
  }

  private boolean jj_3R_223()
 {
<span class="pc bpc" id="L7497" title="1 of 2 branches missed.">    if (jj_3R_210()) return true;</span>
<span class="nc" id="L7498">    return false;</span>
  }

  private boolean jj_3R_283()
 {
    Token xsp;
<span class="nc" id="L7504">    xsp = jj_scanpos;</span>
<span class="nc bnc" id="L7505" title="All 2 branches missed.">    if (jj_3R_293()) {</span>
<span class="nc" id="L7506">    jj_scanpos = xsp;</span>
<span class="nc bnc" id="L7507" title="All 2 branches missed.">    if (jj_3R_294()) return true;</span>
    }
<span class="nc" id="L7509">    return false;</span>
  }

  private boolean jj_3_31()
 {
    Token xsp;
<span class="fc" id="L7515">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L7516" title="All 2 branches covered.">    if (jj_scan_token(59)) {</span>
<span class="fc" id="L7517">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7518" title="1 of 2 branches missed.">    if (jj_scan_token(115)) {</span>
<span class="fc" id="L7519">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L7520" title="All 2 branches covered.">    if (jj_3R_91()) return true;</span>
    }
    }
<span class="fc" id="L7523">    return false;</span>
  }

  private boolean jj_3R_293()
 {
<span class="nc bnc" id="L7528" title="All 2 branches missed.">    if (jj_3R_304()) return true;</span>
<span class="nc" id="L7529">    return false;</span>
  }

  private boolean jj_3R_294()
 {
<span class="nc bnc" id="L7534" title="All 2 branches missed.">    if (jj_3R_305()) return true;</span>
<span class="nc" id="L7535">    return false;</span>
  }

  private boolean jj_3R_245()
 {
    Token xsp;
<span class="fc" id="L7541">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L7542" title="1 of 2 branches missed.">    if (jj_scan_token(28)) jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7543" title="1 of 2 branches missed.">    if (jj_scan_token(LOCAL)) return true;</span>
<span class="nc bnc" id="L7544" title="All 2 branches missed.">    if (jj_3R_109()) return true;</span>
<span class="nc" id="L7545">    return false;</span>
  }

  private boolean jj_3R_303()
 {
    Token xsp;
<span class="fc" id="L7551">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L7552" title="All 2 branches covered.">    if (jj_3R_318()) {</span>
<span class="fc" id="L7553">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7554" title="1 of 2 branches missed.">    if (jj_3R_319()) return true;</span>
    }
<span class="fc" id="L7556">    return false;</span>
  }

  private boolean jj_3R_318()
 {
    Token xsp;
<span class="fc bfc" id="L7562" title="All 2 branches covered.">    if (jj_3R_324()) return true;</span>
    while (true) {
<span class="fc" id="L7564">      xsp = jj_scanpos;</span>
<span class="fc bfc" id="L7565" title="All 2 branches covered.">      if (jj_3R_324()) { jj_scanpos = xsp; break; }</span>
    }
<span class="fc" id="L7567">    return false;</span>
  }

  private boolean jj_3R_97()
 {
    Token xsp;
<span class="fc" id="L7573">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L7574" title="All 2 branches covered.">    if (jj_3R_125()) {</span>
<span class="fc" id="L7575">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7576" title="1 of 2 branches missed.">    if (jj_3R_126()) {</span>
<span class="fc" id="L7577">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7578" title="1 of 2 branches missed.">    if (jj_3R_127()) {</span>
<span class="fc" id="L7579">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7580" title="1 of 2 branches missed.">    if (jj_3R_128()) {</span>
<span class="fc" id="L7581">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7582" title="1 of 2 branches missed.">    if (jj_3R_129()) {</span>
<span class="fc" id="L7583">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7584" title="1 of 2 branches missed.">    if (jj_3R_130()) {</span>
<span class="fc" id="L7585">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7586" title="1 of 2 branches missed.">    if (jj_3R_131()) {</span>
<span class="fc" id="L7587">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7588" title="1 of 2 branches missed.">    if (jj_3R_132()) return true;</span>
    }
    }
    }
    }
    }
    }
    }
<span class="fc" id="L7596">    return false;</span>
  }

  private boolean jj_3R_112()
 {
<span class="fc bfc" id="L7601" title="All 2 branches covered.">    if (jj_3R_84()) return true;</span>
    Token xsp;
    while (true) {
<span class="fc" id="L7604">      xsp = jj_scanpos;</span>
<span class="pc bpc" id="L7605" title="1 of 2 branches missed.">      if (jj_3R_295()) { jj_scanpos = xsp; break; }</span>
    }
<span class="fc" id="L7607">    return false;</span>
  }

  private boolean jj_3R_324()
 {
<span class="fc bfc" id="L7612" title="All 2 branches covered.">    if (jj_scan_token(116)) return true;</span>
<span class="pc bpc" id="L7613" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="fc" id="L7614">    return false;</span>
  }

  private boolean jj_3R_125()
 {
<span class="fc bfc" id="L7619" title="All 2 branches covered.">    if (jj_3R_150()) return true;</span>
<span class="fc" id="L7620">    return false;</span>
  }

  private boolean jj_3R_235()
 {
<span class="pc bpc" id="L7625" title="1 of 2 branches missed.">    if (jj_scan_token(IF)) return true;</span>
<span class="nc bnc" id="L7626" title="All 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="nc bnc" id="L7627" title="All 2 branches missed.">    if (jj_scan_token(THEN)) return true;</span>
<span class="nc bnc" id="L7628" title="All 2 branches missed.">    if (jj_3R_93()) return true;</span>
    Token xsp;
<span class="nc" id="L7630">    xsp = jj_scanpos;</span>
<span class="nc bnc" id="L7631" title="All 2 branches missed.">    if (jj_3R_254()) jj_scanpos = xsp;</span>
<span class="nc bnc" id="L7632" title="All 2 branches missed.">    if (jj_scan_token(ENDIF)) return true;</span>
<span class="nc" id="L7633">    return false;</span>
  }

  private boolean jj_3R_126()
 {
<span class="pc bpc" id="L7638" title="1 of 2 branches missed.">    if (jj_3R_151()) return true;</span>
<span class="nc" id="L7639">    return false;</span>
  }

  private boolean jj_3R_307()
 {
<span class="fc bfc" id="L7644" title="All 2 branches covered.">    if (jj_scan_token(120)) return true;</span>
<span class="pc bpc" id="L7645" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="fc" id="L7646">    return false;</span>
  }

  private boolean jj_3R_127()
 {
<span class="pc bpc" id="L7651" title="1 of 2 branches missed.">    if (jj_3R_152()) return true;</span>
<span class="nc" id="L7652">    return false;</span>
  }

  private boolean jj_3R_295()
 {
<span class="pc bpc" id="L7657" title="1 of 2 branches missed.">    if (jj_scan_token(PWR)) return true;</span>
<span class="nc bnc" id="L7658" title="All 2 branches missed.">    if (jj_3R_84()) return true;</span>
<span class="nc" id="L7659">    return false;</span>
  }

  private boolean jj_3R_128()
 {
<span class="pc bpc" id="L7664" title="1 of 2 branches missed.">    if (jj_3R_153()) return true;</span>
<span class="nc" id="L7665">    return false;</span>
  }

  private boolean jj_3R_129()
 {
<span class="pc bpc" id="L7670" title="1 of 2 branches missed.">    if (jj_3R_154()) return true;</span>
<span class="nc" id="L7671">    return false;</span>
  }

  private boolean jj_3R_130()
 {
<span class="pc bpc" id="L7676" title="1 of 2 branches missed.">    if (jj_3R_155()) return true;</span>
<span class="nc" id="L7677">    return false;</span>
  }

  private boolean jj_3R_304()
 {
<span class="nc bnc" id="L7682" title="All 2 branches missed.">    if (jj_scan_token(WHILEREC)) return true;</span>
<span class="nc" id="L7683">    return false;</span>
  }

  private boolean jj_3R_131()
 {
<span class="pc bpc" id="L7688" title="1 of 2 branches missed.">    if (jj_3R_156()) return true;</span>
<span class="nc" id="L7689">    return false;</span>
  }

  private boolean jj_3R_132()
 {
<span class="pc bpc" id="L7694" title="1 of 2 branches missed.">    if (jj_3R_157()) return true;</span>
<span class="nc" id="L7695">    return false;</span>
  }

  private boolean jj_3R_157()
 {
<span class="pc bpc" id="L7700" title="1 of 2 branches missed.">    if (jj_scan_token(EXTEND)) return true;</span>
<span class="nc bnc" id="L7701" title="All 2 branches missed.">    if (jj_3R_105()) return true;</span>
<span class="nc" id="L7702">    return false;</span>
  }

  private boolean jj_3R_319()
 {
<span class="pc bpc" id="L7707" title="1 of 2 branches missed.">    if (jj_scan_token(118)) return true;</span>
<span class="pc bpc" id="L7708" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
    Token xsp;
<span class="fc" id="L7710">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L7711" title="All 2 branches covered.">    if (jj_3R_325()) jj_scanpos = xsp;</span>
<span class="fc" id="L7712">    return false;</span>
  }

  private boolean jj_3R_96()
 {
<span class="fc bfc" id="L7717" title="All 2 branches covered.">    if (jj_scan_token(120)) return true;</span>
<span class="pc bpc" id="L7718" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="fc" id="L7719">    return false;</span>
  }

  private boolean jj_3_12()
 {
<span class="pc bpc" id="L7724" title="1 of 2 branches missed.">    if (jj_3R_64()) return true;</span>
<span class="pc bpc" id="L7725" title="1 of 2 branches missed.">    if (jj_scan_token(122)) return true;</span>
<span class="nc" id="L7726">    return false;</span>
  }

  private boolean jj_3R_325()
 {
<span class="fc bfc" id="L7731" title="All 2 branches covered.">    if (jj_scan_token(116)) return true;</span>
<span class="pc bpc" id="L7732" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="fc" id="L7733">    return false;</span>
  }

  private boolean jj_3R_150()
 {
<span class="fc bfc" id="L7738" title="All 2 branches covered.">    if (jj_scan_token(Skip)) return true;</span>
<span class="fc" id="L7739">    return false;</span>
  }

  private boolean jj_3R_121()
 {
<span class="fc bfc" id="L7744" title="All 2 branches covered.">    if (jj_scan_token(116)) return true;</span>
<span class="pc bpc" id="L7745" title="1 of 2 branches missed.">    if (jj_3R_94()) return true;</span>
<span class="pc bpc" id="L7746" title="1 of 2 branches missed.">    if (jj_scan_token(IN)) return true;</span>
<span class="pc bpc" id="L7747" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="fc" id="L7748">    return false;</span>
  }

  private boolean jj_3R_254()
 {
<span class="nc bnc" id="L7753" title="All 2 branches missed.">    if (jj_scan_token(ELSE)) return true;</span>
<span class="nc bnc" id="L7754" title="All 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="nc" id="L7755">    return false;</span>
  }

  private boolean jj_3R_84()
 {
    Token xsp;
<span class="fc" id="L7761">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L7762" title="All 2 branches covered.">    if (jj_3R_113()) {</span>
<span class="fc" id="L7763">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L7764" title="All 2 branches covered.">    if (jj_3R_114()) return true;</span>
    }
<span class="fc" id="L7766">    return false;</span>
  }

  private boolean jj_3R_113()
 {
    Token xsp;
<span class="fc" id="L7772">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L7773" title="All 2 branches covered.">    if (jj_3_23()) {</span>
<span class="fc" id="L7774">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L7775" title="All 2 branches covered.">    if (jj_3R_141()) return true;</span>
    }
<span class="fc" id="L7777">    return false;</span>
  }

  private boolean jj_3_23()
 {
<span class="fc bfc" id="L7782" title="All 2 branches covered.">    if (jj_scan_token(PLUS)) return true;</span>
<span class="pc bpc" id="L7783" title="1 of 2 branches missed.">    if (jj_3R_84()) return true;</span>
<span class="fc" id="L7784">    return false;</span>
  }

  private boolean jj_3R_68()
 {
    Token xsp;
<span class="fc" id="L7790">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L7791" title="All 2 branches covered.">    if (jj_scan_token(28)) jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7792" title="1 of 2 branches missed.">    if (jj_scan_token(CONTROLLED)) return true;</span>
<span class="nc bnc" id="L7793" title="All 2 branches missed.">    if (jj_3R_109()) return true;</span>
<span class="nc" id="L7794">    return false;</span>
  }

  private boolean jj_3R_241()
 {
    Token xsp;
<span class="fc" id="L7800">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L7801" title="1 of 2 branches missed.">    if (jj_3R_262()) {</span>
<span class="fc" id="L7802">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7803" title="1 of 2 branches missed.">    if (jj_3R_263()) return true;</span>
    }
<span class="nc" id="L7805">    return false;</span>
  }

  private boolean jj_3R_59()
 {
    Token xsp;
<span class="fc" id="L7811">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L7812" title="1 of 2 branches missed.">    if (jj_3_5()) {</span>
<span class="fc" id="L7813">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7814" title="1 of 2 branches missed.">    if (jj_3R_102()) return true;</span>
    }
<span class="nc" id="L7816">    return false;</span>
  }

  private boolean jj_3R_141()
 {
<span class="fc bfc" id="L7821" title="All 2 branches covered.">    if (jj_scan_token(MINUS)) return true;</span>
<span class="pc bpc" id="L7822" title="1 of 2 branches missed.">    if (jj_3R_84()) return true;</span>
<span class="fc" id="L7823">    return false;</span>
  }

  private boolean jj_3_5()
 {
<span class="pc bpc" id="L7828" title="1 of 2 branches missed.">    if (jj_3R_63()) return true;</span>
<span class="nc" id="L7829">    return false;</span>
  }

  private boolean jj_3R_102()
 {
<span class="pc bpc" id="L7834" title="1 of 2 branches missed.">    if (jj_3R_134()) return true;</span>
<span class="nc" id="L7835">    return false;</span>
  }

  private boolean jj_3R_305()
 {
<span class="nc bnc" id="L7840" title="All 2 branches missed.">    if (jj_scan_token(WHILE)) return true;</span>
<span class="nc" id="L7841">    return false;</span>
  }

  private boolean jj_3R_262()
 {
<span class="pc bpc" id="L7846" title="1 of 2 branches missed.">    if (jj_3R_133()) return true;</span>
<span class="nc" id="L7847">    return false;</span>
  }

  private boolean jj_3R_297()
 {
<span class="fc bfc" id="L7852" title="All 2 branches covered.">    if (jj_scan_token(119)) return true;</span>
<span class="pc bpc" id="L7853" title="1 of 2 branches missed.">    if (jj_3R_94()) return true;</span>
<span class="nc bnc" id="L7854" title="All 2 branches missed.">    if (jj_scan_token(IN)) return true;</span>
<span class="nc bnc" id="L7855" title="All 2 branches missed.">    if (jj_3R_93()) return true;</span>
    Token xsp;
    while (true) {
<span class="nc" id="L7858">      xsp = jj_scanpos;</span>
<span class="nc bnc" id="L7859" title="All 2 branches missed.">      if (jj_3R_308()) { jj_scanpos = xsp; break; }</span>
    }
<span class="nc" id="L7861">    xsp = jj_scanpos;</span>
<span class="nc bnc" id="L7862" title="All 2 branches missed.">    if (jj_3R_309()) jj_scanpos = xsp;</span>
<span class="nc bnc" id="L7863" title="All 2 branches missed.">    if (jj_scan_token(118)) return true;</span>
<span class="nc bnc" id="L7864" title="All 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="nc bnc" id="L7865" title="All 2 branches missed.">    if (jj_scan_token(122)) return true;</span>
<span class="nc bnc" id="L7866" title="All 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="nc bnc" id="L7867" title="All 2 branches missed.">    if (jj_scan_token(120)) return true;</span>
<span class="nc bnc" id="L7868" title="All 2 branches missed.">    if (jj_scan_token(121)) return true;</span>
<span class="nc" id="L7869">    return false;</span>
  }

  private boolean jj_3R_263()
 {
<span class="pc bpc" id="L7874" title="1 of 2 branches missed.">    if (jj_3R_94()) return true;</span>
<span class="nc" id="L7875">    return false;</span>
  }

  private boolean jj_3R_114()
 {
<span class="fc bfc" id="L7880" title="All 2 branches covered.">    if (jj_3R_142()) return true;</span>
<span class="fc" id="L7881">    return false;</span>
  }

  private boolean jj_3_13()
 {
<span class="pc bpc" id="L7886" title="1 of 2 branches missed.">    if (jj_3R_64()) return true;</span>
<span class="fc bfc" id="L7887" title="All 2 branches covered.">    if (jj_scan_token(122)) return true;</span>
<span class="fc" id="L7888">    return false;</span>
  }

  private boolean jj_3R_236()
 {
<span class="pc bpc" id="L7893" title="1 of 2 branches missed.">    if (jj_scan_token(SWITCH)) return true;</span>
<span class="nc bnc" id="L7894" title="All 2 branches missed.">    if (jj_3R_93()) return true;</span>
    Token xsp;
<span class="nc bnc" id="L7896" title="All 2 branches missed.">    if (jj_3R_255()) return true;</span>
    while (true) {
<span class="nc" id="L7898">      xsp = jj_scanpos;</span>
<span class="nc bnc" id="L7899" title="All 2 branches missed.">      if (jj_3R_255()) { jj_scanpos = xsp; break; }</span>
    }
<span class="nc" id="L7901">    xsp = jj_scanpos;</span>
<span class="nc bnc" id="L7902" title="All 2 branches missed.">    if (jj_3R_256()) jj_scanpos = xsp;</span>
<span class="nc bnc" id="L7903" title="All 2 branches missed.">    if (jj_scan_token(END_SWITCH)) return true;</span>
<span class="nc" id="L7904">    return false;</span>
  }

  private boolean jj_3R_63()
 {
    Token xsp;
<span class="fc" id="L7910">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L7911" title="All 2 branches covered.">    if (jj_3R_106()) jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7912" title="1 of 2 branches missed.">    if (jj_scan_token(DOMAIN)) return true;</span>
<span class="nc bnc" id="L7913" title="All 2 branches missed.">    if (jj_3R_105()) return true;</span>
<span class="nc" id="L7914">    return false;</span>
  }

  private boolean jj_3R_122()
 {
<span class="fc bfc" id="L7919" title="All 2 branches covered.">    if (jj_scan_token(120)) return true;</span>
<span class="pc bpc" id="L7920" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="fc" id="L7921">    return false;</span>
  }

  private boolean jj_3R_106()
 {
<span class="fc bfc" id="L7926" title="All 2 branches covered.">    if (jj_scan_token(DYNAMIC)) return true;</span>
<span class="fc" id="L7927">    return false;</span>
  }

  private boolean jj_3R_142()
 {
    Token xsp;
<span class="fc" id="L7933">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L7934" title="All 2 branches covered.">    if (jj_3R_175()) {</span>
<span class="fc" id="L7935">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L7936" title="All 2 branches covered.">    if (jj_3R_176()) {</span>
<span class="fc" id="L7937">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L7938" title="All 2 branches covered.">    if (jj_3R_177()) {</span>
<span class="fc" id="L7939">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L7940" title="All 2 branches covered.">    if (jj_3R_178()) return true;</span>
    }
    }
    }
<span class="fc" id="L7944">    return false;</span>
  }

  private boolean jj_3R_237()
 {
    Token xsp;
<span class="fc" id="L7950">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L7951" title="1 of 2 branches missed.">    if (jj_3R_247()) {</span>
<span class="fc" id="L7952">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L7953" title="1 of 2 branches missed.">    if (jj_3R_248()) {</span>
<span class="fc" id="L7954">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L7955" title="All 2 branches covered.">    if (jj_3R_249()) return true;</span>
    }
    }
<span class="fc" id="L7958">    return false;</span>
  }

  private boolean jj_3R_175()
 {
<span class="fc bfc" id="L7963" title="All 2 branches covered.">    if (jj_3R_85()) return true;</span>
<span class="fc" id="L7964">    return false;</span>
  }

  private boolean jj_3R_247()
 {
<span class="pc bpc" id="L7969" title="1 of 2 branches missed.">    if (jj_3R_271()) return true;</span>
<span class="nc" id="L7970">    return false;</span>
  }

  private boolean jj_3R_248()
 {
<span class="pc bpc" id="L7975" title="1 of 2 branches missed.">    if (jj_3R_86()) return true;</span>
<span class="nc" id="L7976">    return false;</span>
  }

  private boolean jj_3R_176()
 {
<span class="fc bfc" id="L7981" title="All 2 branches covered.">    if (jj_3R_210()) return true;</span>
<span class="fc" id="L7982">    return false;</span>
  }

  private boolean jj_3R_249()
 {
<span class="fc bfc" id="L7987" title="All 2 branches covered.">    if (jj_3R_272()) return true;</span>
<span class="fc" id="L7988">    return false;</span>
  }

  private boolean jj_3R_177()
 {
<span class="fc bfc" id="L7993" title="All 2 branches covered.">    if (jj_3R_86()) return true;</span>
<span class="fc" id="L7994">    return false;</span>
  }

  private boolean jj_3R_178()
 {
<span class="fc bfc" id="L7999" title="All 2 branches covered.">    if (jj_scan_token(115)) return true;</span>
<span class="pc bpc" id="L8000" title="1 of 2 branches missed.">    if (jj_3R_69()) return true;</span>
<span class="fc bfc" id="L8001" title="All 2 branches covered.">    if (jj_scan_token(117)) return true;</span>
<span class="fc" id="L8002">    return false;</span>
  }

  private boolean jj_3R_255()
 {
<span class="nc bnc" id="L8007" title="All 2 branches missed.">    if (jj_scan_token(CASE)) return true;</span>
<span class="nc bnc" id="L8008" title="All 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="nc bnc" id="L8009" title="All 2 branches missed.">    if (jj_scan_token(118)) return true;</span>
<span class="nc bnc" id="L8010" title="All 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="nc" id="L8011">    return false;</span>
  }

  private boolean jj_3R_67()
 {
    Token xsp;
<span class="fc" id="L8017">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L8018" title="All 2 branches covered.">    if (jj_scan_token(28)) jj_scanpos = xsp;</span>
<span class="pc bpc" id="L8019" title="1 of 2 branches missed.">    if (jj_scan_token(SHARED)) return true;</span>
<span class="nc bnc" id="L8020" title="All 2 branches missed.">    if (jj_3R_109()) return true;</span>
<span class="nc" id="L8021">    return false;</span>
  }

  private boolean jj_3_24()
 {
<span class="fc bfc" id="L8026" title="All 2 branches covered.">    if (jj_3R_85()) return true;</span>
<span class="fc" id="L8027">    return false;</span>
  }

  private boolean jj_3R_308()
 {
<span class="nc bnc" id="L8032" title="All 2 branches missed.">    if (jj_scan_token(116)) return true;</span>
<span class="nc bnc" id="L8033" title="All 2 branches missed.">    if (jj_3R_94()) return true;</span>
<span class="nc bnc" id="L8034" title="All 2 branches missed.">    if (jj_scan_token(IN)) return true;</span>
<span class="nc bnc" id="L8035" title="All 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="nc" id="L8036">    return false;</span>
  }

  private boolean jj_3R_86()
 {
    Token xsp;
<span class="fc" id="L8042">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L8043" title="All 2 branches covered.">    if (jj_3R_118()) {</span>
<span class="fc" id="L8044">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L8045" title="All 2 branches covered.">    if (jj_3R_119()) {</span>
<span class="fc" id="L8046">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L8047" title="All 2 branches covered.">    if (jj_3R_120()) return true;</span>
    }
    }
<span class="fc" id="L8050">    return false;</span>
  }

  private boolean jj_3_25()
 {
<span class="fc bfc" id="L8055" title="All 2 branches covered.">    if (jj_3R_86()) return true;</span>
<span class="fc" id="L8056">    return false;</span>
  }

  private boolean jj_3R_118()
 {
<span class="fc bfc" id="L8061" title="All 2 branches covered.">    if (jj_3R_145()) return true;</span>
<span class="fc" id="L8062">    return false;</span>
  }

  private boolean jj_3R_119()
 {
<span class="fc bfc" id="L8067" title="All 2 branches covered.">    if (jj_3R_146()) return true;</span>
<span class="fc" id="L8068">    return false;</span>
  }

  private boolean jj_3R_124()
 {
<span class="fc bfc" id="L8073" title="All 2 branches covered.">    if (jj_scan_token(ID_VARIABLE)) return true;</span>
<span class="fc" id="L8074">    return false;</span>
  }

  private boolean jj_3R_240()
 {
    Token xsp;
<span class="fc" id="L8080">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L8081" title="1 of 2 branches missed.">    if (jj_3R_258()) {</span>
<span class="fc" id="L8082">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L8083" title="1 of 2 branches missed.">    if (jj_3R_259()) {</span>
<span class="fc" id="L8084">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L8085" title="1 of 2 branches missed.">    if (jj_3R_260()) {</span>
<span class="fc" id="L8086">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L8087" title="1 of 2 branches missed.">    if (jj_3R_261()) return true;</span>
    }
    }
    }
<span class="nc" id="L8091">    return false;</span>
  }

  private boolean jj_3R_120()
 {
<span class="fc bfc" id="L8096" title="All 2 branches covered.">    if (jj_3R_147()) return true;</span>
<span class="fc" id="L8097">    return false;</span>
  }

  private boolean jj_3R_258()
 {
<span class="pc bpc" id="L8102" title="1 of 2 branches missed.">    if (jj_3R_278()) return true;</span>
<span class="nc" id="L8103">    return false;</span>
  }

  private boolean jj_3R_134()
 {
    Token xsp;
<span class="fc" id="L8109">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L8110" title="1 of 2 branches missed.">    if (jj_3R_159()) {</span>
<span class="fc" id="L8111">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L8112" title="1 of 2 branches missed.">    if (jj_3R_160()) {</span>
<span class="fc" id="L8113">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L8114" title="1 of 2 branches missed.">    if (jj_3R_161()) {</span>
<span class="fc" id="L8115">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L8116" title="1 of 2 branches missed.">    if (jj_3R_162()) {</span>
<span class="fc" id="L8117">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L8118" title="1 of 2 branches missed.">    if (jj_3R_163()) return true;</span>
    }
    }
    }
    }
<span class="nc" id="L8123">    return false;</span>
  }

  private boolean jj_3R_256()
 {
<span class="nc bnc" id="L8128" title="All 2 branches missed.">    if (jj_scan_token(OTHERWISE)) return true;</span>
<span class="nc bnc" id="L8129" title="All 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="nc" id="L8130">    return false;</span>
  }

  private boolean jj_3R_259()
 {
<span class="pc bpc" id="L8135" title="1 of 2 branches missed.">    if (jj_3R_279()) return true;</span>
<span class="nc" id="L8136">    return false;</span>
  }

  private boolean jj_3R_85()
 {
    Token xsp;
<span class="fc" id="L8142">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L8143" title="All 2 branches covered.">    if (jj_3R_115()) {</span>
<span class="fc" id="L8144">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L8145" title="All 2 branches covered.">    if (jj_3R_116()) {</span>
<span class="fc" id="L8146">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L8147" title="All 2 branches covered.">    if (jj_3R_117()) return true;</span>
    }
    }
<span class="fc" id="L8150">    return false;</span>
  }

  private boolean jj_3R_260()
 {
<span class="pc bpc" id="L8155" title="1 of 2 branches missed.">    if (jj_3R_280()) return true;</span>
<span class="nc" id="L8156">    return false;</span>
  }

  private boolean jj_3R_261()
 {
<span class="pc bpc" id="L8161" title="1 of 2 branches missed.">    if (jj_3R_281()) return true;</span>
<span class="nc" id="L8162">    return false;</span>
  }

  private boolean jj_3_37()
 {
<span class="pc bpc" id="L8167" title="1 of 2 branches missed.">    if (jj_scan_token(115)) return true;</span>
<span class="fc bfc" id="L8168" title="All 2 branches covered.">    if (jj_scan_token(FORALL)) return true;</span>
<span class="fc" id="L8169">    return false;</span>
  }

  private boolean jj_3R_159()
 {
<span class="pc bpc" id="L8174" title="1 of 2 branches missed.">    if (jj_3R_198()) return true;</span>
<span class="nc" id="L8175">    return false;</span>
  }

  private boolean jj_3R_115()
 {
<span class="fc bfc" id="L8180" title="All 2 branches covered.">    if (jj_3R_143()) return true;</span>
<span class="fc" id="L8181">    return false;</span>
  }

  private boolean jj_3R_160()
 {
<span class="pc bpc" id="L8186" title="1 of 2 branches missed.">    if (jj_3R_137()) return true;</span>
<span class="nc" id="L8187">    return false;</span>
  }

  private boolean jj_3_38()
 {
<span class="pc bpc" id="L8192" title="1 of 2 branches missed.">    if (jj_scan_token(115)) return true;</span>
<span class="pc bpc" id="L8193" title="1 of 2 branches missed.">    if (jj_scan_token(EXIST)) return true;</span>
<span class="fc bfc" id="L8194" title="All 2 branches covered.">    if (jj_scan_token(UNIQUE)) return true;</span>
<span class="fc" id="L8195">    return false;</span>
  }

  private boolean jj_3R_116()
 {
<span class="fc bfc" id="L8200" title="All 2 branches covered.">    if (jj_3R_94()) return true;</span>
<span class="fc" id="L8201">    return false;</span>
  }

  private boolean jj_3R_161()
 {
<span class="pc bpc" id="L8206" title="1 of 2 branches missed.">    if (jj_3R_199()) return true;</span>
<span class="nc" id="L8207">    return false;</span>
  }

  private boolean jj_3R_117()
 {
<span class="fc bfc" id="L8212" title="All 2 branches covered.">    if (jj_3R_144()) return true;</span>
<span class="fc" id="L8213">    return false;</span>
  }

  private boolean jj_3R_162()
 {
<span class="pc bpc" id="L8218" title="1 of 2 branches missed.">    if (jj_3R_200()) return true;</span>
<span class="nc" id="L8219">    return false;</span>
  }

  private boolean jj_3R_234()
 {
<span class="fc bfc" id="L8224" title="All 2 branches covered.">    if (jj_scan_token(ID_ENUM)) return true;</span>
<span class="fc" id="L8225">    return false;</span>
  }

  private boolean jj_3_14()
 {
<span class="pc bpc" id="L8230" title="1 of 2 branches missed.">    if (jj_3R_64()) return true;</span>
<span class="fc bfc" id="L8231" title="All 2 branches covered.">    if (jj_scan_token(122)) return true;</span>
<span class="fc" id="L8232">    return false;</span>
  }

  private boolean jj_3R_152()
 {
<span class="pc bpc" id="L8237" title="1 of 2 branches missed.">    if (jj_scan_token(PAR)) return true;</span>
<span class="nc bnc" id="L8238" title="All 2 branches missed.">    if (jj_3R_197()) return true;</span>
<span class="nc" id="L8239">    return false;</span>
  }

  private boolean jj_3R_163()
 {
<span class="pc bpc" id="L8244" title="1 of 2 branches missed.">    if (jj_3R_201()) return true;</span>
<span class="nc" id="L8245">    return false;</span>
  }

  private boolean jj_3R_309()
 {
<span class="nc bnc" id="L8250" title="All 2 branches missed.">    if (jj_scan_token(120)) return true;</span>
<span class="nc bnc" id="L8251" title="All 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="nc" id="L8252">    return false;</span>
  }

  private boolean jj_3R_278()
 {
<span class="pc bpc" id="L8257" title="1 of 2 branches missed.">    if (jj_scan_token(seq)) return true;</span>
<span class="nc" id="L8258">    return false;</span>
  }

  private boolean jj_3R_105()
 {
<span class="fc bfc" id="L8263" title="All 2 branches covered.">    if (jj_scan_token(ID_DOMAIN)) return true;</span>
<span class="fc" id="L8264">    return false;</span>
  }

  private boolean jj_3R_198()
 {
<span class="pc bpc" id="L8269" title="1 of 2 branches missed.">    if (jj_scan_token(ANYDOMAIN)) return true;</span>
<span class="nc bnc" id="L8270" title="All 2 branches missed.">    if (jj_3R_105()) return true;</span>
<span class="nc" id="L8271">    return false;</span>
  }

  private boolean jj_3R_144()
 {
    Token xsp;
<span class="fc" id="L8277">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L8278" title="1 of 2 branches missed.">    if (jj_3_26()) jj_scanpos = xsp;</span>
<span class="fc bfc" id="L8279" title="All 2 branches covered.">    if (jj_3R_109()) return true;</span>
<span class="fc" id="L8280">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L8281" title="All 2 branches covered.">    if (jj_3R_188()) jj_scanpos = xsp;</span>
<span class="fc" id="L8282">    return false;</span>
  }

  private boolean jj_3R_147()
 {
<span class="fc bfc" id="L8287" title="All 2 branches covered.">    if (jj_scan_token(115)) return true;</span>
<span class="fc bfc" id="L8288" title="All 2 branches covered.">    if (jj_scan_token(EXIST)) return true;</span>
<span class="pc bpc" id="L8289" title="1 of 2 branches missed.">    if (jj_3R_94()) return true;</span>
<span class="pc bpc" id="L8290" title="1 of 2 branches missed.">    if (jj_scan_token(IN)) return true;</span>
<span class="pc bpc" id="L8291" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
    Token xsp;
    while (true) {
<span class="fc" id="L8294">      xsp = jj_scanpos;</span>
<span class="fc bfc" id="L8295" title="All 2 branches covered.">      if (jj_3R_193()) { jj_scanpos = xsp; break; }</span>
    }
<span class="fc" id="L8297">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L8298" title="All 2 branches covered.">    if (jj_3R_194()) jj_scanpos = xsp;</span>
<span class="pc bpc" id="L8299" title="1 of 2 branches missed.">    if (jj_scan_token(117)) return true;</span>
<span class="fc" id="L8300">    return false;</span>
  }

  private boolean jj_3R_66()
 {
    Token xsp;
<span class="fc" id="L8306">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L8307" title="All 2 branches covered.">    if (jj_scan_token(28)) jj_scanpos = xsp;</span>
<span class="pc bpc" id="L8308" title="1 of 2 branches missed.">    if (jj_scan_token(MONITORED)) return true;</span>
<span class="nc bnc" id="L8309" title="All 2 branches missed.">    if (jj_3R_109()) return true;</span>
<span class="nc" id="L8310">    return false;</span>
  }

  private boolean jj_3_26()
 {
<span class="fc bfc" id="L8315" title="All 2 branches covered.">    if (jj_3R_87()) return true;</span>
<span class="pc bpc" id="L8316" title="1 of 2 branches missed.">    if (jj_scan_token(123)) return true;</span>
<span class="nc" id="L8317">    return false;</span>
  }

  private boolean jj_3R_196()
 {
<span class="fc bfc" id="L8322" title="All 2 branches covered.">    if (jj_scan_token(ID_RULE)) return true;</span>
<span class="fc" id="L8323">    return false;</span>
  }

  private boolean jj_3R_90()
 {
<span class="fc bfc" id="L8328" title="All 2 branches covered.">    if (jj_scan_token(115)) return true;</span>
<span class="pc bpc" id="L8329" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
    Token xsp;
    while (true) {
<span class="fc" id="L8332">      xsp = jj_scanpos;</span>
<span class="fc bfc" id="L8333" title="All 2 branches covered.">      if (jj_3R_229()) { jj_scanpos = xsp; break; }</span>
    }
<span class="pc bpc" id="L8335" title="1 of 2 branches missed.">    if (jj_scan_token(117)) return true;</span>
<span class="fc" id="L8336">    return false;</span>
  }

  private boolean jj_3R_188()
 {
<span class="fc bfc" id="L8341" title="All 2 branches covered.">    if (jj_3R_90()) return true;</span>
<span class="fc" id="L8342">    return false;</span>
  }

  private boolean jj_3R_153()
 {
<span class="pc bpc" id="L8347" title="1 of 2 branches missed.">    if (jj_scan_token(IF)) return true;</span>
<span class="nc bnc" id="L8348" title="All 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="nc" id="L8349">    return false;</span>
  }

  private boolean jj_3R_201()
 {
<span class="pc bpc" id="L8354" title="1 of 2 branches missed.">    if (jj_scan_token(BASIC)) return true;</span>
<span class="nc bnc" id="L8355" title="All 2 branches missed.">    if (jj_scan_token(DOMAIN)) return true;</span>
<span class="nc" id="L8356">    return false;</span>
  }

  private boolean jj_3R_279()
 {
<span class="pc bpc" id="L8361" title="1 of 2 branches missed.">    if (jj_scan_token(ITERATE)) return true;</span>
<span class="nc" id="L8362">    return false;</span>
  }

  private boolean jj_3_15()
 {
<span class="pc bpc" id="L8367" title="1 of 2 branches missed.">    if (jj_3R_64()) return true;</span>
<span class="fc bfc" id="L8368" title="All 2 branches covered.">    if (jj_scan_token(122)) return true;</span>
<span class="fc" id="L8369">    return false;</span>
  }

  private boolean jj_3R_193()
 {
<span class="fc bfc" id="L8374" title="All 2 branches covered.">    if (jj_scan_token(116)) return true;</span>
<span class="pc bpc" id="L8375" title="1 of 2 branches missed.">    if (jj_3R_94()) return true;</span>
<span class="pc bpc" id="L8376" title="1 of 2 branches missed.">    if (jj_scan_token(IN)) return true;</span>
<span class="pc bpc" id="L8377" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="fc" id="L8378">    return false;</span>
  }

  private boolean jj_3R_200()
 {
    Token xsp;
<span class="fc" id="L8384">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L8385" title="All 2 branches covered.">    if (jj_3R_230()) jj_scanpos = xsp;</span>
<span class="pc bpc" id="L8386" title="1 of 2 branches missed.">    if (jj_scan_token(ABSTRACT)) return true;</span>
<span class="nc bnc" id="L8387" title="All 2 branches missed.">    if (jj_scan_token(DOMAIN)) return true;</span>
<span class="nc" id="L8388">    return false;</span>
  }

  private boolean jj_3R_229()
 {
<span class="fc bfc" id="L8393" title="All 2 branches covered.">    if (jj_scan_token(116)) return true;</span>
<span class="pc bpc" id="L8394" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="fc" id="L8395">    return false;</span>
  }

  private boolean jj_3R_230()
 {
<span class="fc bfc" id="L8400" title="All 2 branches covered.">    if (jj_scan_token(DYNAMIC)) return true;</span>
<span class="fc" id="L8401">    return false;</span>
  }

  private boolean jj_3R_298()
 {
<span class="fc bfc" id="L8406" title="All 2 branches covered.">    if (jj_scan_token(124)) return true;</span>
<span class="fc bfc" id="L8407" title="All 2 branches covered.">    if (jj_3R_94()) return true;</span>
<span class="pc bpc" id="L8408" title="1 of 2 branches missed.">    if (jj_scan_token(IN)) return true;</span>
<span class="pc bpc" id="L8409" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
    Token xsp;
    while (true) {
<span class="fc" id="L8412">      xsp = jj_scanpos;</span>
<span class="pc bpc" id="L8413" title="1 of 2 branches missed.">      if (jj_3R_310()) { jj_scanpos = xsp; break; }</span>
    }
<span class="fc" id="L8415">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L8416" title="1 of 2 branches missed.">    if (jj_3R_311()) jj_scanpos = xsp;</span>
<span class="pc bpc" id="L8417" title="1 of 2 branches missed.">    if (jj_scan_token(118)) return true;</span>
<span class="pc bpc" id="L8418" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="pc bpc" id="L8419" title="1 of 2 branches missed.">    if (jj_scan_token(125)) return true;</span>
<span class="fc" id="L8420">    return false;</span>
  }

  private boolean jj_3R_65()
 {
    Token xsp;
<span class="fc" id="L8426">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L8427" title="All 2 branches covered.">    if (jj_scan_token(28)) jj_scanpos = xsp;</span>
<span class="pc bpc" id="L8428" title="1 of 2 branches missed.">    if (jj_scan_token(OUT)) return true;</span>
<span class="nc bnc" id="L8429" title="All 2 branches missed.">    if (jj_3R_109()) return true;</span>
<span class="nc" id="L8430">    return false;</span>
  }

  private boolean jj_3R_280()
 {
<span class="pc bpc" id="L8435" title="1 of 2 branches missed.">    if (jj_3R_196()) return true;</span>
<span class="nc" id="L8436">    return false;</span>
  }

  private boolean jj_3R_133()
 {
    Token xsp;
<span class="fc" id="L8442">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L8443" title="1 of 2 branches missed.">    if (jj_3_27()) jj_scanpos = xsp;</span>
<span class="fc bfc" id="L8444" title="All 2 branches covered.">    if (jj_3R_109()) return true;</span>
<span class="fc" id="L8445">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L8446" title="All 2 branches covered.">    if (jj_3R_158()) jj_scanpos = xsp;</span>
<span class="fc" id="L8447">    return false;</span>
  }

  private boolean jj_3R_194()
 {
<span class="fc bfc" id="L8452" title="All 2 branches covered.">    if (jj_scan_token(WITH)) return true;</span>
<span class="pc bpc" id="L8453" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="fc" id="L8454">    return false;</span>
  }

  private boolean jj_3R_109()
 {
<span class="fc bfc" id="L8459" title="All 2 branches covered.">    if (jj_scan_token(ID_FUNCTION)) return true;</span>
<span class="fc" id="L8460">    return false;</span>
  }

  private boolean jj_3_27()
 {
<span class="fc bfc" id="L8465" title="All 2 branches covered.">    if (jj_3R_87()) return true;</span>
<span class="pc bpc" id="L8466" title="1 of 2 branches missed.">    if (jj_scan_token(123)) return true;</span>
<span class="nc" id="L8467">    return false;</span>
  }

  private boolean jj_3_44()
 {
<span class="pc bpc" id="L8472" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="nc" id="L8473">    return false;</span>
  }

  private boolean jj_3_16()
 {
<span class="pc bpc" id="L8478" title="1 of 2 branches missed.">    if (jj_3R_64()) return true;</span>
<span class="fc bfc" id="L8479" title="All 2 branches covered.">    if (jj_scan_token(122)) return true;</span>
<span class="fc" id="L8480">    return false;</span>
  }

  private boolean jj_3R_87()
 {
<span class="fc bfc" id="L8485" title="All 2 branches covered.">    if (jj_scan_token(ID_FUNCTION)) return true;</span>
<span class="fc" id="L8486">    return false;</span>
  }

  private boolean jj_3R_154()
 {
<span class="pc bpc" id="L8491" title="1 of 2 branches missed.">    if (jj_scan_token(CHOOSE)) return true;</span>
<span class="nc bnc" id="L8492" title="All 2 branches missed.">    if (jj_3R_94()) return true;</span>
<span class="nc" id="L8493">    return false;</span>
  }

  private boolean jj_3R_158()
 {
<span class="fc bfc" id="L8498" title="All 2 branches covered.">    if (jj_3R_90()) return true;</span>
<span class="fc" id="L8499">    return false;</span>
  }

  private boolean jj_3R_199()
 {
<span class="pc bpc" id="L8504" title="1 of 2 branches missed.">    if (jj_scan_token(ENUM)) return true;</span>
<span class="nc bnc" id="L8505" title="All 2 branches missed.">    if (jj_scan_token(DOMAIN)) return true;</span>
<span class="nc" id="L8506">    return false;</span>
  }

  private boolean jj_3R_310()
 {
<span class="pc bpc" id="L8511" title="1 of 2 branches missed.">    if (jj_scan_token(116)) return true;</span>
<span class="nc bnc" id="L8512" title="All 2 branches missed.">    if (jj_3R_94()) return true;</span>
<span class="nc bnc" id="L8513" title="All 2 branches missed.">    if (jj_scan_token(IN)) return true;</span>
<span class="nc bnc" id="L8514" title="All 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="nc" id="L8515">    return false;</span>
  }

  private boolean jj_3R_238()
 {
    Token xsp;
<span class="fc" id="L8521">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L8522" title="All 2 branches covered.">    if (jj_3R_250()) {</span>
<span class="fc" id="L8523">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L8524" title="All 2 branches covered.">    if (jj_3R_251()) {</span>
<span class="fc" id="L8525">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L8526" title="All 2 branches covered.">    if (jj_3R_252()) {</span>
<span class="fc" id="L8527">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L8528" title="All 2 branches covered.">    if (jj_3R_253()) return true;</span>
    }
    }
    }
<span class="fc" id="L8532">    return false;</span>
  }

  private boolean jj_3R_250()
 {
<span class="fc bfc" id="L8537" title="All 2 branches covered.">    if (jj_3R_273()) return true;</span>
<span class="fc" id="L8538">    return false;</span>
  }

  private boolean jj_3R_251()
 {
<span class="fc bfc" id="L8543" title="All 2 branches covered.">    if (jj_3R_274()) return true;</span>
<span class="fc" id="L8544">    return false;</span>
  }

  private boolean jj_3R_146()
 {
<span class="fc bfc" id="L8549" title="All 2 branches covered.">    if (jj_scan_token(115)) return true;</span>
<span class="fc bfc" id="L8550" title="All 2 branches covered.">    if (jj_scan_token(EXIST)) return true;</span>
<span class="fc bfc" id="L8551" title="All 2 branches covered.">    if (jj_scan_token(UNIQUE)) return true;</span>
<span class="pc bpc" id="L8552" title="1 of 2 branches missed.">    if (jj_3R_94()) return true;</span>
<span class="pc bpc" id="L8553" title="1 of 2 branches missed.">    if (jj_scan_token(IN)) return true;</span>
<span class="pc bpc" id="L8554" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
    Token xsp;
    while (true) {
<span class="fc" id="L8557">      xsp = jj_scanpos;</span>
<span class="pc bpc" id="L8558" title="1 of 2 branches missed.">      if (jj_3R_191()) { jj_scanpos = xsp; break; }</span>
    }
<span class="fc" id="L8560">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L8561" title="1 of 2 branches missed.">    if (jj_3R_192()) jj_scanpos = xsp;</span>
<span class="pc bpc" id="L8562" title="1 of 2 branches missed.">    if (jj_scan_token(117)) return true;</span>
<span class="fc" id="L8563">    return false;</span>
  }

  private boolean jj_3R_252()
 {
<span class="fc bfc" id="L8568" title="All 2 branches covered.">    if (jj_3R_275()) return true;</span>
<span class="fc" id="L8569">    return false;</span>
  }

  private boolean jj_3R_253()
 {
<span class="fc bfc" id="L8574" title="All 2 branches covered.">    if (jj_3R_276()) return true;</span>
<span class="fc" id="L8575">    return false;</span>
  }

  private boolean jj_3R_93()
 {
<span class="fc bfc" id="L8580" title="All 2 branches covered.">    if (jj_3R_123()) return true;</span>
<span class="fc" id="L8581">    return false;</span>
  }

  private boolean jj_3_4()
 {
<span class="pc bpc" id="L8586" title="1 of 2 branches missed.">    if (jj_3R_62()) return true;</span>
<span class="nc" id="L8587">    return false;</span>
  }

  private boolean jj_3_32()
 {
<span class="fc bfc" id="L8592" title="All 2 branches covered.">    if (jj_scan_token(119)) return true;</span>
    Token xsp;
<span class="fc" id="L8594">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L8595" title="All 2 branches covered.">    if (jj_3R_92()) {</span>
<span class="fc" id="L8596">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L8597" title="1 of 2 branches missed.">    if (jj_scan_token(122)) return true;</span>
    }
<span class="fc" id="L8599">    return false;</span>
  }

  private boolean jj_3R_311()
 {
<span class="pc bpc" id="L8604" title="1 of 2 branches missed.">    if (jj_scan_token(120)) return true;</span>
<span class="pc bpc" id="L8605" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="fc" id="L8606">    return false;</span>
  }

  private boolean jj_3R_92()
 {
<span class="fc bfc" id="L8611" title="All 2 branches covered.">    if (jj_3R_93()) return true;</span>
<span class="fc bfc" id="L8612" title="All 2 branches covered.">    if (jj_scan_token(122)) return true;</span>
<span class="fc" id="L8613">    return false;</span>
  }

  private boolean jj_3R_123()
 {
    Token xsp;
<span class="fc" id="L8619">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L8620" title="All 2 branches covered.">    if (jj_3R_148()) {</span>
<span class="fc" id="L8621">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L8622" title="All 2 branches covered.">    if (jj_3R_149()) return true;</span>
    }
<span class="fc" id="L8624">    return false;</span>
  }

  private boolean jj_3R_148()
 {
<span class="fc bfc" id="L8629" title="All 2 branches covered.">    if (jj_3R_69()) return true;</span>
<span class="fc" id="L8630">    return false;</span>
  }

  private boolean jj_3R_149()
 {
<span class="fc bfc" id="L8635" title="All 2 branches covered.">    if (jj_3R_195()) return true;</span>
<span class="fc" id="L8636">    return false;</span>
  }

  private boolean jj_3R_273()
 {
<span class="fc bfc" id="L8641" title="All 2 branches covered.">    if (jj_scan_token(124)) return true;</span>
    Token xsp;
<span class="fc" id="L8643">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L8644" title="All 2 branches covered.">    if (jj_3_33()) jj_scanpos = xsp;</span>
<span class="pc bpc" id="L8645" title="1 of 2 branches missed.">    if (jj_scan_token(125)) return true;</span>
<span class="fc" id="L8646">    return false;</span>
  }

  private boolean jj_3_17()
 {
<span class="fc bfc" id="L8651" title="All 2 branches covered.">    if (jj_3R_69()) return true;</span>
<span class="fc" id="L8652">    return false;</span>
  }

  private boolean jj_3_33()
 {
<span class="fc bfc" id="L8657" title="All 2 branches covered.">    if (jj_3R_93()) return true;</span>
    Token xsp;
<span class="fc" id="L8659">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L8660" title="1 of 2 branches missed.">    if (jj_3R_300()) jj_scanpos = xsp;</span>
<span class="fc" id="L8661">    return false;</span>
  }

  private boolean jj_3R_94()
 {
<span class="fc bfc" id="L8666" title="All 2 branches covered.">    if (jj_3R_124()) return true;</span>
<span class="fc" id="L8667">    return false;</span>
  }

  private boolean jj_3R_191()
 {
<span class="pc bpc" id="L8672" title="1 of 2 branches missed.">    if (jj_scan_token(116)) return true;</span>
<span class="nc bnc" id="L8673" title="All 2 branches missed.">    if (jj_3R_94()) return true;</span>
<span class="nc bnc" id="L8674" title="All 2 branches missed.">    if (jj_scan_token(IN)) return true;</span>
<span class="nc bnc" id="L8675" title="All 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="nc" id="L8676">    return false;</span>
  }

  private boolean jj_3R_242()
 {
    Token xsp;
<span class="fc" id="L8682">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L8683" title="1 of 2 branches missed.">    if (jj_3R_264()) {</span>
<span class="fc" id="L8684">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L8685" title="1 of 2 branches missed.">    if (jj_3R_265()) return true;</span>
    }
<span class="nc" id="L8687">    return false;</span>
  }

  private boolean jj_3R_69()
 {
<span class="fc bfc" id="L8692" title="All 2 branches covered.">    if (jj_3R_110()) return true;</span>
    Token xsp;
    while (true) {
<span class="fc" id="L8695">      xsp = jj_scanpos;</span>
<span class="pc bpc" id="L8696" title="1 of 2 branches missed.">      if (jj_3_18()) { jj_scanpos = xsp; break; }</span>
    }
<span class="fc" id="L8698">    return false;</span>
  }

  private boolean jj_3_18()
 {
    Token xsp;
<span class="fc" id="L8704">    xsp = jj_scanpos;</span>
<span class="fc" id="L8705">    jj_lookingAhead = true;</span>
<span class="fc bfc" id="L8706" title="All 4 branches covered.">    jj_semLA = getToken(1).kind == ID_FUNCTION &amp;&amp; getToken(1).image.equals(&quot;implies&quot;);</span>
<span class="fc" id="L8707">    jj_lookingAhead = false;</span>
<span class="pc bpc" id="L8708" title="3 of 4 branches missed.">    if (!jj_semLA || jj_3R_70()) {</span>
<span class="fc" id="L8709">    jj_scanpos = xsp;</span>
<span class="fc" id="L8710">    jj_lookingAhead = true;</span>
<span class="fc bfc" id="L8711" title="All 4 branches covered.">    jj_semLA = getToken(1).kind == ID_FUNCTION &amp;&amp; getToken(1).image.equals(&quot;iff&quot;);</span>
<span class="fc" id="L8712">    jj_lookingAhead = false;</span>
<span class="pc bpc" id="L8713" title="3 of 4 branches missed.">    if (!jj_semLA || jj_3R_71()) return true;</span>
    }
<span class="nc" id="L8715">    return false;</span>
  }

  private boolean jj_3R_264()
 {
<span class="pc bpc" id="L8720" title="1 of 2 branches missed.">    if (jj_3R_133()) return true;</span>
<span class="nc" id="L8721">    return false;</span>
  }

  private boolean jj_3R_300()
 {
    Token xsp;
<span class="fc" id="L8727">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L8728" title="All 2 branches covered.">    if (jj_3R_314()) {</span>
<span class="fc" id="L8729">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L8730" title="1 of 2 branches missed.">    if (jj_3R_315()) return true;</span>
    }
<span class="fc" id="L8732">    return false;</span>
  }

  private boolean jj_3R_314()
 {
    Token xsp;
<span class="fc bfc" id="L8738" title="All 2 branches covered.">    if (jj_3R_320()) return true;</span>
    while (true) {
<span class="fc" id="L8740">      xsp = jj_scanpos;</span>
<span class="fc bfc" id="L8741" title="All 2 branches covered.">      if (jj_3R_320()) { jj_scanpos = xsp; break; }</span>
    }
<span class="fc" id="L8743">    return false;</span>
  }

  private boolean jj_3R_70()
 {
<span class="nc bnc" id="L8748" title="All 2 branches missed.">    if (jj_scan_token(ID_FUNCTION)) return true;</span>
<span class="nc bnc" id="L8749" title="All 2 branches missed.">    if (jj_3R_110()) return true;</span>
<span class="nc" id="L8750">    return false;</span>
  }

  private boolean jj_3R_320()
 {
<span class="fc bfc" id="L8755" title="All 2 branches covered.">    if (jj_scan_token(116)) return true;</span>
<span class="pc bpc" id="L8756" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="fc" id="L8757">    return false;</span>
  }

  private boolean jj_3R_265()
 {
<span class="pc bpc" id="L8762" title="1 of 2 branches missed.">    if (jj_3R_94()) return true;</span>
<span class="nc" id="L8763">    return false;</span>
  }

  private boolean jj_3R_71()
 {
<span class="nc bnc" id="L8768" title="All 2 branches missed.">    if (jj_scan_token(ID_FUNCTION)) return true;</span>
<span class="nc bnc" id="L8769" title="All 2 branches missed.">    if (jj_3R_110()) return true;</span>
<span class="nc" id="L8770">    return false;</span>
  }

  private boolean jj_3R_315()
 {
<span class="pc bpc" id="L8775" title="1 of 2 branches missed.">    if (jj_scan_token(118)) return true;</span>
<span class="pc bpc" id="L8776" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
    Token xsp;
<span class="fc" id="L8778">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L8779" title="All 2 branches covered.">    if (jj_3R_321()) jj_scanpos = xsp;</span>
<span class="fc" id="L8780">    return false;</span>
  }

  private boolean jj_3R_137()
 {
    Token xsp;
<span class="fc" id="L8786">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L8787" title="All 2 branches covered.">    if (jj_3R_166()) {</span>
<span class="fc" id="L8788">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L8789" title="All 2 branches covered.">    if (jj_3R_167()) {</span>
<span class="fc" id="L8790">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L8791" title="All 2 branches covered.">    if (jj_3R_168()) {</span>
<span class="fc" id="L8792">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L8793" title="All 2 branches covered.">    if (jj_3R_169()) {</span>
<span class="fc" id="L8794">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L8795" title="All 2 branches covered.">    if (jj_3R_170()) {</span>
<span class="fc" id="L8796">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L8797" title="All 2 branches covered.">    if (jj_3R_171()) return true;</span>
    }
    }
    }
    }
    }
<span class="fc" id="L8803">    return false;</span>
  }

  private boolean jj_3R_192()
 {
<span class="pc bpc" id="L8808" title="1 of 2 branches missed.">    if (jj_scan_token(WITH)) return true;</span>
<span class="pc bpc" id="L8809" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="fc" id="L8810">    return false;</span>
  }

  private boolean jj_3R_299()
 {
<span class="fc bfc" id="L8815" title="All 2 branches covered.">    if (jj_scan_token(LT)) return true;</span>
<span class="fc bfc" id="L8816" title="All 2 branches covered.">    if (jj_3R_94()) return true;</span>
<span class="pc bpc" id="L8817" title="1 of 2 branches missed.">    if (jj_scan_token(IN)) return true;</span>
<span class="pc bpc" id="L8818" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
    Token xsp;
    while (true) {
<span class="fc" id="L8821">      xsp = jj_scanpos;</span>
<span class="pc bpc" id="L8822" title="1 of 2 branches missed.">      if (jj_3R_312()) { jj_scanpos = xsp; break; }</span>
    }
<span class="fc" id="L8824">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L8825" title="1 of 2 branches missed.">    if (jj_3R_313()) jj_scanpos = xsp;</span>
<span class="pc bpc" id="L8826" title="1 of 2 branches missed.">    if (jj_scan_token(118)) return true;</span>
<span class="pc bpc" id="L8827" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="pc bpc" id="L8828" title="1 of 2 branches missed.">    if (jj_scan_token(GT)) return true;</span>
<span class="fc" id="L8829">    return false;</span>
  }

  private boolean jj_3R_143()
 {
    Token xsp;
<span class="fc" id="L8835">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L8836" title="1 of 2 branches missed.">    if (jj_3R_179()) {</span>
<span class="fc" id="L8837">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L8838" title="All 2 branches covered.">    if (jj_3R_180()) {</span>
<span class="fc" id="L8839">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L8840" title="All 2 branches covered.">    if (jj_3R_181()) {</span>
<span class="fc" id="L8841">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L8842" title="All 2 branches covered.">    if (jj_3R_182()) {</span>
<span class="fc" id="L8843">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L8844" title="1 of 2 branches missed.">    if (jj_3R_183()) {</span>
<span class="fc" id="L8845">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L8846" title="All 2 branches covered.">    if (jj_3R_184()) {</span>
<span class="fc" id="L8847">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L8848" title="All 2 branches covered.">    if (jj_3R_185()) {</span>
<span class="fc" id="L8849">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L8850" title="All 2 branches covered.">    if (jj_3R_186()) {</span>
<span class="fc" id="L8851">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L8852" title="All 2 branches covered.">    if (jj_3R_187()) return true;</span>
    }
    }
    }
    }
    }
    }
    }
    }
<span class="fc" id="L8861">    return false;</span>
  }

  private boolean jj_3R_166()
 {
<span class="fc bfc" id="L8866" title="All 2 branches covered.">    if (jj_3R_204()) return true;</span>
<span class="fc" id="L8867">    return false;</span>
  }

  private boolean jj_3R_167()
 {
<span class="fc bfc" id="L8872" title="All 2 branches covered.">    if (jj_3R_205()) return true;</span>
<span class="fc" id="L8873">    return false;</span>
  }

  private boolean jj_3R_168()
 {
<span class="fc bfc" id="L8878" title="All 2 branches covered.">    if (jj_3R_206()) return true;</span>
<span class="fc" id="L8879">    return false;</span>
  }

  private boolean jj_3R_179()
 {
<span class="pc bpc" id="L8884" title="1 of 2 branches missed.">    if (jj_3R_88()) return true;</span>
<span class="nc" id="L8885">    return false;</span>
  }

  private boolean jj_3R_321()
 {
<span class="fc bfc" id="L8890" title="All 2 branches covered.">    if (jj_scan_token(116)) return true;</span>
<span class="pc bpc" id="L8891" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="fc" id="L8892">    return false;</span>
  }

  private boolean jj_3R_169()
 {
<span class="fc bfc" id="L8897" title="All 2 branches covered.">    if (jj_3R_207()) return true;</span>
<span class="fc" id="L8898">    return false;</span>
  }

  private boolean jj_3R_170()
 {
<span class="fc bfc" id="L8903" title="All 2 branches covered.">    if (jj_3R_208()) return true;</span>
<span class="fc" id="L8904">    return false;</span>
  }

  private boolean jj_3R_180()
 {
<span class="fc bfc" id="L8909" title="All 2 branches covered.">    if (jj_3R_89()) return true;</span>
<span class="fc" id="L8910">    return false;</span>
  }

  private boolean jj_3R_171()
 {
<span class="fc bfc" id="L8915" title="All 2 branches covered.">    if (jj_3R_209()) return true;</span>
<span class="fc" id="L8916">    return false;</span>
  }

  private boolean jj_3R_181()
 {
<span class="fc bfc" id="L8921" title="All 2 branches covered.">    if (jj_3R_211()) return true;</span>
<span class="fc" id="L8922">    return false;</span>
  }

  private boolean jj_3R_182()
 {
<span class="fc bfc" id="L8927" title="All 2 branches covered.">    if (jj_3R_212()) return true;</span>
<span class="fc" id="L8928">    return false;</span>
  }

  private boolean jj_3R_183()
 {
<span class="pc bpc" id="L8933" title="1 of 2 branches missed.">    if (jj_3R_213()) return true;</span>
<span class="nc" id="L8934">    return false;</span>
  }

  private boolean jj_3R_184()
 {
<span class="fc bfc" id="L8939" title="All 2 branches covered.">    if (jj_3R_214()) return true;</span>
<span class="fc" id="L8940">    return false;</span>
  }

  private boolean jj_3R_185()
 {
<span class="fc bfc" id="L8945" title="All 2 branches covered.">    if (jj_3R_215()) return true;</span>
<span class="fc" id="L8946">    return false;</span>
  }

  private boolean jj_3R_186()
 {
<span class="fc bfc" id="L8951" title="All 2 branches covered.">    if (jj_3R_216()) return true;</span>
<span class="fc" id="L8952">    return false;</span>
  }

  private boolean jj_3_28()
 {
<span class="pc bpc" id="L8957" title="1 of 2 branches missed.">    if (jj_3R_88()) return true;</span>
<span class="nc" id="L8958">    return false;</span>
  }

  private boolean jj_3R_110()
 {
<span class="fc bfc" id="L8963" title="All 2 branches covered.">    if (jj_3R_138()) return true;</span>
    Token xsp;
    while (true) {
<span class="fc" id="L8966">      xsp = jj_scanpos;</span>
<span class="pc bpc" id="L8967" title="1 of 2 branches missed.">      if (jj_3_19()) { jj_scanpos = xsp; break; }</span>
    }
<span class="fc" id="L8969">    return false;</span>
  }

  private boolean jj_3R_187()
 {
<span class="fc bfc" id="L8974" title="All 2 branches covered.">    if (jj_3R_217()) return true;</span>
<span class="fc" id="L8975">    return false;</span>
  }

  private boolean jj_3_29()
 {
<span class="fc bfc" id="L8980" title="All 2 branches covered.">    if (jj_3R_89()) return true;</span>
<span class="fc" id="L8981">    return false;</span>
  }

  private boolean jj_3R_204()
 {
<span class="fc bfc" id="L8986" title="All 2 branches covered.">    if (jj_scan_token(RULEDOM)) return true;</span>
    Token xsp;
<span class="fc" id="L8988">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L8989" title="1 of 2 branches missed.">    if (jj_3R_232()) jj_scanpos = xsp;</span>
<span class="fc" id="L8990">    return false;</span>
  }

  private boolean jj_3_19()
 {
    Token xsp;
<span class="fc" id="L8996">    xsp = jj_scanpos;</span>
<span class="fc" id="L8997">    jj_lookingAhead = true;</span>
<span class="fc bfc" id="L8998" title="All 4 branches covered.">    jj_semLA = getToken(1).kind == ID_FUNCTION &amp;&amp; getToken(1).image.equals(&quot;or&quot;);</span>
<span class="fc" id="L8999">    jj_lookingAhead = false;</span>
<span class="pc bpc" id="L9000" title="3 of 4 branches missed.">    if (!jj_semLA || jj_3R_72()) {</span>
<span class="fc" id="L9001">    jj_scanpos = xsp;</span>
<span class="fc" id="L9002">    jj_lookingAhead = true;</span>
<span class="fc bfc" id="L9003" title="All 4 branches covered.">    jj_semLA = getToken(1).kind == ID_FUNCTION &amp;&amp; getToken(1).image.equals(&quot;xor&quot;);</span>
<span class="fc" id="L9004">    jj_lookingAhead = false;</span>
<span class="pc bpc" id="L9005" title="3 of 4 branches missed.">    if (!jj_semLA || jj_3R_73()) return true;</span>
    }
<span class="nc bnc" id="L9007" title="All 2 branches missed.">    if (jj_3R_138()) return true;</span>
<span class="nc" id="L9008">    return false;</span>
  }

  private boolean jj_3R_281()
 {
<span class="pc bpc" id="L9013" title="1 of 2 branches missed.">    if (jj_3R_245()) return true;</span>
<span class="nc" id="L9014">    return false;</span>
  }

  private boolean jj_3R_72()
 {
<span class="nc bnc" id="L9019" title="All 2 branches missed.">    if (jj_scan_token(ID_FUNCTION)) return true;</span>
<span class="nc" id="L9020">    return false;</span>
  }

  private boolean jj_3R_232()
 {
<span class="pc bpc" id="L9025" title="1 of 2 branches missed.">    if (jj_scan_token(115)) return true;</span>
<span class="pc bpc" id="L9026" title="1 of 2 branches missed.">    if (jj_3R_64()) return true;</span>
    Token xsp;
    while (true) {
<span class="fc" id="L9029">      xsp = jj_scanpos;</span>
<span class="fc bfc" id="L9030" title="All 2 branches covered.">      if (jj_3R_246()) { jj_scanpos = xsp; break; }</span>
    }
<span class="pc bpc" id="L9032" title="1 of 2 branches missed.">    if (jj_scan_token(117)) return true;</span>
<span class="fc" id="L9033">    return false;</span>
  }

  private boolean jj_3R_88()
 {
<span class="pc bpc" id="L9038" title="1 of 2 branches missed.">    if (jj_scan_token(COMPLEX_NUMBER)) return true;</span>
<span class="nc" id="L9039">    return false;</span>
  }

  private boolean jj_3R_145()
 {
<span class="fc bfc" id="L9044" title="All 2 branches covered.">    if (jj_scan_token(115)) return true;</span>
<span class="fc bfc" id="L9045" title="All 2 branches covered.">    if (jj_scan_token(FORALL)) return true;</span>
<span class="pc bpc" id="L9046" title="1 of 2 branches missed.">    if (jj_3R_94()) return true;</span>
<span class="pc bpc" id="L9047" title="1 of 2 branches missed.">    if (jj_scan_token(IN)) return true;</span>
<span class="pc bpc" id="L9048" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
    Token xsp;
    while (true) {
<span class="fc" id="L9051">      xsp = jj_scanpos;</span>
<span class="fc bfc" id="L9052" title="All 2 branches covered.">      if (jj_3R_189()) { jj_scanpos = xsp; break; }</span>
    }
<span class="fc" id="L9054">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L9055" title="1 of 2 branches missed.">    if (jj_3R_190()) jj_scanpos = xsp;</span>
<span class="pc bpc" id="L9056" title="1 of 2 branches missed.">    if (jj_scan_token(117)) return true;</span>
<span class="fc" id="L9057">    return false;</span>
  }

  private boolean jj_3R_73()
 {
<span class="nc bnc" id="L9062" title="All 2 branches missed.">    if (jj_scan_token(ID_FUNCTION)) return true;</span>
<span class="nc" id="L9063">    return false;</span>
  }

  private boolean jj_3R_312()
 {
<span class="pc bpc" id="L9068" title="1 of 2 branches missed.">    if (jj_scan_token(116)) return true;</span>
<span class="nc bnc" id="L9069" title="All 2 branches missed.">    if (jj_3R_94()) return true;</span>
<span class="nc bnc" id="L9070" title="All 2 branches missed.">    if (jj_scan_token(IN)) return true;</span>
<span class="nc bnc" id="L9071" title="All 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="nc" id="L9072">    return false;</span>
  }

  private boolean jj_3R_155()
 {
<span class="pc bpc" id="L9077" title="1 of 2 branches missed.">    if (jj_scan_token(FORALL)) return true;</span>
<span class="nc bnc" id="L9078" title="All 2 branches missed.">    if (jj_3R_94()) return true;</span>
<span class="nc" id="L9079">    return false;</span>
  }

  private boolean jj_3R_246()
 {
<span class="fc bfc" id="L9084" title="All 2 branches covered.">    if (jj_scan_token(116)) return true;</span>
<span class="pc bpc" id="L9085" title="1 of 2 branches missed.">    if (jj_3R_64()) return true;</span>
<span class="fc" id="L9086">    return false;</span>
  }

  private boolean jj_3R_205()
 {
<span class="fc bfc" id="L9091" title="All 2 branches covered.">    if (jj_scan_token(PROD)) return true;</span>
<span class="pc bpc" id="L9092" title="1 of 2 branches missed.">    if (jj_scan_token(115)) return true;</span>
<span class="pc bpc" id="L9093" title="1 of 2 branches missed.">    if (jj_3R_64()) return true;</span>
    Token xsp;
<span class="pc bpc" id="L9095" title="1 of 2 branches missed.">    if (jj_3R_233()) return true;</span>
    while (true) {
<span class="fc" id="L9097">      xsp = jj_scanpos;</span>
<span class="fc bfc" id="L9098" title="All 2 branches covered.">      if (jj_3R_233()) { jj_scanpos = xsp; break; }</span>
    }
<span class="pc bpc" id="L9100" title="1 of 2 branches missed.">    if (jj_scan_token(117)) return true;</span>
<span class="fc" id="L9101">    return false;</span>
  }

  private boolean jj_3R_313()
 {
<span class="pc bpc" id="L9106" title="1 of 2 branches missed.">    if (jj_scan_token(120)) return true;</span>
<span class="pc bpc" id="L9107" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="fc" id="L9108">    return false;</span>
  }

  private boolean jj_3R_89()
 {
<span class="fc bfc" id="L9113" title="All 2 branches covered.">    if (jj_scan_token(REAL_NUMBER)) return true;</span>
<span class="fc" id="L9114">    return false;</span>
  }

  private boolean jj_3R_138()
 {
<span class="fc bfc" id="L9119" title="All 2 branches covered.">    if (jj_3R_172()) return true;</span>
    Token xsp;
    while (true) {
<span class="fc" id="L9122">      xsp = jj_scanpos;</span>
<span class="fc bfc" id="L9123" title="All 2 branches covered.">      if (jj_3R_173()) { jj_scanpos = xsp; break; }</span>
    }
<span class="fc" id="L9125">    return false;</span>
  }

  private boolean jj_3R_275()
 {
<span class="fc bfc" id="L9130" title="All 2 branches covered.">    if (jj_scan_token(119)) return true;</span>
    Token xsp;
<span class="fc" id="L9132">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L9133" title="All 2 branches covered.">    if (jj_3_34()) jj_scanpos = xsp;</span>
<span class="pc bpc" id="L9134" title="1 of 2 branches missed.">    if (jj_scan_token(121)) return true;</span>
<span class="fc" id="L9135">    return false;</span>
  }

  private boolean jj_3R_189()
 {
<span class="fc bfc" id="L9140" title="All 2 branches covered.">    if (jj_scan_token(116)) return true;</span>
<span class="pc bpc" id="L9141" title="1 of 2 branches missed.">    if (jj_3R_94()) return true;</span>
<span class="pc bpc" id="L9142" title="1 of 2 branches missed.">    if (jj_scan_token(IN)) return true;</span>
<span class="pc bpc" id="L9143" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="fc" id="L9144">    return false;</span>
  }

  private boolean jj_3R_173()
 {
<span class="fc bfc" id="L9149" title="All 2 branches covered.">    if (jj_scan_token(ID_FUNCTION)) return true;</span>
<span class="fc bfc" id="L9150" title="All 2 branches covered.">    if (jj_3R_172()) return true;</span>
<span class="fc" id="L9151">    return false;</span>
  }

  private boolean jj_3R_233()
 {
<span class="fc bfc" id="L9156" title="All 2 branches covered.">    if (jj_scan_token(116)) return true;</span>
<span class="pc bpc" id="L9157" title="1 of 2 branches missed.">    if (jj_3R_64()) return true;</span>
<span class="fc" id="L9158">    return false;</span>
  }

  private boolean jj_3_34()
 {
<span class="fc bfc" id="L9163" title="All 2 branches covered.">    if (jj_3R_93()) return true;</span>
    Token xsp;
<span class="fc" id="L9165">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L9166" title="All 2 branches covered.">    if (jj_3R_302()) jj_scanpos = xsp;</span>
<span class="fc" id="L9167">    return false;</span>
  }

  private boolean jj_3R_190()
 {
<span class="pc bpc" id="L9172" title="1 of 2 branches missed.">    if (jj_scan_token(WITH)) return true;</span>
<span class="pc bpc" id="L9173" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="fc" id="L9174">    return false;</span>
  }

  private boolean jj_3R_211()
 {
<span class="fc bfc" id="L9179" title="All 2 branches covered.">    if (jj_scan_token(NUMBER)) return true;</span>
<span class="fc" id="L9180">    return false;</span>
  }

  private boolean jj_3R_206()
 {
<span class="fc bfc" id="L9185" title="All 2 branches covered.">    if (jj_scan_token(SEQ)) return true;</span>
<span class="pc bpc" id="L9186" title="1 of 2 branches missed.">    if (jj_scan_token(115)) return true;</span>
<span class="pc bpc" id="L9187" title="1 of 2 branches missed.">    if (jj_3R_64()) return true;</span>
<span class="pc bpc" id="L9188" title="1 of 2 branches missed.">    if (jj_scan_token(117)) return true;</span>
<span class="fc" id="L9189">    return false;</span>
  }

  private boolean jj_3R_302()
 {
    Token xsp;
<span class="fc" id="L9195">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L9196" title="All 2 branches covered.">    if (jj_3R_316()) {</span>
<span class="fc" id="L9197">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L9198" title="All 2 branches covered.">    if (jj_3R_317()) return true;</span>
    }
<span class="fc" id="L9200">    return false;</span>
  }

  private boolean jj_3R_316()
 {
    Token xsp;
<span class="fc bfc" id="L9206" title="All 2 branches covered.">    if (jj_3R_322()) return true;</span>
    while (true) {
<span class="fc" id="L9208">      xsp = jj_scanpos;</span>
<span class="fc bfc" id="L9209" title="All 2 branches covered.">      if (jj_3R_322()) { jj_scanpos = xsp; break; }</span>
    }
<span class="fc" id="L9211">    return false;</span>
  }

  private boolean jj_3R_322()
 {
<span class="fc bfc" id="L9216" title="All 2 branches covered.">    if (jj_scan_token(116)) return true;</span>
<span class="pc bpc" id="L9217" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="fc" id="L9218">    return false;</span>
  }

  private boolean jj_3R_210()
 {
<span class="fc bfc" id="L9223" title="All 2 branches covered.">    if (jj_3R_64()) return true;</span>
<span class="fc" id="L9224">    return false;</span>
  }

  private boolean jj_3R_207()
 {
<span class="fc bfc" id="L9229" title="All 2 branches covered.">    if (jj_scan_token(POWERSET)) return true;</span>
<span class="pc bpc" id="L9230" title="1 of 2 branches missed.">    if (jj_scan_token(115)) return true;</span>
<span class="pc bpc" id="L9231" title="1 of 2 branches missed.">    if (jj_3R_64()) return true;</span>
<span class="pc bpc" id="L9232" title="1 of 2 branches missed.">    if (jj_scan_token(117)) return true;</span>
<span class="fc" id="L9233">    return false;</span>
  }

  private boolean jj_3R_317()
 {
<span class="fc bfc" id="L9238" title="All 2 branches covered.">    if (jj_scan_token(118)) return true;</span>
<span class="pc bpc" id="L9239" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
    Token xsp;
<span class="fc" id="L9241">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L9242" title="1 of 2 branches missed.">    if (jj_3R_323()) jj_scanpos = xsp;</span>
<span class="fc" id="L9243">    return false;</span>
  }

  private boolean jj_3R_271()
 {
<span class="pc bpc" id="L9248" title="1 of 2 branches missed.">    if (jj_scan_token(LET)) return true;</span>
<span class="nc bnc" id="L9249" title="All 2 branches missed.">    if (jj_scan_token(115)) return true;</span>
<span class="nc bnc" id="L9250" title="All 2 branches missed.">    if (jj_3R_94()) return true;</span>
<span class="nc bnc" id="L9251" title="All 2 branches missed.">    if (jj_scan_token(EQ)) return true;</span>
<span class="nc bnc" id="L9252" title="All 2 branches missed.">    if (jj_3R_93()) return true;</span>
    Token xsp;
    while (true) {
<span class="nc" id="L9255">      xsp = jj_scanpos;</span>
<span class="nc bnc" id="L9256" title="All 2 branches missed.">      if (jj_3R_289()) { jj_scanpos = xsp; break; }</span>
    }
<span class="nc bnc" id="L9258" title="All 2 branches missed.">    if (jj_scan_token(117)) return true;</span>
<span class="nc bnc" id="L9259" title="All 2 branches missed.">    if (jj_scan_token(IN)) return true;</span>
<span class="nc bnc" id="L9260" title="All 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="nc bnc" id="L9261" title="All 2 branches missed.">    if (jj_scan_token(ENDLET)) return true;</span>
<span class="nc" id="L9262">    return false;</span>
  }

  private boolean jj_3R_212()
 {
<span class="fc bfc" id="L9267" title="All 2 branches covered.">    if (jj_scan_token(NATNUMBER)) return true;</span>
<span class="fc" id="L9268">    return false;</span>
  }

  private boolean jj_3R_208()
 {
<span class="fc bfc" id="L9273" title="All 2 branches covered.">    if (jj_scan_token(BAG)) return true;</span>
<span class="pc bpc" id="L9274" title="1 of 2 branches missed.">    if (jj_scan_token(115)) return true;</span>
<span class="pc bpc" id="L9275" title="1 of 2 branches missed.">    if (jj_3R_64()) return true;</span>
<span class="pc bpc" id="L9276" title="1 of 2 branches missed.">    if (jj_scan_token(117)) return true;</span>
<span class="fc" id="L9277">    return false;</span>
  }

  private boolean jj_3R_323()
 {
<span class="pc bpc" id="L9282" title="1 of 2 branches missed.">    if (jj_scan_token(116)) return true;</span>
<span class="nc bnc" id="L9283" title="All 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="nc" id="L9284">    return false;</span>
  }

  private boolean jj_3R_172()
 {
<span class="fc bfc" id="L9289" title="All 2 branches covered.">    if (jj_3R_111()) return true;</span>
    Token xsp;
    while (true) {
<span class="fc" id="L9292">      xsp = jj_scanpos;</span>
<span class="fc bfc" id="L9293" title="All 2 branches covered.">      if (jj_3_20()) { jj_scanpos = xsp; break; }</span>
    }
<span class="fc" id="L9295">    return false;</span>
  }

  private boolean jj_3R_239()
 {
<span class="pc bpc" id="L9300" title="1 of 2 branches missed.">    if (jj_scan_token(126)) return true;</span>
<span class="nc bnc" id="L9301" title="All 2 branches missed.">    if (jj_3R_257()) return true;</span>
<span class="nc bnc" id="L9302" title="All 2 branches missed.">    if (jj_scan_token(127)) return true;</span>
<span class="nc" id="L9303">    return false;</span>
  }

  private boolean jj_3_20()
 {
    Token xsp;
<span class="fc" id="L9309">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L9310" title="All 2 branches covered.">    if (jj_3R_74()) {</span>
<span class="fc" id="L9311">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L9312" title="All 2 branches covered.">    if (jj_3R_75()) {</span>
<span class="fc" id="L9313">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L9314" title="All 2 branches covered.">    if (jj_3R_76()) {</span>
<span class="fc" id="L9315">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L9316" title="All 2 branches covered.">    if (jj_3R_77()) {</span>
<span class="fc" id="L9317">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L9318" title="All 2 branches covered.">    if (jj_3R_78()) {</span>
<span class="fc" id="L9319">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L9320" title="All 2 branches covered.">    if (jj_3R_79()) return true;</span>
    }
    }
    }
    }
    }
<span class="fc" id="L9326">    return false;</span>
  }

  private boolean jj_3R_156()
 {
<span class="pc bpc" id="L9331" title="1 of 2 branches missed.">    if (jj_scan_token(LET)) return true;</span>
<span class="nc bnc" id="L9332" title="All 2 branches missed.">    if (jj_scan_token(115)) return true;</span>
<span class="nc" id="L9333">    return false;</span>
  }

  private boolean jj_3R_209()
 {
<span class="fc bfc" id="L9338" title="All 2 branches covered.">    if (jj_scan_token(MAP)) return true;</span>
<span class="pc bpc" id="L9339" title="1 of 2 branches missed.">    if (jj_scan_token(115)) return true;</span>
<span class="pc bpc" id="L9340" title="1 of 2 branches missed.">    if (jj_3R_64()) return true;</span>
<span class="pc bpc" id="L9341" title="1 of 2 branches missed.">    if (jj_scan_token(116)) return true;</span>
<span class="pc bpc" id="L9342" title="1 of 2 branches missed.">    if (jj_3R_64()) return true;</span>
<span class="pc bpc" id="L9343" title="1 of 2 branches missed.">    if (jj_scan_token(117)) return true;</span>
<span class="fc" id="L9344">    return false;</span>
  }

  private boolean jj_3R_74()
 {
<span class="fc bfc" id="L9349" title="All 2 branches covered.">    if (jj_scan_token(EQ)) return true;</span>
<span class="pc bpc" id="L9350" title="1 of 2 branches missed.">    if (jj_3R_111()) return true;</span>
<span class="fc" id="L9351">    return false;</span>
  }

  private boolean jj_3R_75()
 {
<span class="fc bfc" id="L9356" title="All 2 branches covered.">    if (jj_scan_token(NEQ)) return true;</span>
<span class="pc bpc" id="L9357" title="1 of 2 branches missed.">    if (jj_3R_111()) return true;</span>
<span class="fc" id="L9358">    return false;</span>
  }

  private boolean jj_3R_213()
 {
<span class="pc bpc" id="L9363" title="1 of 2 branches missed.">    if (jj_scan_token(CHAR_LITERAL)) return true;</span>
<span class="nc" id="L9364">    return false;</span>
  }

  private boolean jj_3R_62()
 {
<span class="pc bpc" id="L9369" title="1 of 2 branches missed.">    if (jj_scan_token(DOMAIN)) return true;</span>
<span class="nc bnc" id="L9370" title="All 2 branches missed.">    if (jj_3R_105()) return true;</span>
<span class="nc" id="L9371">    return false;</span>
  }

  private boolean jj_3R_76()
 {
<span class="fc bfc" id="L9376" title="All 2 branches covered.">    if (jj_scan_token(LT)) return true;</span>
<span class="pc bpc" id="L9377" title="1 of 2 branches missed.">    if (jj_3R_111()) return true;</span>
<span class="fc" id="L9378">    return false;</span>
  }

  private boolean jj_3R_64()
 {
    Token xsp;
<span class="fc" id="L9384">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L9385" title="All 2 branches covered.">    if (jj_3R_107()) {</span>
<span class="fc" id="L9386">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L9387" title="All 2 branches covered.">    if (jj_3R_108()) return true;</span>
    }
<span class="fc" id="L9389">    return false;</span>
  }

  private boolean jj_3R_77()
 {
<span class="fc bfc" id="L9394" title="All 2 branches covered.">    if (jj_scan_token(LE)) return true;</span>
<span class="pc bpc" id="L9395" title="1 of 2 branches missed.">    if (jj_3R_111()) return true;</span>
<span class="fc" id="L9396">    return false;</span>
  }

  private boolean jj_3R_107()
 {
<span class="fc bfc" id="L9401" title="All 2 branches covered.">    if (jj_3R_105()) return true;</span>
<span class="fc" id="L9402">    return false;</span>
  }

  private boolean jj_3R_78()
 {
<span class="fc bfc" id="L9407" title="All 2 branches covered.">    if (jj_scan_token(GT)) return true;</span>
<span class="fc bfc" id="L9408" title="All 2 branches covered.">    if (jj_3R_111()) return true;</span>
<span class="fc" id="L9409">    return false;</span>
  }

  private boolean jj_3R_289()
 {
<span class="nc bnc" id="L9414" title="All 2 branches missed.">    if (jj_scan_token(116)) return true;</span>
<span class="nc bnc" id="L9415" title="All 2 branches missed.">    if (jj_3R_94()) return true;</span>
<span class="nc bnc" id="L9416" title="All 2 branches missed.">    if (jj_scan_token(EQ)) return true;</span>
<span class="nc bnc" id="L9417" title="All 2 branches missed.">    if (jj_3R_93()) return true;</span>
<span class="nc" id="L9418">    return false;</span>
  }

  private boolean jj_3R_108()
 {
<span class="fc bfc" id="L9423" title="All 2 branches covered.">    if (jj_3R_137()) return true;</span>
<span class="fc" id="L9424">    return false;</span>
  }

  private boolean jj_3R_79()
 {
<span class="fc bfc" id="L9429" title="All 2 branches covered.">    if (jj_scan_token(GE)) return true;</span>
<span class="pc bpc" id="L9430" title="1 of 2 branches missed.">    if (jj_3R_111()) return true;</span>
<span class="fc" id="L9431">    return false;</span>
  }

  private boolean jj_3R_274()
 {
<span class="fc bfc" id="L9436" title="All 2 branches covered.">    if (jj_scan_token(119)) return true;</span>
    Token xsp;
<span class="fc" id="L9438">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L9439" title="1 of 2 branches missed.">    if (jj_3R_290()) {</span>
<span class="fc" id="L9440">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L9441" title="All 2 branches covered.">    if (jj_3_35()) return true;</span>
    }
<span class="pc bpc" id="L9443" title="1 of 2 branches missed.">    if (jj_scan_token(121)) return true;</span>
<span class="fc" id="L9444">    return false;</span>
  }

  private boolean jj_3R_214()
 {
<span class="fc bfc" id="L9449" title="All 2 branches covered.">    if (jj_scan_token(STRING_LITERAL)) return true;</span>
<span class="fc" id="L9450">    return false;</span>
  }

  private boolean jj_3_1()
 {
<span class="pc bpc" id="L9455" title="1 of 2 branches missed.">    if (jj_3R_59()) return true;</span>
<span class="nc" id="L9456">    return false;</span>
  }

  private boolean jj_3R_60()
 {
    Token xsp;
<span class="fc" id="L9462">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L9463" title="1 of 2 branches missed.">    if (jj_3R_103()) {</span>
<span class="fc" id="L9464">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L9465" title="1 of 2 branches missed.">    if (jj_3R_104()) return true;</span>
    }
<span class="nc" id="L9467">    return false;</span>
  }

  private boolean jj_3R_103()
 {
<span class="pc bpc" id="L9472" title="1 of 2 branches missed.">    if (jj_3R_135()) return true;</span>
<span class="nc" id="L9473">    return false;</span>
  }

  private boolean jj_3R_104()
 {
<span class="pc bpc" id="L9478" title="1 of 2 branches missed.">    if (jj_3R_136()) return true;</span>
<span class="nc" id="L9479">    return false;</span>
  }

  private boolean jj_3R_290()
 {
<span class="pc bpc" id="L9484" title="1 of 2 branches missed.">    if (jj_scan_token(122)) return true;</span>
<span class="nc" id="L9485">    return false;</span>
  }

  private boolean jj_3R_111()
 {
    Token xsp;
<span class="fc" id="L9491">    xsp = jj_scanpos;</span>
<span class="fc" id="L9492">    jj_lookingAhead = true;</span>
<span class="fc bfc" id="L9493" title="All 4 branches covered.">    jj_semLA = getToken(1).kind == ID_FUNCTION &amp;&amp; getToken(1).image.equals(&quot;not&quot;);</span>
<span class="fc" id="L9494">    jj_lookingAhead = false;</span>
<span class="pc bpc" id="L9495" title="1 of 4 branches missed.">    if (!jj_semLA || jj_3R_139()) {</span>
<span class="fc" id="L9496">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L9497" title="All 2 branches covered.">    if (jj_3R_140()) return true;</span>
    }
<span class="fc" id="L9499">    return false;</span>
  }

  private boolean jj_3_35()
 {
<span class="fc bfc" id="L9504" title="All 2 branches covered.">    if (jj_3R_93()) return true;</span>
<span class="fc bfc" id="L9505" title="All 2 branches covered.">    if (jj_scan_token(122)) return true;</span>
<span class="pc bpc" id="L9506" title="1 of 2 branches missed.">    if (jj_3R_93()) return true;</span>
    Token xsp;
    while (true) {
<span class="fc" id="L9509">      xsp = jj_scanpos;</span>
<span class="fc bfc" id="L9510" title="All 2 branches covered.">      if (jj_3R_301()) { jj_scanpos = xsp; break; }</span>
    }
<span class="fc" id="L9512">    return false;</span>
  }

  private boolean jj_3R_135()
 {
    Token xsp;
<span class="fc" id="L9518">    xsp = jj_scanpos;</span>
<span class="pc bpc" id="L9519" title="1 of 2 branches missed.">    if (jj_3R_164()) {</span>
<span class="fc" id="L9520">    jj_scanpos = xsp;</span>
<span class="pc bpc" id="L9521" title="1 of 2 branches missed.">    if (jj_3R_165()) return true;</span>
    }
<span class="nc" id="L9523">    return false;</span>
  }

  private boolean jj_3R_139()
 {
<span class="pc bpc" id="L9528" title="1 of 2 branches missed.">    if (jj_scan_token(ID_FUNCTION)) return true;</span>
<span class="pc bpc" id="L9529" title="1 of 2 branches missed.">    if (jj_3R_174()) return true;</span>
<span class="fc" id="L9530">    return false;</span>
  }

  private boolean jj_3R_257()
 {
<span class="nc bnc" id="L9535" title="All 2 branches missed.">    if (jj_3R_196()) return true;</span>
    Token xsp;
<span class="nc" id="L9537">    xsp = jj_scanpos;</span>
<span class="nc bnc" id="L9538" title="All 2 branches missed.">    if (jj_3R_277()) jj_scanpos = xsp;</span>
<span class="nc" id="L9539">    return false;</span>
  }

  private boolean jj_3R_164()
 {
<span class="pc bpc" id="L9544" title="1 of 2 branches missed.">    if (jj_3R_202()) return true;</span>
<span class="nc" id="L9545">    return false;</span>
  }

  private boolean jj_3R_165()
 {
<span class="pc bpc" id="L9550" title="1 of 2 branches missed.">    if (jj_3R_203()) return true;</span>
<span class="nc" id="L9551">    return false;</span>
  }

  private boolean jj_3R_215()
 {
    Token xsp;
<span class="fc" id="L9557">    xsp = jj_scanpos;</span>
<span class="fc bfc" id="L9558" title="All 2 branches covered.">    if (jj_scan_token(46)) {</span>
<span class="fc" id="L9559">    jj_scanpos = xsp;</span>
<span class="fc bfc" id="L9560" title="All 2 branches covered.">    if (jj_scan_token(47)) return true;</span>
    }
<span class="fc" id="L9562">    return false;</span>
  }

  private boolean jj_3R_277()
 {
<span class="nc bnc" id="L9567" title="All 2 branches missed.">    if (jj_scan_token(115)) return true;</span>
<span class="nc bnc" id="L9568" title="All 2 branches missed.">    if (jj_3R_64()) return true;</span>
    Token xsp;
    while (true) {
<span class="nc" id="L9571">      xsp = jj_scanpos;</span>
<span class="nc bnc" id="L9572" title="All 2 branches missed.">      if (jj_3R_291()) { jj_scanpos = xsp; break; }</span>
    }
<span class="nc bnc" id="L9574" title="All 2 branches missed.">    if (jj_scan_token(117)) return true;</span>
<span class="nc" id="L9575">    return false;</span>
  }

  private boolean jj_3_2()
 {
<span class="pc bpc" id="L9580" title="1 of 2 branches missed.">    if (jj_3R_60()) return true;</span>
<span class="nc" id="L9581">    return false;</span>
  }

  private boolean jj_3R_140()
 {
<span class="fc bfc" id="L9586" title="All 2 branches covered.">    if (jj_3R_174()) return true;</span>
<span class="fc" id="L9587">    return false;</span>
  }

  private boolean jj_3R_244()
 {
    Token xsp;
<span class="fc" id="L9593">    xsp = jj_scanpos;</span>
<span class="nc bnc" id="L9594" title="All 2 branches missed.">    if (jj_3R_268()) {</span>
<span class="nc" id="L9595">    jj_scanpos = xsp;</span>
<span class="nc bnc" id="L9596" title="All 2 branches missed.">    if (jj_3R_269()) return true;</span>
    }
<span class="nc" id="L9598">    return false;</span>
  }

  private boolean jj_3R_136()
 {
<span class="pc bpc" id="L9603" title="1 of 2 branches missed.">    if (jj_scan_token(DERIVED)) return true;</span>
<span class="nc bnc" id="L9604" title="All 2 branches missed.">    if (jj_3R_109()) return true;</span>
<span class="nc" id="L9605">    return false;</span>
  }

  /** Generated Token Manager. */
  public ASMParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  /** Whether we are looking ahead. */
<span class="pc" id="L9619">  private boolean jj_lookingAhead = false;</span>
  private boolean jj_semLA;
  private int jj_gen;
<span class="pc" id="L9622">  final private int[] jj_la1 = new int[151];</span>
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static {
<span class="fc" id="L9629">	   jj_la1_init_0();</span>
<span class="fc" id="L9630">	   jj_la1_init_1();</span>
<span class="fc" id="L9631">	   jj_la1_init_2();</span>
<span class="fc" id="L9632">	   jj_la1_init_3();</span>
<span class="fc" id="L9633">	   jj_la1_init_4();</span>
<span class="fc" id="L9634">	}</span>
	private static void jj_la1_init_0() {
<span class="fc" id="L9636">	   jj_la1_0 = new int[] {0x200,0x180,0x0,0x2000,0x2000,0x6000,0x380,0x400,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x8000,0x0,0x0,0x4000000,0x0,0x800000,0x500000,0xb0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb0000,0xa0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x500000,0x10000000,0x10000000,0x10000000,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf8000000,0xd8000000,0x10000000,0x10000000,0x10000000,0x10000000,0x10000000,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x10000000,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,};</span>
<span class="fc" id="L9637">	}</span>
	private static void jj_la1_init_1() {
<span class="fc" id="L9639">	   jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3f00,0x0,0x0,0x0,0x3f00,0x0,0x0,0x0,0x0,0x0,0x3f78,0x0,0x3f78,0x0,0x0,0x0,0x3f00,0x0,0x0,0x0,0x3f00,0x3,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x8443f00,0x0,0x1ff00,0x0,0x0,0x0,0x0,0x0,0x1ff00,0x3f00,0x0,0x1c000,0x0,0x0,0x1c000,0xc000,0x440000,0x3f00,0x100000,0x1000000,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x80000000,0x0,0x80000000,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x0,0x0,0x0,0x8040000,0x0,0x8440000,0x100000,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x8440000,0x0,0x0,0x0,0x0,0x400000,0x1000000,0x2000000,0x0,};</span>
<span class="fc" id="L9640">	}</span>
	private static void jj_la1_init_2() {
<span class="fc" id="L9642">	   jj_la1_2 = new int[] {0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x0,0x1c,0x0,0x0,0x0,0x0,0x0,0x1c,0x8,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x10000,0x10000,0x0,0x0,0x0,0x0,0x0,0x800000,0xfc00000,0x30000000,0x30000000,0x20000000,0xc0000000,0x0,0x20000000,0x30000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x0,0x0,0x0,0x0,0x0,0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x15000,0x180000,0x0,0x0,0x0,0x943,0x0,0x195943,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x15000,0x195943,0x0,0x0,0x10000,0x0,0x180000,0x0,0x0,0x180000,};</span>
<span class="fc" id="L9643">	}</span>
	private static void jj_la1_init_3() {
<span class="fc" id="L9645">	   jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1180,0x100000,0x1180,0x80000,0x1180,0x100000,0x1180,0x1180,0x0,0x0,0x100000,0x80000,0x0,0x0,0x0,0x0,0x0,0x100000,0x80000,0x0,0x0,0x100000,0x80000,0x100000,0x80000,0x0,0x0,0x0,0x200,0x80,0x80000,0x1180,0x100000,0x80,0x80000,0x1180,0x400,0x800,0x0,0x0,0x0,0x0,0x0,0x1100000,0x1100000,0x0,0x100000,0x80000,0x100000,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x50880080,0x0,0x990fe,0x0,0x0,0x0,0x1,0x0,0x990fe,0x80,0x80000,0x1907e,0x80000,0x80000,0x18046,0x0,0x0,0x50800080,0x0,0x0,0x0,0x100000,0x10000000,0x800000,0x100000,0x100000,0x500000,0x500000,0x100000,0x100000,0x500000,0x500000,0x100000,0x4000000,0x100000,0x100000,0x500000,0x500000,0x10880000,0x80000,0x100000,0x0,0x100000,0x0,0x100000,0x0,0x100000,0x10800000,0x100000,0x1000000,0x100000,0x1000000,0x100000,0x1000000,0x100000,0x1000000,0x100000,0x80000,0x100,0x1020,0x1020,0x100000,0x10000000,0x100,0x1020,0x1120,0x0,0x100000,0x0,0x100000,0x0,0x100000,0x100000,0x100000,0x100,0x1120,0x100000,0x1020,0x0,0x100000,0x0,0x0,0x0,0x0,};</span>
<span class="fc" id="L9646">	}</span>
	private static void jj_la1_init_4() {
<span class="fc" id="L9648">	   jj_la1_4 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};</span>
<span class="fc" id="L9649">	}</span>
<span class="pc" id="L9650">  private final JJCalls[] jj_2_rtns = new JJCalls[44];</span>
<span class="pc" id="L9651">  private boolean jj_rescan = false;</span>
<span class="pc" id="L9652">  private int jj_gc = 0;</span>

  /**
   * Constructor with InputStream.
   * @param stream input stream
   */
  public ASMParser(final java.io.InputStream stream) {
<span class="nc" id="L9659">	  this(stream, null);</span>
<span class="nc" id="L9660">  }</span>

  /**
   * Constructor with InputStream and supplied encoding
   * @param stream input stream
   * @param encoding charset to be used
   */
<span class="fc" id="L9667">  public ASMParser(final java.io.InputStream stream, final java.nio.charset.Charset encoding) {</span>
<span class="fc" id="L9668">   jj_input_stream = new JavaCharStream(stream, encoding, 1, 1);</span>
<span class="fc" id="L9669">	 token_source = new ASMParserTokenManager(jj_input_stream);</span>
<span class="fc" id="L9670">	 token = new Token();</span>
<span class="fc" id="L9671">	 jj_ntk = -1;</span>
<span class="fc" id="L9672">	 jj_gen = 0;</span>
<span class="fc bfc" id="L9673" title="All 2 branches covered.">	 for (int i = 0; i &lt; 151; i++) jj_la1[i] = -1;</span>
<span class="fc bfc" id="L9674" title="All 2 branches covered.">	 for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();</span>
<span class="fc" id="L9675">  }</span>

  /**
   * Reinitialise
   * @param stream input stream
   */
  public void ReInit(final java.io.InputStream stream) {
<span class="nc" id="L9682">	  ReInit(stream, null);</span>
<span class="nc" id="L9683">  }</span>
  /**
   * Reinitialise
   * @param stream input stream
   * @param encoding charset to be used
   */
  public void ReInit(final java.io.InputStream stream, final java.nio.charset.Charset encoding) {
<span class="nc" id="L9690">    jj_input_stream.reInit(stream, encoding, 1, 1);</span>
<span class="nc" id="L9691">	 token_source.ReInit(jj_input_stream);</span>
<span class="nc" id="L9692">	 token = new Token();</span>
<span class="nc" id="L9693">	 jj_ntk = -1;</span>
<span class="nc" id="L9694">	 jj_gen = 0;</span>
<span class="nc bnc" id="L9695" title="All 2 branches missed.">	 for (int i = 0; i &lt; 151; i++) jj_la1[i] = -1;</span>
<span class="nc bnc" id="L9696" title="All 2 branches missed.">	 for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();</span>
<span class="nc" id="L9697">  }</span>

  /**
   * Constructor with InputStream.
   * @param stream char stream
   */
<span class="nc" id="L9703">  public ASMParser(final java.io.Reader stream) {</span>
<span class="nc" id="L9704">	 jj_input_stream = new JavaCharStream(stream, 1, 1);</span>
<span class="nc" id="L9705">	 token_source = new ASMParserTokenManager(jj_input_stream);</span>
<span class="nc" id="L9706">	 token = new Token();</span>
<span class="nc" id="L9707">	 jj_ntk = -1;</span>
<span class="nc" id="L9708">	 jj_gen = 0;</span>
<span class="nc bnc" id="L9709" title="All 2 branches missed.">   for (int i = 0; i &lt; 151; i++)</span>
<span class="nc" id="L9710">     jj_la1[i] = -1;</span>
<span class="nc bnc" id="L9711" title="All 2 branches missed.">   for (int i = 0; i &lt; jj_2_rtns.length; i++)</span>
<span class="nc" id="L9712">     jj_2_rtns[i] = new JJCalls();</span>
<span class="nc" id="L9713">  }</span>

  /**
   * Reinitialise
   * @param stream char stream
   */
  public void ReInit(final java.io.Reader stream) {
<span class="nc bnc" id="L9720" title="All 2 branches missed.">	if (jj_input_stream == null) {</span>
<span class="nc" id="L9721">	  jj_input_stream = new JavaCharStream(stream, 1, 1);</span>
	} else {
<span class="nc" id="L9723">	  jj_input_stream.reInit(stream, 1, 1);</span>
  }
<span class="nc bnc" id="L9725" title="All 2 branches missed.">	if (token_source == null) {</span>
<span class="nc" id="L9726"> token_source = new ASMParserTokenManager(jj_input_stream);</span>
	}

<span class="nc" id="L9729">	 token_source.ReInit(jj_input_stream);</span>
<span class="nc" id="L9730">	 token = new Token();</span>
<span class="nc" id="L9731">	 jj_ntk = -1;</span>
<span class="nc" id="L9732">	 jj_gen = 0;</span>
<span class="nc bnc" id="L9733" title="All 2 branches missed.">   for (int i = 0; i &lt; 151; i++)</span>
<span class="nc" id="L9734">     jj_la1[i] = -1;</span>
<span class="nc bnc" id="L9735" title="All 2 branches missed.">   for (int i = 0; i &lt; jj_2_rtns.length; i++)</span>
<span class="nc" id="L9736">     jj_2_rtns[i] = new JJCalls();</span>
<span class="nc" id="L9737">  }</span>

  /**
   * Constructor with generated Token Manager.
   * @param tm Token manager to use
   */
<span class="nc" id="L9743">  public ASMParser(final ASMParserTokenManager tm) {</span>
<span class="nc" id="L9744">	 token_source = tm;</span>
<span class="nc" id="L9745">	 token = new Token();</span>
<span class="nc" id="L9746">	 jj_ntk = -1;</span>
<span class="nc" id="L9747">	 jj_gen = 0;</span>
<span class="nc bnc" id="L9748" title="All 2 branches missed.">	 for (int i = 0; i &lt; 151; i++) jj_la1[i] = -1;</span>
<span class="nc bnc" id="L9749" title="All 2 branches missed.">	 for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();</span>
<span class="nc" id="L9750">  }</span>

  /**
   * Reinitialise
   * @param tm Token manager to use
   */
  public void ReInit(final ASMParserTokenManager tm) {
<span class="nc" id="L9757">	 token_source = tm;</span>
<span class="nc" id="L9758">	 token = new Token();</span>
<span class="nc" id="L9759">	 jj_ntk = -1;</span>
<span class="nc" id="L9760">	 jj_gen = 0;</span>
<span class="nc bnc" id="L9761" title="All 2 branches missed.">	 for (int i = 0; i &lt; 151; i++) jj_la1[i] = -1;</span>
<span class="nc bnc" id="L9762" title="All 2 branches missed.">	 for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();</span>
<span class="nc" id="L9763">  }</span>

  private Token jj_consume_token(final int kind) throws ParseException {
<span class="fc" id="L9766">    final Token oldToken = token;</span>
<span class="fc bfc" id="L9767" title="All 2 branches covered.">    if (token.next != null)</span>
<span class="fc" id="L9768">      token = token.next;</span>
    else {
<span class="fc" id="L9770">      token.next = token_source.getNextToken();</span>
<span class="fc" id="L9771">      token = token.next;</span>
    }
<span class="fc" id="L9773">    jj_ntk = -1;</span>
<span class="fc bfc" id="L9774" title="All 2 branches covered.">    if (token.kind == kind) {</span>
<span class="fc" id="L9775">      jj_gen++;</span>
<span class="fc bfc" id="L9776" title="All 2 branches covered.">      if (++jj_gc &gt; 100) {</span>
<span class="fc" id="L9777">        jj_gc = 0;</span>
<span class="fc bfc" id="L9778" title="All 2 branches covered.">        for (int i = 0; i &lt; jj_2_rtns.length; i++) {</span>
<span class="fc" id="L9779">          JJCalls c = jj_2_rtns[i];</span>
<span class="fc bfc" id="L9780" title="All 2 branches covered.">          while (c != null) {</span>
<span class="fc bfc" id="L9781" title="All 2 branches covered.">            if (c.gen &lt; jj_gen)</span>
<span class="fc" id="L9782">              c.first = null;</span>
<span class="fc" id="L9783">            c = c.next;</span>
          }
        }
      }
<span class="fc" id="L9787">      return token;</span>
    }
<span class="fc" id="L9789">    token = oldToken;</span>
<span class="fc" id="L9790">    jj_kind = kind;</span>
<span class="fc" id="L9791">    throw generateParseException();</span>
  }

<span class="fc" id="L9794">  private static final class LookaheadSuccess extends IllegalStateException {}</span>
<span class="pc" id="L9795">  private final LookaheadSuccess jj_ls = new LookaheadSuccess();</span>
  private boolean jj_scan_token(int kind) {
<span class="fc bfc" id="L9797" title="All 2 branches covered.">	 if (jj_scanpos == jj_lastpos) {</span>
<span class="fc" id="L9798">	   jj_la--;</span>
<span class="fc bfc" id="L9799" title="All 2 branches covered.">	   if (jj_scanpos.next == null) {</span>
<span class="fc" id="L9800">		   jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();</span>
	   } else {
<span class="fc" id="L9802">		   jj_lastpos = jj_scanpos = jj_scanpos.next;</span>
	   }
	 } else {
<span class="fc" id="L9805">	   jj_scanpos = jj_scanpos.next;</span>
	 }
<span class="fc bfc" id="L9807" title="All 2 branches covered.">	 if (jj_rescan) {</span>
<span class="fc" id="L9808">	   int i = 0; Token tok = token;</span>
<span class="fc bfc" id="L9809" title="All 4 branches covered.">	   while (tok != null &amp;&amp; tok != jj_scanpos) { i++; tok = tok.next; }</span>
<span class="fc bfc" id="L9810" title="All 2 branches covered.">	   if (tok != null) jj_add_error_token(kind, i);</span>
	 }
<span class="fc bfc" id="L9812" title="All 2 branches covered.">	 if (jj_scanpos.kind != kind) return true;</span>
<span class="fc bfc" id="L9813" title="All 4 branches covered.">	 if (jj_la == 0 &amp;&amp; jj_scanpos == jj_lastpos) throw jj_ls;</span>
<span class="fc" id="L9814">	 return false;</span>
  }


  /**
   * @return the next Token.
   */
  public final Token getNextToken() {
<span class="nc bnc" id="L9822" title="All 2 branches missed.">   if (token.next != null)</span>
<span class="nc" id="L9823">     token = token.next;</span>
   else
<span class="nc" id="L9825">     token = token.next = token_source.getNextToken();</span>
<span class="nc" id="L9826">	 jj_ntk = -1;</span>
<span class="nc" id="L9827">	 jj_gen++;</span>
<span class="nc" id="L9828">	 return token;</span>
  }

  /**
   * @param index index to be retrieved
   * @return the specific Token.
   */
  public final Token getToken(final int index) {
<span class="fc bfc" id="L9836" title="All 2 branches covered.">    Token t = jj_lookingAhead ? jj_scanpos : token;</span>
<span class="fc bfc" id="L9837" title="All 2 branches covered.">    for (int i = 0; i &lt; index; i++) {</span>
<span class="fc bfc" id="L9838" title="All 2 branches covered.">      if (t.next == null)</span>
<span class="fc" id="L9839">        t.next = token_source.getNextToken();</span>
<span class="fc" id="L9840">      t = t.next;</span>
    }
<span class="fc" id="L9842">    return t;</span>
  }

  private int jj_ntk_f() {
<span class="fc" id="L9846">    jj_nt = token.next;</span>
<span class="fc bfc" id="L9847" title="All 2 branches covered.">    if (jj_nt == null) {</span>
<span class="fc" id="L9848">      token.next = token_source.getNextToken();</span>
<span class="fc" id="L9849">      jj_ntk = token.next.kind;</span>
<span class="fc" id="L9850">      return jj_ntk;</span>
    }
<span class="fc" id="L9852">    jj_ntk = jj_nt.kind;</span>
<span class="fc" id="L9853">    return jj_ntk;</span>
  }

<span class="pc" id="L9856">  private java.util.List&lt;int[]&gt; jj_expentries = new java.util.ArrayList&lt;&gt;();</span>
  private int[] jj_expentry;
<span class="pc" id="L9858">  private int jj_kind = -1;</span>
<span class="pc" id="L9859">  private int[] jj_lasttokens = new int[100];</span>
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
<span class="pc bpc" id="L9863" title="1 of 2 branches missed.">  if (pos &gt;= 100) {</span>
<span class="nc" id="L9864">    return;</span>
  }

<span class="fc bfc" id="L9867" title="All 2 branches covered.">  if (pos == jj_endpos + 1) {</span>
<span class="fc" id="L9868">    jj_lasttokens[jj_endpos++] = kind;</span>
<span class="fc bfc" id="L9869" title="All 2 branches covered.">  } else if (jj_endpos != 0) {</span>
<span class="fc" id="L9870">    jj_expentry = new int[jj_endpos];</span>

<span class="fc bfc" id="L9872" title="All 2 branches covered.">    for (int i = 0; i &lt; jj_endpos; i++) {</span>
<span class="fc" id="L9873">      jj_expentry[i] = jj_lasttokens[i];</span>
    }

<span class="fc bfc" id="L9876" title="All 2 branches covered.">    for (final int[] oldentry : jj_expentries) {</span>
<span class="pc bpc" id="L9877" title="1 of 2 branches missed.">      if (oldentry.length == jj_expentry.length) {</span>
<span class="fc" id="L9878">        boolean isMatched = true;</span>
<span class="fc bfc" id="L9879" title="All 2 branches covered.">        for (int i = 0; i &lt; jj_expentry.length; i++) {</span>
<span class="fc bfc" id="L9880" title="All 2 branches covered.">          if (oldentry[i] != jj_expentry[i]) {</span>
<span class="fc" id="L9881">            isMatched = false;</span>
<span class="fc" id="L9882">            break;</span>
          }
        }
<span class="fc bfc" id="L9885" title="All 2 branches covered.">        if (isMatched) {</span>
<span class="fc" id="L9886">          jj_expentries.add(jj_expentry);</span>
<span class="fc" id="L9887">          break;</span>
        }
      }
<span class="fc" id="L9890">    }</span>

<span class="fc bfc" id="L9892" title="All 2 branches covered.">    if (pos != 0) {</span>
<span class="fc" id="L9893">      jj_endpos = pos;</span>
<span class="fc" id="L9894">      jj_lasttokens[jj_endpos - 1] = kind;</span>
    }
  }
<span class="fc" id="L9897">}</span>

  /**
   * Generate ParseException.
   * @return new Exception object. Never &lt;code&gt;null&lt;/code&gt;
   */
  public ParseException generateParseException() {
<span class="fc" id="L9904">    jj_expentries.clear();</span>
<span class="fc" id="L9905">    boolean[] la1tokens = new boolean[130];</span>
<span class="pc bpc" id="L9906" title="1 of 2 branches missed.">    if (jj_kind &gt;= 0) {</span>
<span class="fc" id="L9907">      la1tokens[jj_kind] = true;</span>
<span class="fc" id="L9908">      jj_kind = -1;</span>
    }
<span class="fc bfc" id="L9910" title="All 2 branches covered.">    for (int i = 0; i &lt; 151; i++) {</span>
<span class="fc bfc" id="L9911" title="All 2 branches covered.">      if (jj_la1[i] == jj_gen) {</span>
<span class="fc bfc" id="L9912" title="All 2 branches covered.">        for (int j = 0; j &lt; 32; j++) {</span>
<span class="pc bpc" id="L9913" title="1 of 2 branches missed.">          if ((jj_la1_0[i] &amp; (1&lt;&lt;j)) != 0) {</span>
<span class="nc" id="L9914">            la1tokens[j] = true;</span>
          }
<span class="pc bpc" id="L9916" title="1 of 2 branches missed.">          if ((jj_la1_1[i] &amp; (1&lt;&lt;j)) != 0) {</span>
<span class="nc" id="L9917">            la1tokens[32+j] = true;</span>
          }
<span class="fc bfc" id="L9919" title="All 2 branches covered.">          if ((jj_la1_2[i] &amp; (1&lt;&lt;j)) != 0) {</span>
<span class="fc" id="L9920">            la1tokens[64+j] = true;</span>
          }
<span class="fc bfc" id="L9922" title="All 2 branches covered.">          if ((jj_la1_3[i] &amp; (1&lt;&lt;j)) != 0) {</span>
<span class="fc" id="L9923">            la1tokens[96+j] = true;</span>
          }
<span class="pc bpc" id="L9925" title="1 of 2 branches missed.">          if ((jj_la1_4[i] &amp; (1&lt;&lt;j)) != 0) {</span>
<span class="nc" id="L9926">            la1tokens[128+j] = true;</span>
          }
        }
      }
    }
<span class="fc bfc" id="L9931" title="All 2 branches covered.">    for (int i = 0; i &lt; 130; i++) {</span>
<span class="fc bfc" id="L9932" title="All 2 branches covered.">      if (la1tokens[i]) {</span>
<span class="fc" id="L9933">        jj_expentry = new int[1];</span>
<span class="fc" id="L9934">        jj_expentry[0] = i;</span>
<span class="fc" id="L9935">        jj_expentries.add(jj_expentry);</span>
      }
    }
<span class="fc" id="L9938">    jj_endpos = 0;</span>
<span class="fc" id="L9939">    jj_rescan_token();</span>
<span class="fc" id="L9940">    jj_add_error_token(0, 0);</span>
<span class="fc" id="L9941">    int[][] exptokseq = new int[jj_expentries.size()][];</span>
<span class="fc bfc" id="L9942" title="All 2 branches covered.">    for (int i = 0; i &lt; jj_expentries.size(); i++) {</span>
<span class="fc" id="L9943">      exptokseq[i] = jj_expentries.get(i);</span>
    }
<span class="fc" id="L9945">    return new ParseException(token, exptokseq, tokenImage);</span>
  }

  /**
   * @return Always &lt;code&gt;false&lt;/code&gt;.
   */
  public final boolean trace_enabled() {
<span class="nc" id="L9952">    return false;</span>
  }

  /** Enable tracing. */
<span class="nc" id="L9956">  public final void enable_tracing() {}</span>

  /** Disable tracing. */
<span class="nc" id="L9959">  public final void disable_tracing() {}</span>

  private void jj_rescan_token() {
<span class="fc" id="L9962">    jj_rescan = true;</span>
<span class="fc bfc" id="L9963" title="All 2 branches covered.">    for (int i = 0; i &lt; 44; i++) {</span>
      try {
<span class="fc" id="L9965">        JJCalls p = jj_2_rtns[i];</span>
        do {
<span class="fc bfc" id="L9967" title="All 2 branches covered.">          if (p.gen &gt; jj_gen) {</span>
<span class="fc" id="L9968">            jj_la = p.arg;</span>
<span class="fc" id="L9969">            jj_scanpos = p.first;</span>
<span class="fc" id="L9970">            jj_lastpos = p.first;</span>
<span class="pc bpc" id="L9971" title="41 of 45 branches missed.">            switch (i) {</span>
<span class="nc" id="L9972">              case 0: jj_3_1(); break;</span>
<span class="nc" id="L9973">              case 1: jj_3_2(); break;</span>
<span class="nc" id="L9974">              case 2: jj_3_3(); break;</span>
<span class="nc" id="L9975">              case 3: jj_3_4(); break;</span>
<span class="nc" id="L9976">              case 4: jj_3_5(); break;</span>
<span class="nc" id="L9977">              case 5: jj_3_6(); break;</span>
<span class="nc" id="L9978">              case 6: jj_3_7(); break;</span>
<span class="nc" id="L9979">              case 7: jj_3_8(); break;</span>
<span class="nc" id="L9980">              case 8: jj_3_9(); break;</span>
<span class="nc" id="L9981">              case 9: jj_3_10(); break;</span>
<span class="nc" id="L9982">              case 10: jj_3_11(); break;</span>
<span class="nc" id="L9983">              case 11: jj_3_12(); break;</span>
<span class="nc" id="L9984">              case 12: jj_3_13(); break;</span>
<span class="nc" id="L9985">              case 13: jj_3_14(); break;</span>
<span class="nc" id="L9986">              case 14: jj_3_15(); break;</span>
<span class="nc" id="L9987">              case 15: jj_3_16(); break;</span>
<span class="fc" id="L9988">              case 16: jj_3_17(); break;</span>
<span class="nc" id="L9989">              case 17: jj_3_18(); break;</span>
<span class="nc" id="L9990">              case 18: jj_3_19(); break;</span>
<span class="fc" id="L9991">              case 19: jj_3_20(); break;</span>
<span class="nc" id="L9992">              case 20: jj_3_21(); break;</span>
<span class="fc" id="L9993">              case 21: jj_3_22(); break;</span>
<span class="nc" id="L9994">              case 22: jj_3_23(); break;</span>
<span class="nc" id="L9995">              case 23: jj_3_24(); break;</span>
<span class="nc" id="L9996">              case 24: jj_3_25(); break;</span>
<span class="nc" id="L9997">              case 25: jj_3_26(); break;</span>
<span class="nc" id="L9998">              case 26: jj_3_27(); break;</span>
<span class="nc" id="L9999">              case 27: jj_3_28(); break;</span>
<span class="nc" id="L10000">              case 28: jj_3_29(); break;</span>
<span class="nc" id="L10001">              case 29: jj_3_30(); break;</span>
<span class="nc" id="L10002">              case 30: jj_3_31(); break;</span>
<span class="fc" id="L10003">              case 31: jj_3_32(); break;</span>
<span class="nc" id="L10004">              case 32: jj_3_33(); break;</span>
<span class="nc" id="L10005">              case 33: jj_3_34(); break;</span>
<span class="nc" id="L10006">              case 34: jj_3_35(); break;</span>
<span class="nc" id="L10007">              case 35: jj_3_36(); break;</span>
<span class="nc" id="L10008">              case 36: jj_3_37(); break;</span>
<span class="nc" id="L10009">              case 37: jj_3_38(); break;</span>
<span class="nc" id="L10010">              case 38: jj_3_39(); break;</span>
<span class="nc" id="L10011">              case 39: jj_3_40(); break;</span>
<span class="nc" id="L10012">              case 40: jj_3_41(); break;</span>
<span class="nc" id="L10013">              case 41: jj_3_42(); break;</span>
<span class="nc" id="L10014">              case 42: jj_3_43(); break;</span>
<span class="nc" id="L10015">              case 43: jj_3_44(); break;</span>
            }
          }
<span class="fc" id="L10018">          p = p.next;</span>
<span class="pc bpc" id="L10019" title="1 of 2 branches missed.">        } while (p != null);</span>
<span class="pc" id="L10020">      } catch(LookaheadSuccess ls) { /* ignore */ }</span>
    }
<span class="fc" id="L10022">    jj_rescan = false;</span>
<span class="fc" id="L10023">  }</span>

  private void jj_save(int index, int xla) {
<span class="fc" id="L10026">    JJCalls p = jj_2_rtns[index];</span>
<span class="fc bfc" id="L10027" title="All 2 branches covered.">    while (p.gen &gt; jj_gen) {</span>
<span class="fc bfc" id="L10028" title="All 2 branches covered.">      if (p.next == null) {</span>
<span class="fc" id="L10029">        p.next = new JJCalls();</span>
<span class="fc" id="L10030">        p = p.next;</span>
<span class="fc" id="L10031">        break;</span>
      }
<span class="fc" id="L10033">      p = p.next;</span>
    }
<span class="fc" id="L10035">    p.gen = jj_gen + xla - jj_la; </span>
<span class="fc" id="L10036">    p.first = token;</span>
<span class="fc" id="L10037">    p.arg = xla;</span>
<span class="fc" id="L10038">  }</span>

<span class="fc" id="L10040">  static final class JJCalls {</span>
	 int gen;
	 Token first;
	 int arg;
	 JJCalls next;
  }

  /*************
    Attenzione il parser continua ad avere metodi come
    public ASMParser(java.io.InputStream stream) {}
    ...
    che non inizializzano correttamente il parser (ad esempio fileSpec)
    **************/
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>