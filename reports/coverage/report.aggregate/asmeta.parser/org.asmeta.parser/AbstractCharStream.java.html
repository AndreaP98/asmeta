<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AbstractCharStream.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">report.aggregate</a> &gt; <a href="../index.html" class="el_bundle">asmeta.parser</a> &gt; <a href="index.source.html" class="el_package">org.asmeta.parser</a> &gt; <span class="el_source">AbstractCharStream.java</span></div><h1>AbstractCharStream.java</h1><pre class="source lang-java linenums">/* Generated by: ParserGeneratorCC: Do not edit this line. AbstractCharStream.java Version 1.1 */
/* ParserGeneratorCCOptions:SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package org.asmeta.parser;

/**
 * An implementation of interface CharStream, where the stream is assumed to
 * contain only ASCII characters (without unicode processing).
 */

public
abstract class AbstractCharStream
implements CharStream
{
  /** Default buffer size if nothing is specified */
  public static final int DEFAULT_BUF_SIZE = 4096;

  static final int hexval (final char c) throws java.io.IOException
  {
<span class="nc bnc" id="L19" title="All 17 branches missed.">    switch (c)</span>
    {
      case '0':
<span class="nc" id="L22">        return 0;</span>
      case '1':
<span class="nc" id="L24">        return 1;</span>
      case '2':
<span class="nc" id="L26">        return 2;</span>
      case '3':
<span class="nc" id="L28">        return 3;</span>
      case '4':
<span class="nc" id="L30">        return 4;</span>
      case '5':
<span class="nc" id="L32">        return 5;</span>
      case '6':
<span class="nc" id="L34">        return 6;</span>
      case '7':
<span class="nc" id="L36">        return 7;</span>
      case '8':
<span class="nc" id="L38">        return 8;</span>
      case '9':
<span class="nc" id="L40">        return 9;</span>
      case 'a':
      case 'A':
<span class="nc" id="L43">        return 10;</span>
      case 'b':
      case 'B':
<span class="nc" id="L46">        return 11;</span>
      case 'c':
      case 'C':
<span class="nc" id="L49">        return 12;</span>
      case 'd':
      case 'D':
<span class="nc" id="L52">        return 13;</span>
      case 'e':
      case 'E':
<span class="nc" id="L55">        return 14;</span>
      case 'f':
      case 'F':
<span class="nc" id="L58">        return 15;</span>
      default:  
<span class="nc" id="L60">        throw new java.io.IOException (&quot;Invalid hex char '&quot; + c + &quot;' (=&quot; + (int) c + &quot;) provided!&quot;); </span>
    }
  }

  /** Tab size for formatting. Usually in the range 1 to 8. */
<span class="fc" id="L65">  private int m_nTabSize = 1;</span>

  /** Internal circular buffer */
  protected char[] buffer;

  /** Overall buffer size - same as buffer.length */
  protected int bufsize;

  /** Current read position in buffer. */
  protected int bufpos;
  
  /** The number of unoccupied buffer array positions */
  protected int available;
  
  /** The first array index (of `buffer`) that the current token starts */
  protected int tokenBegin;

  /** Characters in the backup/pushBack buffer */
  protected int inBuf;
  protected int maxNextCharInd;

  private int[] m_aBufLine;
  private int[] m_aBufColumn;

  // Current line number
  private int m_nLineNo;
  // Current column number
  private int m_nColumnNo;

  // Was the previous character a &quot;\r&quot; char?
  private boolean m_bPrevCharIsCR;
  // Was the previous character a &quot;\n&quot; char?
  private boolean m_bPrevCharIsLF;
  
  // Is line/column tracking enabled?
<span class="fc" id="L100">  private boolean m_bTrackLineColumn = true;</span>


  /** Constructor. */
  public AbstractCharStream(final int nStartLine,
                            final int nStartColumn, 
                            final int nBufferSize)
<span class="fc" id="L107">  {</span>
<span class="fc" id="L108">    reInit (nStartLine, nStartColumn, nBufferSize);</span>
<span class="fc" id="L109">  }</span>

  /** Reinitialise. */
  public final void reInit(final int nStartLine,
                           final int nStartColumn, 
                           final int nBufferSize)
  {
<span class="fc" id="L116">    m_nLineNo = nStartLine;</span>
<span class="fc" id="L117">    m_nColumnNo = nStartColumn - 1;</span>
<span class="fc" id="L118">    m_bPrevCharIsCR = false;</span>
<span class="fc" id="L119">    m_bPrevCharIsLF = false;</span>
<span class="pc bpc" id="L120" title="3 of 4 branches missed.">    if (buffer == null || nBufferSize != buffer.length)</span>
    {
<span class="fc" id="L122">      bufsize = nBufferSize;</span>
<span class="fc" id="L123">      available = nBufferSize;</span>
<span class="fc" id="L124">      buffer = new char[nBufferSize];</span>
<span class="fc" id="L125">      m_aBufLine = new int[nBufferSize];</span>
<span class="fc" id="L126">      m_aBufColumn = new int[nBufferSize];</span>
    }
<span class="fc" id="L128">    maxNextCharInd = 0;</span>
<span class="fc" id="L129">    inBuf = 0;</span>
<span class="fc" id="L130">    tokenBegin = 0;</span>
<span class="fc" id="L131">    bufpos = -1;</span>
<span class="fc" id="L132">  }</span>

  /**
   * Read from the underlying stream.
   * @param aBuf the buffer to be filled
   * @param nOfs The offset into the buffer. 0-based
   * @param nLen Number of chars to read.
   * @return Number of effective chars read, or -1 on error.
   */
  protected abstract int streamRead (char[] aBuf, int nOfs, int nLen) throws java.io.IOException;
  
  /**
   * Close the underlying stream.
   * @throws java.io.IOException If closing fails.
   */
  protected abstract void streamClose () throws java.io.IOException;
   
  // Override this method if you need more aggressive buffer size expansion
  protected int getBufSizeAfterExpansion ()
  {
    // Double the size by default
<span class="nc" id="L153">    return bufsize * 2;</span>
  }

  protected void expandBuff (final boolean bWrapAround)
  {
    // Get the new buffer size
<span class="nc" id="L159">    final int nNewBufSize = getBufSizeAfterExpansion ();</span>
    
<span class="nc" id="L161">    final char[] newbuffer = new char[nNewBufSize];</span>
<span class="nc" id="L162">    final int[] newbufline = new int[nNewBufSize];</span>
<span class="nc" id="L163">    final int[] newbufcolumn = new int[nNewBufSize];</span>

    // Number of chars to be preserved
<span class="nc" id="L166">    final int nPreservedChars = bufsize - tokenBegin;</span>
    
<span class="nc bnc" id="L168" title="All 2 branches missed.">    if (bWrapAround)</span>
    {
      // Move from offset &quot;tokenBegin&quot; to offset 0
      // arraycopy(src, srcPos, dest, destPos, length)

      // copy the &quot;tail end&quot; to the &quot;start&quot; (index 0) of the new buffer array 
<span class="nc" id="L174">      System.arraycopy(buffer, tokenBegin, newbuffer, 0, nPreservedChars);</span>
      
      // copy the remaining &quot;wrap around&quot; content of the buffer from the start of the original buffer (starting at srcPos index 0) 
<span class="nc" id="L177">      System.arraycopy(buffer, 0, newbuffer, nPreservedChars, bufpos);</span>
      
      // swap the new buffer in place of the old buffer
<span class="nc" id="L180">      buffer = newbuffer;</span>
      
<span class="nc" id="L182">      System.arraycopy(m_aBufLine, tokenBegin, newbufline, 0, nPreservedChars);</span>
<span class="nc" id="L183">      System.arraycopy(m_aBufLine, 0, newbufline, nPreservedChars, bufpos);</span>
<span class="nc" id="L184">      m_aBufLine = newbufline;</span>

<span class="nc" id="L186">      System.arraycopy(m_aBufColumn, tokenBegin, newbufcolumn, 0, nPreservedChars);</span>
<span class="nc" id="L187">      System.arraycopy(m_aBufColumn, 0, newbufcolumn, nPreservedChars, bufpos);</span>
<span class="nc" id="L188">      m_aBufColumn = newbufcolumn;</span>

<span class="nc" id="L190">      bufpos += nPreservedChars;</span>
<span class="nc" id="L191">      maxNextCharInd = bufpos;</span>
    }
    else
    {
      // Move from offset &quot;tokenBegin&quot; to offset 0
      
<span class="nc" id="L197">      System.arraycopy(buffer, tokenBegin, newbuffer, 0, nPreservedChars);</span>
<span class="nc" id="L198">      buffer = newbuffer;</span>

<span class="nc" id="L200">      System.arraycopy(m_aBufLine, tokenBegin, newbufline, 0, nPreservedChars);</span>
<span class="nc" id="L201">      m_aBufLine = newbufline;</span>

<span class="nc" id="L203">      System.arraycopy(m_aBufColumn, tokenBegin, newbufcolumn, 0, nPreservedChars);</span>
<span class="nc" id="L204">      m_aBufColumn = newbufcolumn;</span>

<span class="nc" id="L206">      bufpos -= tokenBegin;</span>
<span class="nc" id="L207">      maxNextCharInd = bufpos;</span>
    }

    // Increase buffer size
<span class="nc" id="L211">    bufsize = nNewBufSize;</span>
<span class="nc" id="L212">    available = nNewBufSize;</span>
<span class="nc" id="L213">    tokenBegin = 0;</span>
<span class="nc" id="L214">  }</span>

  protected final void internalAdjustBuffSize()
  {
<span class="nc" id="L218">    final int nHalfBufferSize = bufsize / 2; </span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">    if (available == bufsize)</span>
    {
<span class="nc bnc" id="L221" title="All 2 branches missed.">      if (tokenBegin &lt; 0)</span>
      {
        // If this method is called from &quot;beginToken()&quot;
        // Just refill the buffer from the start
<span class="nc" id="L225">        bufpos = 0;</span>
<span class="nc" id="L226">        maxNextCharInd = 0;</span>
      }
      else
<span class="nc bnc" id="L229" title="All 2 branches missed.">        if (tokenBegin &gt; nHalfBufferSize)</span>
        {
          // The token started in the second half - fill the front part 
<span class="nc" id="L232">          bufpos = 0;</span>
<span class="nc" id="L233">          maxNextCharInd = 0;</span>

          // Available bytes are &gt; 50%
<span class="nc" id="L236">          available = tokenBegin;</span>
        }
        else
        {
          // Token starts in the first half
          // just append to existing buffer
<span class="nc" id="L242">          expandBuff (false);</span>
        }
    }
    else
    {
      // A token was read across array boundaries 
<span class="nc bnc" id="L248" title="All 2 branches missed.">      if (available &gt; tokenBegin)</span>
      {
<span class="nc" id="L250">        available = bufsize;</span>
      }
      else
<span class="nc bnc" id="L253" title="All 2 branches missed.">        if ((tokenBegin - available) &lt; nHalfBufferSize)</span>
        {
<span class="nc" id="L255">          expandBuff (true);</span>
        }
        else
        {
<span class="nc" id="L259">          available = tokenBegin;</span>
        }
    }
<span class="nc" id="L262">  }</span>

  protected void fillBuff() throws java.io.IOException
  {
<span class="nc bnc" id="L266" title="All 2 branches missed.">    if (maxNextCharInd == available)</span>
<span class="nc" id="L267">      internalAdjustBuffSize();</span>

    try
    {
      // Read from underlying stream
<span class="nc" id="L272">      final int nCharsRead = streamRead (buffer, maxNextCharInd, available - maxNextCharInd);</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">      if (nCharsRead == -1) </span>
      {
        // We reached the end of the file
<span class="nc" id="L276">        streamClose ();</span>
        
        // Caught down below and re-thrown
<span class="nc" id="L279">        throw new java.io.IOException(&quot;PGCC end of stream&quot;);</span>
      }
<span class="nc" id="L281">      maxNextCharInd += nCharsRead;</span>
    }
<span class="nc" id="L283">    catch (final java.io.IOException ex)</span>
    {
<span class="nc" id="L285">      --bufpos;</span>
      // ?What is the reason of this? Backup of 0 does nothing
<span class="nc" id="L287">      backup (0);</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">      if (tokenBegin == -1)</span>
      {
        // Error occurred in &quot;beginToken()&quot;
<span class="nc" id="L291">        tokenBegin = bufpos;</span>
      }
<span class="nc" id="L293">      throw ex;</span>
<span class="nc" id="L294">    }</span>
<span class="nc" id="L295">  }</span>

  protected final void internalSetBufLineColumn (final int nLine, final int nColumn)
  {
<span class="fc" id="L299">    m_aBufLine[bufpos] = nLine;</span>
<span class="fc" id="L300">    m_aBufColumn[bufpos] = nColumn;</span>
<span class="fc" id="L301">  }</span>

  protected final void internalUpdateLineColumn(final char c)
  {
<span class="fc" id="L305">    m_nColumnNo++;</span>

<span class="fc bfc" id="L307" title="All 2 branches covered.">    if (m_bPrevCharIsLF)</span>
    {
      // It's a &quot;\r\n&quot; or &quot;\n&quot;
      // Start of a new line
<span class="fc" id="L311">      m_bPrevCharIsLF = false;</span>
<span class="fc" id="L312">      m_nColumnNo = 1;</span>
<span class="fc" id="L313">      m_nLineNo++;</span>
    }
    else
<span class="fc bfc" id="L316" title="All 2 branches covered.">      if (m_bPrevCharIsCR)</span>
      {
<span class="fc" id="L318">        m_bPrevCharIsCR = false;</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">        if (c == '\n')</span>
        {
          // It's a &quot;\r\n&quot;
<span class="fc" id="L322">          m_bPrevCharIsLF = true;</span>
        }
        else
        {
          // It's only a &quot;\r&quot;
<span class="fc" id="L327">          m_nColumnNo = 1;</span>
<span class="fc" id="L328">          m_nLineNo++;</span>
        }
      }

<span class="fc bfc" id="L332" title="All 4 branches covered.">    switch (c)</span>
    {
      case '\r':
<span class="fc" id="L335">        m_bPrevCharIsCR = true;</span>
<span class="fc" id="L336">        break;</span>
      case '\n':
<span class="fc" id="L338">        m_bPrevCharIsLF = true;</span>
<span class="fc" id="L339">        break;</span>
      case '\t':
<span class="fc" id="L341">        m_nColumnNo--;</span>
<span class="fc" id="L342">        m_nColumnNo += (m_nTabSize - (m_nColumnNo % m_nTabSize));</span>
        break;
    }

<span class="fc" id="L346">    internalSetBufLineColumn (m_nLineNo, m_nColumnNo);</span>
<span class="fc" id="L347">  }</span>

  public char readChar() throws java.io.IOException
  {
<span class="nc bnc" id="L351" title="All 2 branches missed.">    if (inBuf &gt; 0)</span>
    {
      // Something is left from last backup
<span class="nc" id="L354">      --inBuf;</span>

<span class="nc" id="L356">      ++bufpos;</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">      if (bufpos == bufsize)</span>
      {
        // Buffer overflow
<span class="nc" id="L360">        bufpos = 0;</span>
      }

<span class="nc" id="L363">      return buffer[bufpos];</span>
    }

<span class="nc" id="L366">    ++bufpos;</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">    if (bufpos &gt;= maxNextCharInd)</span>
<span class="nc" id="L368">      fillBuff();</span>

<span class="nc" id="L370">    final char c = buffer[bufpos];</span>

<span class="nc bnc" id="L372" title="All 2 branches missed.">    if (m_bTrackLineColumn)</span>
<span class="nc" id="L373">      internalUpdateLineColumn(c);</span>
<span class="nc" id="L374">    return c;</span>
  }

  public char beginToken() throws java.io.IOException
  {
<span class="nc" id="L379">    tokenBegin = -1;</span>
<span class="nc" id="L380">    final char c = readChar();</span>
<span class="nc" id="L381">    tokenBegin = bufpos;</span>
<span class="nc" id="L382">    return c;</span>
  }

  public int getBeginColumn ()
  {
<span class="fc" id="L387">    return m_aBufColumn[tokenBegin];</span>
  }

  public int getBeginLine ()
  {
<span class="fc" id="L392">    return m_aBufLine[tokenBegin];</span>
  }

  public int getEndColumn ()
  {
<span class="fc" id="L397">    return m_aBufColumn[bufpos];</span>
  }

  public int getEndLine ()
  {
<span class="fc" id="L402">     return m_aBufLine[bufpos];</span>
  }

  public void backup (final int nAmount)
  {
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">    if (nAmount &gt; bufsize)</span>
<span class="nc" id="L408">      throw new IllegalStateException (&quot;Cannot back &quot; + nAmount + &quot; chars which is larger than the internal buffer size (&quot; + bufsize + &quot;)&quot;);</span>
  
<span class="fc" id="L410">    inBuf += nAmount;</span>
<span class="fc" id="L411">    bufpos -= nAmount;</span>
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">    if (bufpos &lt; 0)</span>
    {
      // Buffer underflow (modulo)
<span class="nc" id="L415">      bufpos += bufsize;</span>
    }
<span class="fc" id="L417">  }</span>

  public String getImage()
  {
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">    if (bufpos &gt;= tokenBegin)</span>
    {
      // from tokenBegin to bufpos
<span class="fc" id="L424">      return new String (buffer, tokenBegin, bufpos - tokenBegin + 1);</span>
    }

    // from tokenBegin to bufsize, and from 0 to bufpos
<span class="nc" id="L428">    return new String (buffer, tokenBegin, bufsize - tokenBegin) +</span>
           new String (buffer, 0, bufpos + 1);
  }

  public char[] getSuffix (final int len)
  {
<span class="nc" id="L434">    char[] ret = new char[len];</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">    if ((bufpos + 1) &gt;= len)</span>
    {
      // one piece
<span class="nc" id="L438">      System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);</span>
    }
    else
    {
      // Wrap around
<span class="nc" id="L443">      final int nPart1 = len - bufpos - 1;</span>
<span class="nc" id="L444">      System.arraycopy(buffer, bufsize - nPart1, ret, 0, nPart1);</span>
<span class="nc" id="L445">      System.arraycopy(buffer, 0, ret, nPart1, bufpos + 1);</span>
    }
<span class="nc" id="L447">    return ret;</span>
  }

  public void done()
  {
<span class="nc" id="L452">    buffer = null;</span>
<span class="nc" id="L453">    m_aBufLine = null;</span>
<span class="nc" id="L454">    m_aBufColumn = null;</span>
<span class="nc" id="L455">  }</span>
 
  public final int getTabSize()
  { 
<span class="nc" id="L459">    return m_nTabSize;</span>
  }

  public final void setTabSize (final int nTabSize)
  { 
<span class="nc" id="L464">    m_nTabSize = nTabSize;</span>
<span class="nc" id="L465">  }</span>

  /**
   * Method to adjust line and column numbers for the start of a token.
   * This is used internally to 
   */
  public final void adjustBeginLineColumn(final int nNewLine, final int newCol)
  {
<span class="nc" id="L473">    int start = tokenBegin;</span>
<span class="nc" id="L474">    int newLine = nNewLine;</span>
    
    int len;
<span class="nc bnc" id="L477" title="All 2 branches missed.">    if (bufpos &gt;= tokenBegin)</span>
    {
<span class="nc" id="L479">      len = bufpos - tokenBegin + inBuf + 1;</span>
    }
    else
    {
<span class="nc" id="L483">      len = bufsize - tokenBegin + bufpos + 1 + inBuf;</span>
    }

<span class="nc" id="L486">    int i = 0;</span>
<span class="nc" id="L487">    int j = 0;</span>
<span class="nc" id="L488">    int k = 0;</span>
<span class="nc" id="L489">    int nextColDiff = 0;</span>
<span class="nc" id="L490">    int columnDiff = 0;</span>

    // TODO disassemble meaning and split up
<span class="nc bnc" id="L493" title="All 4 branches missed.">    while (i &lt; len &amp;&amp; m_aBufLine[j = start % bufsize] == m_aBufLine[k = ++start % bufsize])</span>
    {
<span class="nc" id="L495">      m_aBufLine[j] = newLine;</span>
<span class="nc" id="L496">      nextColDiff = columnDiff + m_aBufColumn[k] - m_aBufColumn[j];</span>
<span class="nc" id="L497">      m_aBufColumn[j] = newCol + columnDiff;</span>
<span class="nc" id="L498">      columnDiff = nextColDiff;</span>
<span class="nc" id="L499">      i++;</span>
    }

<span class="nc bnc" id="L502" title="All 2 branches missed.">    if (i &lt; len)</span>
    {
<span class="nc" id="L504">      m_aBufLine[j] = newLine++;</span>
<span class="nc" id="L505">      m_aBufColumn[j] = newCol + columnDiff;</span>

<span class="nc bnc" id="L507" title="All 2 branches missed.">      while (i++ &lt; len)</span>
      {
        // TODO disassemble meaning and split up
<span class="nc bnc" id="L510" title="All 2 branches missed.">        if (m_aBufLine[j = start % bufsize] != m_aBufLine[++start % bufsize])</span>
<span class="nc" id="L511">          m_aBufLine[j] = newLine++;</span>
        else
<span class="nc" id="L513">          m_aBufLine[j] = newLine;</span>
      }
    }

<span class="nc" id="L517">    m_nLineNo = m_aBufLine[j];</span>
<span class="nc" id="L518">    m_nColumnNo = m_aBufColumn[j];</span>
<span class="nc" id="L519">  }</span>
  
  /**
   * @return the current line number. 0-based.
   */
  protected final int getLine ()
  { 
<span class="fc" id="L526">    return m_nLineNo;</span>
  }
  
  /**
   * @return the current column number. 0-based.
   */
  protected final int getColumn ()
  { 
<span class="fc" id="L534">    return m_nColumnNo;</span>
  }
  
  public final boolean isTrackLineColumn ()
  { 
<span class="fc" id="L539">    return m_bTrackLineColumn;</span>
  }

  public final void setTrackLineColumn (final boolean bTrackLineColumn)
  { 
<span class="nc" id="L544">    m_bTrackLineColumn = bTrackLineColumn;</span>
<span class="nc" id="L545">  }</span>
}
/* ParserGeneratorCC - OriginalChecksum=b4ecace9281398097aa5fe5579f193c6 (do not edit this line) */
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>