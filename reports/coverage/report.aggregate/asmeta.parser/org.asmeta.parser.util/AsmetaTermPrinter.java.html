<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AsmetaTermPrinter.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">report.aggregate</a> &gt; <a href="../index.html" class="el_bundle">asmeta.parser</a> &gt; <a href="index.source.html" class="el_package">org.asmeta.parser.util</a> &gt; <span class="el_source">AsmetaTermPrinter.java</span></div><h1>AsmetaTermPrinter.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2005, 2006 ASMETA group (http://asmeta.sourceforge.net)
 * License Information: http://asmeta.sourceforge.net/licensing/
 * 
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License version 2 as
 *   published by the Free Software Foundation.
 * 
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 * 
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301
 *   USA
 * 
 *   http://www.gnu.org/licenses/gpl.txt
 * 
 *   
 *******************************************************************************/

/*
 * AsmetaTermPrinter.java
 *
 * Created on 26 giugno 2006, 10.47
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */

package org.asmeta.parser.util;

import java.util.Collection;
import java.util.Iterator;

import org.asmeta.parser.Defs;
import org.eclipse.emf.common.util.EList;

import asmeta.definitions.domains.Domain;
import asmeta.definitions.domains.PowersetDomain;
import asmeta.definitions.domains.RuleDomain;
import asmeta.terms.basicterms.BooleanTerm;
import asmeta.terms.basicterms.DomainTerm;
import asmeta.terms.basicterms.FunctionTerm;
import asmeta.terms.basicterms.LocationTerm;
import asmeta.terms.basicterms.RuleAsTerm;
import asmeta.terms.basicterms.SetTerm;
import asmeta.terms.basicterms.Term;
import asmeta.terms.basicterms.TupleTerm;
import asmeta.terms.basicterms.UndefTerm;
import asmeta.terms.basicterms.VariableTerm;
import asmeta.terms.furtherterms.BagCt;
import asmeta.terms.furtherterms.BagTerm;
import asmeta.terms.furtherterms.CaseTerm;
import asmeta.terms.furtherterms.ComprehensionTerm;
import asmeta.terms.furtherterms.ConditionalTerm;
import asmeta.terms.furtherterms.EnumTerm;
import asmeta.terms.furtherterms.ExistTerm;
import asmeta.terms.furtherterms.FiniteQuantificationTerm;
import asmeta.terms.furtherterms.ForallTerm;
import asmeta.terms.furtherterms.IntegerTerm;
import asmeta.terms.furtherterms.LetTerm;
import asmeta.terms.furtherterms.NaturalTerm;
import asmeta.terms.furtherterms.RealTerm;
import asmeta.terms.furtherterms.SequenceCt;
import asmeta.terms.furtherterms.SequenceTerm;
import asmeta.terms.furtherterms.SetCt;

/**
 * A term printer.
 * 
 */
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">public class AsmetaTermPrinter extends ReflectiveVisitor&lt;String&gt; {</span>

	/**
	 * Fully qualified name flag.
	 * 
	 */
	protected boolean showAsmName;

	/**
	 * Creates a term printer.
	 * 
	 * @param showAsmName
	 *            if true show the fully qualified name
	 */
<span class="fc" id="L89">	public AsmetaTermPrinter(boolean showAsmName) {</span>
<span class="fc" id="L90">		this.showAsmName = showAsmName;</span>
<span class="fc" id="L91">	}</span>

	/**
	 * Converts a term into string.
	 * 
	 * @param term
	 *            a term
	 * @return a string
	 */
	public String visit(Term term) {
<span class="fc" id="L101">		return visit((Object) term);</span>
	}

	/**
	 * Converts a variable term into string.
	 * 
	 * @param term
	 *            a term
	 * @return a string
	 */
	public String visit(VariableTerm variable) {
<span class="fc" id="L112">		return variable.getName();</span>
	}

	/**
	 * Converts a tuple term into string.
	 * 
	 * @param term
	 *            a term
	 * @return a string
	 */
	public String visit(TupleTerm tuple) {
<span class="fc bfc" id="L123" title="All 2 branches covered.">		return tuple == null ? &quot;&quot; : visit(tuple.getTerms(), &quot;(&quot;, &quot;)&quot;);</span>
	}

	/**
	 * Converts a function term into string.
	 * 
	 * @param term
	 *            a term
	 * @return a string
	 */
	public String visit(FunctionTerm function) {
<span class="fc" id="L134">		StringBuilder s = new StringBuilder();</span>
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">		if (showAsmName)</span>
<span class="nc" id="L136">			s.append(Defs.getAsmName(function.getFunction()) + &quot;::&quot;);</span>
<span class="fc" id="L137">		s.append(function.getFunction().getName());</span>
<span class="fc" id="L138">		s.append(visit(function.getArguments()));</span>
<span class="fc" id="L139">		return s.toString();</span>
	}

	/**
	 * Converts a location term into string.
	 * 
	 * @param term
	 *            a term
	 * @return a string
	 */
	public String visit(LocationTerm location) {
<span class="fc" id="L150">		return visit((FunctionTerm) location);</span>
	}

	/**
	 * Converts a conditional term into string.
	 * 
	 * @param term
	 *            a term
	 * @return a string
	 */
	public String visit(ConditionalTerm cond) {
<span class="fc" id="L161">		return &quot;if &quot; + visit(cond.getGuard()) + &quot; then &quot; + visit(cond.getThenTerm())</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">				+ (cond.getElseTerm() == null ? &quot;&quot; : &quot; else &quot; + visit(cond.getElseTerm())) + &quot; endif&quot;;</span>
	}

	/**
	 * Converts a case term into string.
	 * 
	 * @param term
	 *            a term
	 * @return a string
	 */
	public String visit(CaseTerm caseTerm) {
<span class="fc" id="L173">		StringBuilder s = new StringBuilder();</span>
<span class="fc" id="L174">		s.append(&quot;switch &quot; + visit(caseTerm.getComparedTerm()));</span>
<span class="fc" id="L175">		Iterator&lt;Term&gt; resultIt = caseTerm.getResultTerms().iterator();</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">		for (Term comp : caseTerm.getComparingTerm()) {</span>
<span class="fc" id="L177">			Term result = resultIt.next();</span>
<span class="fc" id="L178">			s.append(&quot; case &quot; + visit(comp) + &quot;:&quot; + visit(result));</span>
<span class="fc" id="L179">		}</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">		if (caseTerm.getOtherwiseTerm() != null) {</span>
<span class="fc" id="L181">			s.append(&quot; otherwise &quot; + visit(caseTerm.getOtherwiseTerm()));</span>
		}
<span class="fc" id="L183">		s.append(&quot; endswitch&quot;);</span>
<span class="fc" id="L184">		return s.toString();</span>
	}

	/**
	 * Converts an exist term into string.
	 * 
	 * @param term
	 *            a term
	 * @return a string
	 */
	public String visit(ExistTerm exist) {
<span class="fc" id="L195">		return visitQuant(exist, &quot;exist&quot;);</span>
	}

	/**
	 * Converts a forall term into string.
	 * 
	 * @param term
	 *            a term
	 * @return a string
	 */
	public String visit(ForallTerm forall) {
<span class="fc" id="L206">		return visitQuant(forall, &quot;forall&quot;);</span>
	}

	/**
	 * Converte in stringa un &lt;i&gt;FiniteQuantificationTerm&lt;/i&gt;.
	 * 
	 * @param term
	 *            termine da convertire
	 * @param quantName
	 *            &quot;exist&quot; o &quot;forall&quot;
	 * @return la rappresentazione in stringa del termine
	 */
	/**
	 * Converts a finite quantification term into string.
	 * 
	 * @param quantTerm
	 *            a finite quantification term
	 * @param quantName
	 *            &quot;exist&quot; or &quot;forall&quot;
	 * @return a string
	 */
	protected String visitQuant(FiniteQuantificationTerm quantTerm, String quantName) {
<span class="fc" id="L228">		StringBuilder s = new StringBuilder();</span>
<span class="fc" id="L229">		s.append(&quot;(&quot; + quantName + &quot; &quot;);</span>
<span class="pc bpc" id="L230" title="2 of 4 branches missed.">		assert quantTerm.getVariable().size() &gt; 0: quantTerm;</span>
<span class="fc" id="L231">		Iterator&lt;VariableTerm&gt; variableIt = quantTerm.getVariable().iterator();</span>
<span class="fc" id="L232">		Iterator&lt;Term&gt; rangeIt = quantTerm.getRanges().iterator();</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">		if (variableIt.hasNext()) {</span>
<span class="fc" id="L234">			VariableTerm variable = variableIt.next();</span>
<span class="fc" id="L235">			Term range = rangeIt.next();</span>
<span class="fc" id="L236">			s.append(visit(variable) + &quot; in &quot; + visit(range));</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">			while (variableIt.hasNext()) {</span>
<span class="fc" id="L238">				variable = variableIt.next();</span>
<span class="fc" id="L239">				range = rangeIt.next();</span>
<span class="fc" id="L240">				s.append(&quot;,&quot; + visit(variable) + &quot; in &quot; + visit(range));</span>
			}
		}
<span class="fc" id="L243">		Term guard = quantTerm.getGuard();</span>
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">		if (guard != null)</span>
<span class="fc" id="L245">			s.append(&quot; with &quot; + visit(guard));</span>
<span class="fc" id="L246">		s.append(&quot;)&quot;);</span>
		//System.out.println(s.toString());
<span class="fc" id="L248">		return s.toString();</span>
	}

	/**
	 * Converts a let term into string.
	 * 
	 * @param term
	 *            a term
	 * @return a string
	 */
	public String visit(LetTerm let) {
<span class="fc" id="L259">		StringBuilder s = new StringBuilder();</span>
<span class="fc" id="L260">		s.append(&quot;let(&quot;);</span>
<span class="fc" id="L261">		Iterator&lt;?&gt;/* &lt;VariableTerm&gt; */ varIt = let.getVariable().iterator();</span>
<span class="fc" id="L262">		Iterator&lt;?&gt;/* &lt;Term&gt; */ initIt = let.getAssignmentTerm().iterator();</span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">		if (varIt.hasNext()) {</span>
<span class="fc" id="L264">			VariableTerm var = (VariableTerm) varIt.next();</span>
<span class="fc" id="L265">			Term init = (Term) initIt.next();</span>
<span class="fc" id="L266">			s.append(visit(var) + &quot;=&quot; + visit(init));</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">			while (varIt.hasNext()) {</span>
<span class="fc" id="L268">				var = (VariableTerm) varIt.next();</span>
<span class="fc" id="L269">				init = (Term) initIt.next();</span>
<span class="fc" id="L270">				s.append(&quot;,&quot; + visit(var) + &quot;=&quot; + visit(init));</span>
			}
		}
<span class="fc" id="L273">		s.append(&quot;) in &quot; + visit(let.getBody()) + &quot; endlet&quot;);</span>
<span class="fc" id="L274">		return s.toString();</span>
	}

	/**
	 * Converts a domain term into string.
	 * 
	 * @param term
	 *            a term
	 * @return a string
	 */
	public String visit(DomainTerm term) {
<span class="fc" id="L285">		PowersetDomain dom = (PowersetDomain) term.getDomain();</span>
<span class="fc" id="L286">		Domain base = dom.getBaseDomain();</span>
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">		return (showAsmName ? Defs.getAsmName(base) + &quot;::&quot; : &quot;&quot;) + base.getName();</span>
	}

	/**
	 * Converts a set comprehension term into string.
	 * 
	 * @param term
	 *            a term
	 * @return a string
	 */
	public String visit(SetCt ct) {
<span class="fc" id="L298">		return visitCt(ct, &quot;{&quot;, &quot;}&quot;);</span>
	}

	/**
	 * Converts a sequence comprehension term into string.
	 * 
	 * @param term
	 *            a term
	 * @return a string
	 */
	public String visit(SequenceCt ct) {
<span class="nc" id="L309">		return visitCt(ct, &quot;[&quot;, &quot;]&quot;);</span>
	}

	/**
	 * Converts a bag comprehension term into string.
	 * 
	 * @param term
	 *            a term
	 * @return a string
	 */
	public String visit(BagCt bt) {
<span class="nc" id="L320">		return visitCt(bt, &quot;&lt;&quot;, &quot;&gt;&quot;);</span>
	}

	/**
	 * Converts a comprehension term into string.
	 * 
	 * @param ct
	 *            a comprehension term
	 * @param startStr
	 *            &quot;{&quot; or &quot;[&quot;
	 * @param stopStr
	 *            &quot;}&quot; or &quot;]&quot;
	 * @return a string
	 */
	protected String visitCt(ComprehensionTerm ct, String startStr, String stopStr) {
<span class="pc bpc" id="L335" title="2 of 4 branches missed.">		assert (ct.getTerm() != null);</span>
<span class="fc" id="L336">		StringBuilder s = new StringBuilder();</span>
<span class="fc" id="L337">		s.append(startStr);</span>
<span class="fc" id="L338">		Iterator&lt;VariableTerm&gt; variableIt = ct.getVariable().iterator();</span>
<span class="fc" id="L339">		Iterator&lt;Term&gt; rangeIt = ct.getRanges().iterator();</span>
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">		if (variableIt.hasNext()) {</span>
<span class="fc" id="L341">			VariableTerm variable = variableIt.next();</span>
<span class="fc" id="L342">			Term range = rangeIt.next();</span>
<span class="fc" id="L343">			s.append(visit(variable) + &quot; in &quot; + visit(range));</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">			while (variableIt.hasNext()) {</span>
<span class="fc" id="L345">				variable = variableIt.next();</span>
<span class="fc" id="L346">				range = rangeIt.next();</span>
<span class="fc" id="L347">				s.append(&quot;,&quot; + visit(variable) + &quot; in &quot; + visit(range));</span>
			}
		}
<span class="fc" id="L350">		Term guard = ct.getGuard();</span>
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">		if (guard != null) {</span>
<span class="fc" id="L352">			s.append(&quot;| &quot; + visit(ct.getGuard()) + &quot; : &quot;);</span>
		}
<span class="fc" id="L354">		s.append(visit(ct.getTerm()));</span>
<span class="fc" id="L355">		s.append(stopStr);</span>
<span class="fc" id="L356">		return s.toString();</span>
	}

	/**
	 * Converts a set term into string.
	 * 
	 * @param term
	 *            a term
	 * @return a string
	 */
	public String visit(SetTerm setTerm) {
<span class="fc" id="L367">		return visit(setTerm.getTerm(), &quot;{&quot;, &quot;}&quot;);</span>
	}

	/**
	 * Converts a sequence term into string.
	 * 
	 * @param term
	 *            a term
	 * @return a string
	 */
	public String visit(SequenceTerm sequence) {
<span class="nc" id="L378">		return visit(sequence.getTerms(), &quot;[&quot;, &quot;]&quot;);</span>
	}

	/**
	 * Converts a bag term into string.
	 * 
	 * @param term
	 *            a term
	 * @return a string
	 */
	public String visit(BagTerm bag) {
<span class="nc" id="L389">		return visit(bag.getTerm(), &quot;&lt;&quot;, &quot;&gt;&quot;);</span>
	}

	/**
	 * Converts a rule as term into string.
	 * 
	 * @param term
	 *            a term
	 * @return a string
	 */
	public String visit(RuleAsTerm term) {
<span class="nc" id="L400">		Domain domain = term.getDomain();</span>
<span class="nc" id="L401">		StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">		if (domain != null) {</span>
<span class="nc bnc" id="L403" title="All 4 branches missed.">			assert domain instanceof RuleDomain;</span>
<span class="nc" id="L404">			EList&lt;Domain&gt; domains = ((RuleDomain) domain).getDomains();</span>
<span class="nc" id="L405">			sb.append(&quot;(&quot;);</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">			for (int i = 0; i &lt; domains.size() - 1; i++) {</span>
<span class="nc" id="L407">				sb.append(domains.get(i).getName() + &quot;, &quot;);</span>
			}
<span class="nc" id="L409">			sb.append(domains.get(domains.size() - 1).getName() + &quot;)&quot;);</span>
		}
<span class="nc bnc" id="L411" title="All 2 branches missed.">		return &quot;&lt;&lt;&quot; + (showAsmName ? Defs.getAsmName(term.getRule()) + &quot;::&quot; : &quot;&quot;) + term.getRule().getName()</span>
<span class="nc" id="L412">				+ sb.toString() + &quot;&gt;&gt;&quot;;</span>
	}

	/**
	 * Converts a natural term into string.
	 * 
	 * @param term
	 *            a term
	 * @return a string
	 */
	public String visit(NaturalTerm number) {
<span class="fc" id="L423">		return number.getSymbol();</span>
	}

	/**
	 * Converts an integer term into string.
	 * 
	 * @param term
	 *            a term
	 * @return a string
	 */
	public String visit(IntegerTerm number) {
<span class="fc" id="L434">		return number.getSymbol();</span>
	}

	/**
	 * Converts a real term into string.
	 * 
	 * @param term
	 *            a term
	 * @return a string
	 */
	public String visit(RealTerm number) {
<span class="fc" id="L445">		return number.getSymbol();</span>
	}

	/**
	 * Converts a boolean term into string.
	 * 
	 * @param term
	 *            a term
	 * @return a string
	 */
	public String visit(BooleanTerm bool) {
<span class="fc" id="L456">        return bool.getSymbol();</span>
    }
	
	
	/**
	 * Converts a string term into string.
	 * 
	 * @param term
	 *            a term
	 * @return a string
	 */
	public String visit(asmeta.terms.furtherterms.StringTerm st) {
		// string term does not contain the &quot;&quot; already
		// AG 2018/07/31
<span class="pc bpc" id="L470" title="2 of 4 branches missed.">		assert !st.getSymbol().startsWith(&quot;\&quot;&quot;);</span>
<span class="pc bpc" id="L471" title="2 of 4 branches missed.">		assert !st.getSymbol().endsWith(&quot;\&quot;&quot;);</span>
		// TODO it may contain a &quot; that should be escaped in the output
<span class="pc bpc" id="L473" title="2 of 4 branches missed.">		assert !st.getSymbol().contains(&quot;\&quot;&quot;);</span>
<span class="fc" id="L474">		return &quot;\&quot;&quot; + st.getSymbol() + &quot;\&quot;&quot;;</span>
	}

	/**
	 * Converts an enumeration term into string.
	 * 
	 * @param term
	 *            a term
	 * @return a string
	 */
	public String visit(EnumTerm enumTerm) {
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">		return (showAsmName ? Defs.getAsmName(enumTerm.getDomain()) + &quot;::&quot; : &quot;&quot;) + enumTerm.getSymbol();</span>
	}

	/**
	 * Converts a mapTerm into string.
	 * 
	 * @param term
	 *            a term
	 * @return a string
	 */
	public String visit(asmeta.terms.furtherterms.MapTerm mapT) {
<span class="fc" id="L496">		StringBuilder s = new StringBuilder(&quot;{&quot;);</span>
<span class="fc" id="L497">		EList&lt;TupleTerm&gt; pairs = mapT.getPair();</span>
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">		if (pairs != null) {</span>
<span class="fc" id="L499">			boolean first = true;</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">			for (TupleTerm pairTT : pairs) {</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">				if (first)</span>
<span class="fc" id="L502">					first = false;</span>
				else
<span class="fc" id="L504">					s.append(&quot;,&quot;);</span>
<span class="fc" id="L505">				EList&lt;Term&gt; pair = pairTT.getTerms();</span>
<span class="fc" id="L506">				s.append(visit(pair.get(0)));</span>
<span class="fc" id="L507">				s.append(&quot;-&gt;&quot;);</span>
<span class="fc" id="L508">				s.append(visit(pair.get(1)));</span>
<span class="fc" id="L509">			}</span>
		}
<span class="fc" id="L511">		s.append(&quot;}&quot;);</span>
<span class="fc" id="L512">		return s.toString();</span>
	}

	/**
	 * Converts a collection of terms into string.
	 * 
	 * @param collection
	 *            a collection
	 * @param startStr
	 *            e.g. &quot;(&quot;
	 * @param stopStr
	 *            e.g. &quot;)&quot;
	 * @return a string
	 */
	public String visit(Collection&lt;? extends Term&gt; collection, String startStr, String stopStr) {
<span class="fc" id="L527">		StringBuilder s = new StringBuilder();</span>
<span class="fc" id="L528">		s.append(startStr);</span>
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">		if (collection != null) {</span>
<span class="fc" id="L530">			Iterator&lt;? extends Term&gt; iterator = collection.iterator();</span>
<span class="fc bfc" id="L531" title="All 2 branches covered.">			if (iterator.hasNext()) {</span>
<span class="fc" id="L532">				Term term = iterator.next();</span>
<span class="fc" id="L533">				s.append(visit(term));</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">				while (iterator.hasNext()) {</span>
<span class="fc" id="L535">					term = iterator.next();</span>
<span class="fc" id="L536">					s.append(&quot;,&quot; + visit(term));</span>
				}
			}
		}
<span class="fc" id="L540">		s.append(stopStr);</span>
<span class="fc" id="L541">		return s.toString();</span>
	}

	/**
	 * Converts an undefined term into string.
	 * 
	 * @param term
	 *            a term
	 * @return a string
	 */
	public String visit(UndefTerm undef) {
<span class="fc" id="L552">		return &quot;undef&quot;;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>