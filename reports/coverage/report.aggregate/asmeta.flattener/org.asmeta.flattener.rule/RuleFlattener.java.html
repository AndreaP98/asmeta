<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>RuleFlattener.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">report.aggregate</a> &gt; <a href="../index.html" class="el_bundle">asmeta.flattener</a> &gt; <a href="index.source.html" class="el_package">org.asmeta.flattener.rule</a> &gt; <span class="el_source">RuleFlattener.java</span></div><h1>RuleFlattener.java</h1><pre class="source lang-java linenums">package org.asmeta.flattener.rule;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.log4j.Logger;
import org.asmeta.flattener.term.DomainVisitor;
import org.asmeta.flattener.term.TermRenameVars;
import org.asmeta.parser.util.ReflectiveVisitor;
import org.asmeta.simulator.wrapper.RuleFactory;
import org.eclipse.emf.common.util.EList;

import asmeta.definitions.RuleDeclaration;
import asmeta.structure.Asm;
import asmeta.terms.basicterms.Term;
import asmeta.terms.basicterms.VariableTerm;
import asmeta.transitionrules.basictransitionrules.BlockRule;
import asmeta.transitionrules.basictransitionrules.ChooseRule;
import asmeta.transitionrules.basictransitionrules.ConditionalRule;
import asmeta.transitionrules.basictransitionrules.ExtendRule;
import asmeta.transitionrules.basictransitionrules.ForallRule;
import asmeta.transitionrules.basictransitionrules.LetRule;
import asmeta.transitionrules.basictransitionrules.MacroCallRule;
import asmeta.transitionrules.basictransitionrules.MacroDeclaration;
import asmeta.transitionrules.basictransitionrules.Rule;
import asmeta.transitionrules.basictransitionrules.SkipRule;
import asmeta.transitionrules.basictransitionrules.TermAsRule;
import asmeta.transitionrules.basictransitionrules.UpdateRule;
import asmeta.transitionrules.derivedtransitionrules.CaseRule;
import asmeta.transitionrules.turbotransitionrules.SeqRule;

<span class="pc bpc" id="L34" title="1 of 2 branches missed.">public abstract class RuleFlattener extends ReflectiveVisitor&lt;Rule&gt; implements AsmetaFlattener {</span>
<span class="fc" id="L35">	static final Logger logger = Logger.getLogger(RuleFlattener.class);</span>
<span class="fc" id="L36">	private static int counterForLogicVars = 0;</span>
<span class="fc" id="L37">	protected RuleFactory ruleFact = new RuleFactory();</span>
	protected Asm asm;
<span class="fc" id="L39">	protected TermRenameVars trv = new TermRenameVars();</span>
	protected DomainVisitor dv;
<span class="fc" id="L41">	protected boolean rename = false;</span>
	// public static boolean DO_STATS = true;

<span class="fc" id="L44">	public RuleFlattener(Asm asm) {</span>
<span class="fc" id="L45">		this.asm = asm;</span>
<span class="fc" id="L46">	}</span>

	@Override
	public Asm flattenASM() {
<span class="fc" id="L50">		List&lt;RuleDeclaration&gt; rules = asm.getBodySection().getRuleDeclaration();</span>
<span class="fc bfc" id="L51" title="All 2 branches covered.">		for (RuleDeclaration r : rules) {</span>
<span class="fc" id="L52">			Rule ruleBody = r.getRuleBody();</span>
<span class="pc bpc" id="L53" title="2 of 4 branches missed.">			assert ruleBody != null;</span>
<span class="fc" id="L54">			r.setRuleBody(visit(ruleBody));</span>
<span class="fc" id="L55">		}</span>
<span class="fc" id="L56">		return asm;</span>
	}

	public Rule visit(BlockRule blockRule) {
<span class="fc" id="L60">		int numRules = blockRule.getRules().size();</span>
<span class="fc" id="L61">		BlockRule newBlockRule = ruleFact.createBlockRule();</span>
<span class="fc" id="L62">		List&lt;Rule&gt; newRules = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L63" title="All 2 branches covered.">		for (Rule rule : blockRule.getRules()) {</span>
<span class="fc" id="L64">			newRules.add(visit(rule));</span>
<span class="fc" id="L65">		}</span>
<span class="fc" id="L66">		newBlockRule.getRules().addAll(newRules);</span>
<span class="pc bpc" id="L67" title="2 of 4 branches missed.">		assert numRules == newBlockRule.getRules().size();</span>
<span class="fc" id="L68">		return newBlockRule;</span>
	}

	public Rule visit(SeqRule seqRule) {
<span class="nc" id="L72">		SeqRule newSeqRule = ruleFact.createSeqRule();</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">		for (Rule rule : seqRule.getRules()) {</span>
<span class="nc" id="L74">			newSeqRule.getRules().add(visit(rule));</span>
<span class="nc" id="L75">		}</span>
<span class="nc" id="L76">		return newSeqRule;</span>
	}

	public Rule visit(CaseRule caseRule) {
<span class="fc" id="L80">		CaseRule newCaseRule = ruleFact.createCaseRule();</span>
<span class="fc" id="L81">		newCaseRule.setTerm(trv.visit(caseRule.getTerm()));</span>
<span class="fc bfc" id="L82" title="All 2 branches covered.">		for (Term caseTerm : caseRule.getCaseTerm()) {</span>
<span class="fc" id="L83">			newCaseRule.getCaseTerm().add(trv.visit(caseTerm));</span>
<span class="fc" id="L84">		}</span>
<span class="fc bfc" id="L85" title="All 2 branches covered.">		for (Rule branch : caseRule.getCaseBranches()) {</span>
<span class="fc" id="L86">			newCaseRule.getCaseBranches().add(visit(branch));</span>
<span class="fc" id="L87">		}</span>
<span class="fc" id="L88">		Rule otherwise = caseRule.getOtherwiseBranch();</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">		if (otherwise != null) {</span>
<span class="fc" id="L90">			newCaseRule.setOtherwiseBranch(visit(otherwise));</span>
		}
<span class="fc" id="L92">		return newCaseRule;</span>
	}

	public Rule visit(ChooseRule chooseRule) {
<span class="fc" id="L96">		ChooseRule newChooseRule = ruleFact.createChooseRule();</span>

<span class="fc" id="L98">		Map&lt;VariableTerm, Term&gt; variablesMap = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">		if (rename) {</span>
<span class="fc" id="L100">			logger.debug(&quot;variables renamed&quot;);</span>
			// logic variables must be renamed as the rule could be duplicated
<span class="fc bfc" id="L102" title="All 2 branches covered.">			for (VariableTerm vt : chooseRule.getVariable()) {</span>
<span class="fc" id="L103">				VariableTerm newVt = ruleFact.createVariableTerm();</span>
<span class="fc" id="L104">				newVt.setDomain(vt.getDomain());</span>
<span class="fc" id="L105">				newVt.setName(vt.getName() + (counterForLogicVars++));</span>
<span class="fc" id="L106">				variablesMap.put(vt, newVt);</span>
<span class="fc" id="L107">			}</span>
<span class="fc" id="L108">			logger.debug(&quot;new map &quot; + variablesMap);</span>
<span class="fc" id="L109">			trv.addMap(variablesMap);</span>
		}
<span class="fc" id="L111">		EList&lt;VariableTerm&gt; newVars = newChooseRule.getVariable();</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">		for (VariableTerm v : chooseRule.getVariable()) {</span>
<span class="fc" id="L113">			newVars.add((VariableTerm) trv.visit(v));</span>
<span class="fc" id="L114">		}</span>
<span class="fc" id="L115">		newChooseRule.getRanges().addAll(chooseRule.getRanges());</span>
<span class="fc" id="L116">		newChooseRule.setDoRule(visit(chooseRule.getDoRule()));</span>
<span class="pc bpc" id="L117" title="2 of 4 branches missed.">		assert newChooseRule.getDoRule() != null;</span>
<span class="fc" id="L118">		newChooseRule.setGuard(trv.visit(chooseRule.getGuard()));</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">		if (chooseRule.getIfnone() != null) {</span>
<span class="fc" id="L120">			newChooseRule.setIfnone(visit(chooseRule.getIfnone()));</span>
		}
<span class="fc bfc" id="L122" title="All 2 branches covered.">		if (rename) {</span>
			// System.out.println(&quot;variable map reset&quot;);
<span class="fc" id="L124">			trv.removeMap(variablesMap);</span>
		}
<span class="fc" id="L126">		return newChooseRule;</span>
	}

	public Rule visit(ConditionalRule conditionalRule) {
<span class="fc" id="L130">		ConditionalRule newCondRule = ruleFact.createConditionalRule();</span>
<span class="fc" id="L131">		newCondRule.setGuard(trv.visit(conditionalRule.getGuard()));</span>
<span class="pc bpc" id="L132" title="2 of 4 branches missed.">		assert conditionalRule.getThenRule() != null;</span>
<span class="fc" id="L133">		newCondRule.setThenRule(visit(conditionalRule.getThenRule()));</span>
<span class="fc" id="L134">		Rule elseRule = conditionalRule.getElseRule();</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">		if (elseRule != null) {</span>
<span class="fc" id="L136">			newCondRule.setElseRule(visit(elseRule));</span>
		}
<span class="fc" id="L138">		return newCondRule;</span>
	}

	public Rule visit(ExtendRule extendRule) {
<span class="nc" id="L142">		ExtendRule newExtendRule = ruleFact.createExtendRule();</span>
<span class="nc" id="L143">		newExtendRule.setExtendedDomain(extendRule.getExtendedDomain());</span>

<span class="nc" id="L145">		Map&lt;VariableTerm, Term&gt; variablesMap = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">		if (rename) {</span>
<span class="nc" id="L147">			logger.debug(&quot;variables renamed&quot;);</span>
			// logic variables must be renamed as the rule could be duplicated
<span class="nc bnc" id="L149" title="All 2 branches missed.">			for (VariableTerm vt : extendRule.getBoundVar()) {</span>
<span class="nc" id="L150">				VariableTerm newVt = ruleFact.createVariableTerm();</span>
<span class="nc" id="L151">				newVt.setDomain(vt.getDomain());</span>
<span class="nc" id="L152">				newVt.setName(vt.getName() + (counterForLogicVars++));</span>
<span class="nc" id="L153">				variablesMap.put(vt, newVt);</span>
<span class="nc" id="L154">			}</span>
<span class="nc" id="L155">			logger.debug(&quot;new map &quot; + variablesMap);</span>
<span class="nc" id="L156">			trv.addMap(variablesMap);</span>
		}
<span class="nc" id="L158">		List&lt;VariableTerm&gt; newVars = new ArrayList&lt;VariableTerm&gt;();</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">		for (VariableTerm v : extendRule.getBoundVar()) {</span>
<span class="nc" id="L160">			newVars.add((VariableTerm) trv.visit(v));</span>
<span class="nc" id="L161">		}</span>
<span class="nc" id="L162">		newExtendRule.getBoundVar().addAll(newVars);</span>

<span class="nc" id="L164">		Rule doRule = extendRule.getDoRule();</span>
<span class="nc bnc" id="L165" title="All 4 branches missed.">		assert doRule != null;</span>
<span class="nc" id="L166">		newExtendRule.setDoRule(visit(doRule));</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">		if (rename) {</span>
<span class="nc" id="L168">			trv.removeMap(variablesMap);</span>
		}
<span class="nc" id="L170">		return newExtendRule;</span>
	}

	public Rule visit(ForallRule forallRule) {
<span class="fc" id="L174">		ForallRule newForallRule = ruleFact.createForallRule();</span>

		// logic variables must be renamed as the rule could be duplicated
<span class="fc" id="L177">		Map&lt;VariableTerm, Term&gt; variablesMap = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">		if (rename) {</span>
<span class="fc" id="L179">			logger.debug(&quot;variables renamed&quot;);</span>

<span class="fc bfc" id="L181" title="All 2 branches covered.">			for (VariableTerm vt : forallRule.getVariable()) {</span>
<span class="fc" id="L182">				VariableTerm newVt = ruleFact.createVariableTerm();</span>
<span class="fc" id="L183">				newVt.setDomain(vt.getDomain());</span>
<span class="fc" id="L184">				String varName = vt.getName() + (counterForLogicVars++);</span>
<span class="fc" id="L185">				newVt.setName(varName);</span>
<span class="fc" id="L186">				variablesMap.put(vt, newVt);</span>
<span class="fc" id="L187">				logger.debug(vt + &quot; -&gt; &quot; + newVt);</span>
<span class="fc" id="L188">			}</span>
<span class="fc" id="L189">			trv.addMap(variablesMap);</span>
		}
<span class="fc" id="L191">		EList&lt;VariableTerm&gt; newVars = newForallRule.getVariable();</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">		for (VariableTerm v : forallRule.getVariable()) {</span>
<span class="fc" id="L193">			newVars.add((VariableTerm) trv.visit(v));</span>
<span class="fc" id="L194">		}</span>
<span class="fc" id="L195">		newForallRule.getRanges().addAll(forallRule.getRanges());</span>
<span class="fc" id="L196">		newForallRule.setDoRule(visit(forallRule.getDoRule()));</span>
<span class="fc" id="L197">		newForallRule.setGuard(trv.visit(forallRule.getGuard()));</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">		if (rename) {</span>
<span class="fc" id="L199">			trv.removeMap(variablesMap);</span>
		}
<span class="fc" id="L201">		return newForallRule;</span>
	}

	public Rule visit(LetRule letRule) {
<span class="fc" id="L205">		LetRule newLetRule = ruleFact.createLetRule();</span>
		// logic variables must be renamed as the rule could be duplicated
<span class="fc" id="L207">		Map&lt;VariableTerm, Term&gt; variablesMap = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">		if (rename) {</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">			for (VariableTerm vt : letRule.getVariable()) {</span>
<span class="fc" id="L210">				VariableTerm newVt = ruleFact.createVariableTerm();</span>
<span class="fc" id="L211">				newVt.setDomain(vt.getDomain());</span>
				// newVt.setName(vt.getName() + (counterForLogicVars++));
<span class="fc" id="L213">				newVt.setName(vt.getName());</span>
<span class="fc" id="L214">				variablesMap.put(vt, newVt);</span>
<span class="fc" id="L215">			}</span>
<span class="fc" id="L216">			trv.addMap(variablesMap);</span>
		}
<span class="fc" id="L218">		List&lt;VariableTerm&gt; newVars = newLetRule.getVariable();</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">		for (VariableTerm v : letRule.getVariable()) {</span>
<span class="fc" id="L220">			newVars.add((VariableTerm) trv.visit(v));</span>
<span class="fc" id="L221">		}</span>
<span class="fc" id="L222">		List&lt;Term&gt; newInit = newLetRule.getInitExpression();</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">		for (Term init : letRule.getInitExpression()) {</span>
<span class="fc" id="L224">			newInit.add(trv.visit(init));</span>
<span class="fc" id="L225">		}</span>
<span class="fc" id="L226">		newLetRule.setInRule(visit(letRule.getInRule()));</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">		if (rename) {</span>
<span class="fc" id="L228">			trv.removeMap(variablesMap);</span>
		}
<span class="fc" id="L230">		return newLetRule;</span>
	}

	public Rule visit(MacroCallRule macroCallRule) {
<span class="fc" id="L234">		MacroCallRule newMacroCallRule = ruleFact.createMacroCallRule();</span>
<span class="fc" id="L235">		MacroDeclaration calledMacro = macroCallRule.getCalledMacro();</span>
<span class="fc" id="L236">		newMacroCallRule.setCalledMacro(calledMacro);</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">		for (Term p : macroCallRule.getParameters()) {</span>
<span class="fc" id="L238">			newMacroCallRule.getParameters().add(trv.visit(p));</span>
<span class="fc" id="L239">		}</span>
<span class="fc" id="L240">		return newMacroCallRule;</span>
	}

	public Rule visit(SkipRule skipRule) {
<span class="fc" id="L244">		return ruleFact.createSkipRule();</span>
	}

	public Rule visit(TermAsRule termAsRule) {
<span class="fc" id="L248">		TermAsRule newTermAsRule = ruleFact.createTermAsRule();</span>
<span class="fc" id="L249">		newTermAsRule.setTerm(trv.visit(termAsRule.getTerm()));</span>
<span class="fc" id="L250">		EList&lt;Term&gt; newParameters = newTermAsRule.getParameters();</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">		for (Term p : termAsRule.getParameters()) {</span>
<span class="nc" id="L252">			newParameters.add(trv.visit(p));</span>
<span class="nc" id="L253">		}</span>
		//System.out.println(((FunctionTermImpl)newTermAsRule.getTerm()).getFunction().getName());
<span class="fc" id="L255">		return newTermAsRule;</span>
	}

	public Rule visit(UpdateRule updateRule) {
<span class="fc" id="L259">		UpdateRule newUpdateRule = ruleFact.createUpdateRule();</span>
<span class="fc" id="L260">		newUpdateRule.setLocation(trv.visit(updateRule.getLocation()));</span>
<span class="fc" id="L261">		newUpdateRule.setUpdatingTerm(trv.visit(updateRule.getUpdatingTerm()));</span>
<span class="fc" id="L262">		return newUpdateRule;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>