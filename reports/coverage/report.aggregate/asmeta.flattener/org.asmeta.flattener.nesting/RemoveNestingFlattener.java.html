<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>RemoveNestingFlattener.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">report.aggregate</a> &gt; <a href="../index.html" class="el_bundle">asmeta.flattener</a> &gt; <a href="index.source.html" class="el_package">org.asmeta.flattener.nesting</a> &gt; <span class="el_source">RemoveNestingFlattener.java</span></div><h1>RemoveNestingFlattener.java</h1><pre class="source lang-java linenums">package org.asmeta.flattener.nesting;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;

import org.apache.log4j.Logger;
import org.asmeta.flattener.rule.AsmetaFlattener;
import org.asmeta.flattener.term.Utils;
import org.asmeta.flattener.util.StdlFunction;
import org.asmeta.parser.util.ReflectiveVisitor;
import org.asmeta.simulator.wrapper.RuleFactory;

import asmeta.definitions.RuleDeclaration;
import asmeta.structure.Asm;
import asmeta.terms.basicterms.Term;
import asmeta.transitionrules.basictransitionrules.BlockRule;
import asmeta.transitionrules.basictransitionrules.ChooseRule;
import asmeta.transitionrules.basictransitionrules.ConditionalRule;
import asmeta.transitionrules.basictransitionrules.ExtendRule;
import asmeta.transitionrules.basictransitionrules.ForallRule;
import asmeta.transitionrules.basictransitionrules.LetRule;
import asmeta.transitionrules.basictransitionrules.MacroCallRule;
import asmeta.transitionrules.basictransitionrules.Rule;
import asmeta.transitionrules.basictransitionrules.SkipRule;
import asmeta.transitionrules.basictransitionrules.TermAsRule;
import asmeta.transitionrules.basictransitionrules.UpdateRule;
import asmeta.transitionrules.derivedtransitionrules.CaseRule;
import asmeta.transitionrules.turbotransitionrules.SeqRule;

<span class="pc bpc" id="L33" title="1 of 2 branches missed.">public class RemoveNestingFlattener extends ReflectiveVisitor&lt;Void&gt; implements AsmetaFlattener {</span>
<span class="fc" id="L34">	static final Logger logger = Logger.getLogger(RemoveNestingFlattener.class);</span>
	private StdlFunction stdlFunction;
	private RuleFactory ruleFact;
	private Stack&lt;Term&gt; guardsStack;
	private ArrayList&lt;Term&gt; currentGuard;
	private Map&lt;ArrayList&lt;Term&gt;, ArrayList&lt;Rule&gt;&gt; guardsRulesMap;
	Asm asm;

<span class="fc" id="L42">	public RemoveNestingFlattener(Asm asm) {</span>
<span class="fc" id="L43">		stdlFunction = new StdlFunction(asm);</span>
<span class="fc" id="L44">		ruleFact = new RuleFactory();</span>
<span class="fc" id="L45">		guardsStack = new Stack&lt;&gt;();</span>
<span class="fc" id="L46">		guardsRulesMap = new HashMap&lt;ArrayList&lt;Term&gt;, ArrayList&lt;Rule&gt;&gt;();</span>
<span class="fc" id="L47">		currentGuard = new ArrayList&lt;Term&gt;();</span>
		// visit main rule of asm and load the information on guardsRulesMap
<span class="fc" id="L49">		this.asm = asm;</span>
<span class="fc" id="L50">	}</span>

	private void addRule(Rule rule) {
<span class="fc" id="L53">		ArrayList&lt;Rule&gt; rulesList = guardsRulesMap.get(currentGuard);</span>
<span class="fc bfc" id="L54" title="All 2 branches covered.">		if (rulesList == null) {</span>
			// initialize the list
<span class="fc" id="L56">			rulesList = new ArrayList&lt;Rule&gt;();</span>
		}
<span class="fc" id="L58">		rulesList.add(rule);</span>
<span class="fc" id="L59">		guardsRulesMap.put((ArrayList&lt;Term&gt;) currentGuard.clone(), rulesList);</span>
<span class="fc" id="L60">	}</span>

	// it creates the current guard from the union of the nested guards (stored into
	// the stack)
	private void calcCurrentGuard() {
<span class="fc" id="L65">		currentGuard.clear();</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">		for (Term t : guardsStack) {</span>
<span class="fc" id="L67">			currentGuard.add(t);</span>
<span class="fc" id="L68">		}</span>
<span class="fc" id="L69">	}</span>

<span class="fc" id="L71">	public static boolean PROPAGATE_EQ = false;</span>
	
	private Rule createNewRule() {
		// create a PAR of IFs
<span class="fc" id="L75">		BlockRule par = ruleFact.createBlockRule();</span>
		// assert guardsRulesMap.keySet().size() &gt; 0;
<span class="fc" id="L77">		List&lt;Rule&gt; parRules = par.getRules();</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">		for (ArrayList&lt;Term&gt; bt : guardsRulesMap.keySet()) {</span>
			// set updates without condition
<span class="fc" id="L80">			ArrayList&lt;Rule&gt; rulesList = guardsRulesMap.get(bt);</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">			if (bt.size() == 0) {</span>
<span class="fc bfc" id="L82" title="All 2 branches covered.">				if (rulesList.size() == 1) {</span>
<span class="fc" id="L83">					parRules.add(rulesList.get(0));</span>
				} else {
					// if there are more rules
<span class="fc" id="L86">					BlockRule par2 = ruleFact.createBlockRule();</span>
<span class="fc" id="L87">					List&lt;Rule&gt; par2rules = par2.getRules();</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">					for (Rule r : rulesList) {</span>
<span class="fc" id="L89">						par2rules.add(r);</span>
<span class="fc" id="L90">					}</span>
<span class="fc" id="L91">					parRules.add(par2);</span>
<span class="fc" id="L92">				}</span>
			} else {
<span class="fc" id="L94">				ConditionalRule condRule = ruleFact.createConditionalRule();</span>
				// set guard for every conditional rule, it's created by combining(and) each
				// &quot;nested&quot; guard
				ArrayList&lt;Term&gt; newList;
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">				if(PROPAGATE_EQ) {</span>
<span class="nc" id="L99">					newList = Utils.propagateEq(bt);</span>
				}
				else {
<span class="fc" id="L102">					newList = bt;</span>
				}
<span class="fc" id="L104">				condRule.setGuard(stdlFunction.and(newList));</span>
				// set rule/rules
<span class="fc bfc" id="L106" title="All 2 branches covered.">				if (rulesList.size() == 1) {</span>
					// if there is a single rule
<span class="fc" id="L108">					condRule.setThenRule(rulesList.get(0));</span>
				} else {
					// if there are more rules
<span class="fc" id="L111">					BlockRule par2 = ruleFact.createBlockRule();</span>
<span class="fc" id="L112">					List&lt;Rule&gt; par2rules = par2.getRules();</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">					for (Rule r : rulesList) {</span>
<span class="fc" id="L114">						par2rules.add(r);</span>
<span class="fc" id="L115">					}</span>
<span class="fc" id="L116">					condRule.setThenRule(par2);</span>
				}
				// add every IF to the PAR
<span class="fc" id="L119">				parRules.add(condRule);</span>
			}
<span class="fc" id="L121">		}</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">		if (parRules.size() &gt; 1) {</span>
<span class="fc" id="L123">			return par;</span>
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">		} else if (parRules.size() == 1) {</span>
<span class="fc" id="L125">			return parRules.get(0);</span>
		}
<span class="nc" id="L127">		return null;</span>
	}

	@Override
	public Asm flattenASM() {
		/*
		 * MacroDeclaration mainrule = asm.getMainrule(); Rule mainRuleBody =
		 * mainrule.getRuleBody(); visit(mainRuleBody); Rule newRule = createNewRule();
		 * mainrule.setRuleBody(newRule); return asm;
		 */
<span class="fc" id="L137">		List&lt;RuleDeclaration&gt; rules = asm.getBodySection().getRuleDeclaration();</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">		for (RuleDeclaration r : rules) {</span>
<span class="fc" id="L139">			logger.debug(&quot;visiting &quot; + r.getName());</span>
<span class="fc" id="L140">			visit(r.getRuleBody());</span>
<span class="fc" id="L141">			Rule newRule = createNewRule();</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">			if (r != null) {</span>
<span class="fc" id="L143">				r.setRuleBody(newRule);</span>
			}
<span class="fc" id="L145">			guardsRulesMap.clear();</span>
<span class="pc bpc" id="L146" title="2 of 4 branches missed.">			assert guardsStack.isEmpty();</span>
<span class="pc bpc" id="L147" title="2 of 4 branches missed.">			assert currentGuard.isEmpty();</span>
<span class="fc" id="L148">		}</span>
<span class="fc" id="L149">		return asm;</span>
	}

	public Map&lt;ArrayList&lt;Term&gt;, ArrayList&lt;Rule&gt;&gt; getGuardsRulesMap() {
<span class="nc" id="L153">		return guardsRulesMap;</span>
	}

	public Void visit(BlockRule blockRule) {
<span class="fc bfc" id="L157" title="All 2 branches covered.">		for (Rule rule : blockRule.getRules()) {</span>
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">			if (rule != null) {</span>
<span class="fc" id="L159">				this.visit(rule);</span>
			}
<span class="fc" id="L161">		}</span>
<span class="fc" id="L162">		return null;</span>
	}

	public Void visit(CaseRule caseRule) {
		// flattening CaseBranches
		RemoveNestingFlattener rnf;
<span class="fc" id="L168">		CaseRule newCaseRule = ruleFact.createCaseRule();</span>
<span class="fc" id="L169">		List&lt;Rule&gt; branches = newCaseRule.getCaseBranches();</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">		for (Rule rule : caseRule.getCaseBranches()) {</span>
<span class="pc bpc" id="L171" title="2 of 4 branches missed.">			assert rule != null;</span>
<span class="fc" id="L172">			rnf = new RemoveNestingFlattener(asm);</span>
<span class="fc" id="L173">			rnf.visit(rule);</span>
<span class="fc" id="L174">			branches.add(rnf.createNewRule());</span>
<span class="fc" id="L175">		}</span>

		// flattening OtherviseBranch
<span class="fc" id="L178">		Rule otherwise = caseRule.getOtherwiseBranch();</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">		if (otherwise != null) {</span>
<span class="fc" id="L180">			rnf = new RemoveNestingFlattener(asm);</span>
<span class="fc" id="L181">			rnf.visit(otherwise);</span>
<span class="fc" id="L182">			newCaseRule.setOtherwiseBranch(rnf.createNewRule());</span>
		}
<span class="fc" id="L184">		newCaseRule.setTerm(caseRule.getTerm());</span>
<span class="fc" id="L185">		newCaseRule.getCaseTerm().addAll(caseRule.getCaseTerm());</span>

		// add to map
<span class="fc" id="L188">		addRule(newCaseRule);</span>
<span class="fc" id="L189">		return null;</span>
	}

	public Void visit(ChooseRule chooseRule) {
<span class="fc" id="L193">		Rule doRule = chooseRule.getDoRule();</span>

<span class="pc bpc" id="L195" title="2 of 4 branches missed.">		assert doRule != null;</span>

		// flattening doRule
<span class="fc" id="L198">		RemoveNestingFlattener rnf = new RemoveNestingFlattener(asm);</span>
<span class="fc" id="L199">		rnf.visit(doRule);</span>
<span class="fc" id="L200">		Rule r = rnf.createNewRule();</span>

		// create a ChooseRule with the flattened doRule inside
<span class="fc" id="L203">		ChooseRule cr = ruleFact.createChooseRule();</span>
<span class="fc" id="L204">		cr.setDoRule(r);</span>
<span class="fc" id="L205">		cr.setGuard(chooseRule.getGuard());</span>
<span class="fc" id="L206">		cr.getVariable().addAll(chooseRule.getVariable());</span>
<span class="fc" id="L207">		cr.getRanges().addAll(chooseRule.getRanges());</span>

		// add to map
<span class="fc" id="L210">		addRule(cr);</span>

<span class="fc" id="L212">		return null;</span>
	}

	public Void visit(ConditionalRule conditionalRule) {
<span class="fc" id="L216">		guardsStack.push(conditionalRule.getGuard());</span>
		@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L218">		ArrayList&lt;Term&gt; oldGuard = (ArrayList&lt;Term&gt;) currentGuard.clone();</span>
<span class="fc" id="L219">		this.calcCurrentGuard();</span>

		// then branch
<span class="fc" id="L222">		Rule thenRule = conditionalRule.getThenRule();</span>
		// check if then rule is present
<span class="pc bpc" id="L224" title="2 of 4 branches missed.">		assert thenRule != null;</span>

<span class="fc" id="L226">		this.visit(thenRule);</span>

		// else branch
<span class="fc" id="L229">		Rule elseRule = conditionalRule.getElseRule();</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">		if (elseRule != null) {</span>
<span class="fc" id="L231">			Term pop = guardsStack.pop();</span>
<span class="pc bpc" id="L232" title="2 of 4 branches missed.">			assert pop != null : &quot;The stack is empty&quot;;</span>
<span class="fc" id="L233">			guardsStack.push(stdlFunction.not(pop));</span>
<span class="fc" id="L234">			this.calcCurrentGuard();</span>
<span class="fc" id="L235">			this.visit(elseRule);</span>
		}

<span class="fc" id="L238">		guardsStack.pop();</span>
		// restore the guard that it was present before this conditional rule
		// currentGuard = (ArrayList&lt;Term&gt;) oldGuard.clone();
<span class="fc" id="L241">		currentGuard = oldGuard;</span>
<span class="fc" id="L242">		return null;</span>
	}

	public Void visit(ExtendRule extendRule) {
<span class="nc" id="L246">		Rule doRule = extendRule.getDoRule();</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">		if (doRule != null) {</span>
<span class="nc" id="L248">			this.visit(doRule);</span>
		}
<span class="nc" id="L250">		return null;</span>
	}

	public Void visit(ForallRule forallRule) {
<span class="fc" id="L254">		Rule doRule = forallRule.getDoRule();</span>
		// flattening doRule rule
<span class="fc" id="L256">		RemoveNestingFlattener rnf = new RemoveNestingFlattener(asm);</span>
<span class="fc" id="L257">		rnf.visit(doRule);</span>
		// create a par of visited(and flattened) rules
<span class="fc" id="L259">		Rule r = rnf.createNewRule();</span>

		// create a forall with the flattened doRule inside
<span class="fc" id="L262">		ForallRule fr = ruleFact.createForallRule();</span>
<span class="fc" id="L263">		fr.setDoRule(r);</span>
<span class="fc" id="L264">		fr.setGuard(forallRule.getGuard());</span>
<span class="fc" id="L265">		fr.getVariable().addAll(forallRule.getVariable());</span>
<span class="fc" id="L266">		fr.getRanges().addAll(forallRule.getRanges());</span>
		// add to map
<span class="fc" id="L268">		addRule(fr);</span>
<span class="fc" id="L269">		return null;</span>
	}

	public Void visit(LetRule letRule) {
<span class="fc" id="L273">		Rule inRule = letRule.getInRule();</span>

<span class="pc bpc" id="L275" title="2 of 4 branches missed.">		assert inRule != null;</span>

		// flattening inRule
<span class="fc" id="L278">		RemoveNestingFlattener rnf = new RemoveNestingFlattener(asm);</span>
<span class="fc" id="L279">		rnf.visit(inRule);</span>
<span class="fc" id="L280">		Rule r = rnf.createNewRule();</span>

		// create a LetRule with the flattened inRule inside
<span class="fc" id="L283">		LetRule cr = ruleFact.createLetRule();</span>
<span class="fc" id="L284">		cr.getInitExpression().addAll(letRule.getInitExpression());</span>
<span class="fc" id="L285">		cr.getVariable().addAll(letRule.getVariable());</span>
<span class="fc" id="L286">		cr.setInRule(r);</span>

<span class="fc" id="L288">		addRule(cr);</span>
<span class="fc" id="L289">		return null;</span>
	}

	public Void visit(MacroCallRule macroCallRule) {
<span class="fc" id="L293">		addRule(macroCallRule);</span>
<span class="fc" id="L294">		return null;</span>
	}

	public Void visit(SeqRule seqRule) {
<span class="nc" id="L298">		SeqRule newSeqRule = ruleFact.createSeqRule();</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">		for (Rule rule : seqRule.getRules()) {</span>
<span class="nc" id="L300">			RemoveNestingFlattener rnf = new RemoveNestingFlattener(asm);</span>
<span class="nc" id="L301">			rnf.visit(rule);</span>
<span class="nc" id="L302">			Rule r = rnf.createNewRule();</span>
<span class="nc" id="L303">			newSeqRule.getRules().add(r);</span>
<span class="nc" id="L304">		}</span>
<span class="nc" id="L305">		addRule(newSeqRule);</span>
<span class="nc" id="L306">		return null;</span>
	}

	public Void visit(SkipRule skipRule) {
<span class="fc" id="L310">		addRule(skipRule);</span>
<span class="fc" id="L311">		return null;</span>
	}

	public Void visit(TermAsRule termAsRule) {
<span class="fc" id="L315">		addRule(termAsRule);</span>
<span class="fc" id="L316">		return null;</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	public Void visit(UpdateRule updateRule) {
<span class="fc" id="L321">		addRule(updateRule);</span>
		// show data inside guardsRulesMap every time there is an update
		// System.out.println(guardsRulesMap);
<span class="fc" id="L324">		return null;</span>
	}

	@Override
	public String getCode() {
<span class="nc" id="L329">		return &quot;NR&quot;;</span>
	}

	public StdlFunction getStdlFunction() {
<span class="nc" id="L333">		return stdlFunction;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>