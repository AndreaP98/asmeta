<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>StdlFunction.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">report.aggregate</a> &gt; <a href="../index.html" class="el_bundle">asmeta.flattener</a> &gt; <a href="index.source.html" class="el_package">org.asmeta.flattener.util</a> &gt; <span class="el_source">StdlFunction.java</span></div><h1>StdlFunction.java</h1><pre class="source lang-java linenums">package org.asmeta.flattener.util;

import java.util.Collection;
import java.util.Iterator;

import org.asmeta.simulator.wrapper.RuleFactory;
import org.eclipse.emf.common.util.EList;

import asmeta.definitions.Function;
import asmeta.definitions.domains.BooleanDomain;
import asmeta.definitions.domains.DomainsFactory;
import asmeta.structure.Asm;
import asmeta.terms.basicterms.FunctionTerm;
import asmeta.terms.basicterms.Term;
import asmeta.terms.basicterms.TupleTerm;

<span class="pc bpc" id="L17" title="1 of 2 branches missed.">public class StdlFunction {</span>
	private Asm asm;

<span class="fc" id="L20">	public StdlFunction(Asm asm) {</span>
<span class="fc" id="L21">		this.asm = asm;</span>
<span class="fc" id="L22">	}</span>

	public FunctionTerm not(Term term) {
<span class="fc" id="L25">		return stdlFunc(&quot;not&quot;, term);</span>
	}

	public FunctionTerm eq(Term term1, Term term2) {
<span class="fc" id="L29">		return stdlFunc(&quot;eq&quot;, term1, term2);</span>
	}

	public Term and(Collection&lt;Term&gt; operands) {
<span class="fc" id="L33">		return applyToList(operands, &quot;and&quot;);</span>
	}

	public Term or(Collection&lt;Term&gt; operands) {
<span class="nc" id="L37">		return applyToList(operands, &quot;or&quot;);</span>
	}

	private Term applyToList(Collection&lt;Term&gt; operands, String operator) {
<span class="fc" id="L41">		Iterator&lt;Term&gt; it = operands.iterator();</span>
<span class="fc bfc" id="L42" title="All 2 branches covered.">		if (operands.size() &gt; 1) {</span>
<span class="fc" id="L43">			Term first = it.next();</span>
<span class="fc" id="L44">			Term second = it.next();</span>
<span class="fc" id="L45">			FunctionTerm and = stdlFunc(operator, first, second);</span>
<span class="fc bfc" id="L46" title="All 2 branches covered.">			while (it.hasNext()) {</span>
<span class="fc" id="L47">				and = stdlFunc(operator, and, it.next());</span>
			}
<span class="fc" id="L49">			return and;</span>
		} else {
<span class="pc bpc" id="L51" title="2 of 4 branches missed.">			assert operands.size() == 1;</span>
<span class="fc" id="L52">			return it.next();</span>
		}
	}

	public FunctionTerm stdlFunc(String funcName, Term... arguments) {
<span class="fc" id="L57">		EList&lt;Function&gt; funcsSTDL = asm.getHeaderSection().getImportClause().get(0).getImportedFunction();</span>
<span class="fc" id="L58">		Function not = null;</span>
<span class="pc bpc" id="L59" title="1 of 2 branches missed.">		for (Function f : funcsSTDL) {</span>
<span class="fc bfc" id="L60" title="All 2 branches covered.">			if (f.getName().equals(funcName)) {</span>
<span class="fc" id="L61">				not = f;</span>
<span class="fc" id="L62">				break;</span>
			}
<span class="fc" id="L64">		}</span>
<span class="fc" id="L65">		RuleFactory ruleFact = new RuleFactory();</span>
<span class="fc" id="L66">		FunctionTerm ft = ruleFact.createFunctionTerm();</span>
<span class="fc" id="L67">		DomainsFactory df = DomainsFactory.eINSTANCE;</span>
<span class="fc" id="L68">		BooleanDomain boolDom = df.createBooleanDomain();</span>
<span class="fc" id="L69">		ft.setDomain(boolDom);</span>
<span class="fc" id="L70">		ft.setFunction(not);</span>
<span class="fc" id="L71">		TupleTerm args = ruleFact.createTupleTerm();</span>
<span class="fc" id="L72">		args.setArity(arguments.length);</span>
<span class="fc bfc" id="L73" title="All 2 branches covered.">		for (Term t : arguments) {</span>
<span class="fc" id="L74">			args.getTerms().add(t);</span>
		}
<span class="fc" id="L76">		ft.setArguments(args);</span>
<span class="fc" id="L77">		return ft;</span>
	}

	public Term neq(Term term1, Term term2) {
<span class="fc" id="L81">		return stdlFunc(&quot;neq&quot;, term1, term2);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>